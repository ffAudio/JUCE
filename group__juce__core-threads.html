<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>JUCE: threads</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">threads<div class="ingroups"><a class="el" href="group__juce__core.html">juce_core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classChildProcess"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classChildProcess">ChildProcess</a></td></tr>
<tr class="memdesc:classChildProcess"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launches and monitors a child process.  <a href="group__juce__core-threads.html#classChildProcess">More...</a><br/></td></tr>
<tr class="separator:classChildProcess"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classCriticalSection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a></td></tr>
<tr class="memdesc:classCriticalSection"><td class="mdescLeft">&#160;</td><td class="mdescRight">A re-entrant mutex.  <a href="group__juce__core-threads.html#classCriticalSection">More...</a><br/></td></tr>
<tr class="separator:classCriticalSection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classDummyCriticalSection"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classDummyCriticalSection">DummyCriticalSection</a></td></tr>
<tr class="memdesc:classDummyCriticalSection"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can be used in place of a real <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object, but which doesn't perform any locking.  <a href="group__juce__core-threads.html#classDummyCriticalSection">More...</a><br/></td></tr>
<tr class="separator:classDummyCriticalSection"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classDynamicLibrary"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classDynamicLibrary">DynamicLibrary</a></td></tr>
<tr class="memdesc:classDynamicLibrary"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles the opening and closing of DLLs.  <a href="group__juce__core-threads.html#classDynamicLibrary">More...</a><br/></td></tr>
<tr class="separator:classDynamicLibrary"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classHighResolutionTimer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classHighResolutionTimer">HighResolutionTimer</a></td></tr>
<tr class="memdesc:classHighResolutionTimer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A high-resolution periodic timer.  <a href="group__juce__core-threads.html#classHighResolutionTimer">More...</a><br/></td></tr>
<tr class="separator:classHighResolutionTimer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classInterProcessLock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classInterProcessLock">InterProcessLock</a></td></tr>
<tr class="memdesc:classInterProcessLock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as a critical section which processes can use to block each other.  <a href="group__juce__core-threads.html#classInterProcessLock">More...</a><br/></td></tr>
<tr class="separator:classInterProcessLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classProcess"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classProcess">Process</a></td></tr>
<tr class="memdesc:classProcess"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the current executable's process.  <a href="group__juce__core-threads.html#classProcess">More...</a><br/></td></tr>
<tr class="separator:classProcess"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classReadWriteLock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classReadWriteLock">ReadWriteLock</a></td></tr>
<tr class="memdesc:classReadWriteLock"><td class="mdescLeft">&#160;</td><td class="mdescRight">A critical section that allows multiple simultaneous readers.  <a href="group__juce__core-threads.html#classReadWriteLock">More...</a><br/></td></tr>
<tr class="separator:classReadWriteLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classGenericScopedLock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock&lt; LockType &gt;</a></td></tr>
<tr class="memdesc:classGenericScopedLock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically locks and unlocks a mutex object.  <a href="group__juce__core-threads.html#classGenericScopedLock">More...</a><br/></td></tr>
<tr class="separator:classGenericScopedLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classGenericScopedUnlock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock&lt; LockType &gt;</a></td></tr>
<tr class="memdesc:classGenericScopedUnlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically unlocks and re-locks a mutex object.  <a href="group__juce__core-threads.html#classGenericScopedUnlock">More...</a><br/></td></tr>
<tr class="separator:classGenericScopedUnlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classGenericScopedTryLock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock&lt; LockType &gt;</a></td></tr>
<tr class="memdesc:classGenericScopedTryLock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically locks and unlocks a mutex object.  <a href="group__juce__core-threads.html#classGenericScopedTryLock">More...</a><br/></td></tr>
<tr class="separator:classGenericScopedTryLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classScopedReadLock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classScopedReadLock">ScopedReadLock</a></td></tr>
<tr class="memdesc:classScopedReadLock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically locks and unlocks a <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a> object.  <a href="group__juce__core-threads.html#classScopedReadLock">More...</a><br/></td></tr>
<tr class="separator:classScopedReadLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classScopedWriteLock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classScopedWriteLock">ScopedWriteLock</a></td></tr>
<tr class="memdesc:classScopedWriteLock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically locks and unlocks a <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a> object.  <a href="group__juce__core-threads.html#classScopedWriteLock">More...</a><br/></td></tr>
<tr class="separator:classScopedWriteLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classSpinLock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classSpinLock">SpinLock</a></td></tr>
<tr class="memdesc:classSpinLock"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations.  <a href="group__juce__core-threads.html#classSpinLock">More...</a><br/></td></tr>
<tr class="separator:classSpinLock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classThread"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classThread">Thread</a></td></tr>
<tr class="memdesc:classThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a thread.  <a href="group__juce__core-threads.html#classThread">More...</a><br/></td></tr>
<tr class="separator:classThread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classThreadLocalValue"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue&lt; Type &gt;</a></td></tr>
<tr class="memdesc:classThreadLocalValue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides cross-platform support for thread-local objects.  <a href="group__juce__core-threads.html#classThreadLocalValue">More...</a><br/></td></tr>
<tr class="separator:classThreadLocalValue"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classThreadPoolJob"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a></td></tr>
<tr class="memdesc:classThreadPoolJob"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task that is executed by a <a class="el" href="group__juce__core-threads.html#classThreadPool" title="A set of threads that will run a list of jobs. ">ThreadPool</a> object.  <a href="group__juce__core-threads.html#classThreadPoolJob">More...</a><br/></td></tr>
<tr class="separator:classThreadPoolJob"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classThreadPool"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classThreadPool">ThreadPool</a></td></tr>
<tr class="memdesc:classThreadPool"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of threads that will run a list of jobs.  <a href="group__juce__core-threads.html#classThreadPool">More...</a><br/></td></tr>
<tr class="separator:classThreadPool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classTimeSliceClient"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a></td></tr>
<tr class="memdesc:classTimeSliceClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a> class.  <a href="group__juce__core-threads.html#classTimeSliceClient">More...</a><br/></td></tr>
<tr class="separator:classTimeSliceClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classTimeSliceThread"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classTimeSliceThread">TimeSliceThread</a></td></tr>
<tr class="memdesc:classTimeSliceThread"><td class="mdescLeft">&#160;</td><td class="mdescRight">A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run some sort of short task.  <a href="group__juce__core-threads.html#classTimeSliceThread">More...</a><br/></td></tr>
<tr class="separator:classTimeSliceThread"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classWaitableEvent"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#classWaitableEvent">WaitableEvent</a></td></tr>
<tr class="memdesc:classWaitableEvent"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows threads to wait for events triggered by other threads.  <a href="group__juce__core-threads.html#classWaitableEvent">More...</a><br/></td></tr>
<tr class="separator:classWaitableEvent"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacedaa6fb1373c96d2d15e7a617a5cec8"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="group__juce__core-threads.html#a586568fcce3a9c6a0f1547518fd6ddb6">CriticalSection::ScopedLockType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8">ScopedLock</a></td></tr>
<tr class="memdesc:gacedaa6fb1373c96d2d15e7a617a5cec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically locks and unlocks a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object.  <a href="#gacedaa6fb1373c96d2d15e7a617a5cec8">More...</a><br/></td></tr>
<tr class="separator:gacedaa6fb1373c96d2d15e7a617a5cec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cc435f24ace2a8f59b488ed66d9cf2c"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="group__juce__core-threads.html#a69d6b613f2638fbae341cfd06df478c7">CriticalSection::ScopedUnlockType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ga4cc435f24ace2a8f59b488ed66d9cf2c">ScopedUnlock</a></td></tr>
<tr class="memdesc:ga4cc435f24ace2a8f59b488ed66d9cf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically unlocks and re-locks a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object.  <a href="#ga4cc435f24ace2a8f59b488ed66d9cf2c">More...</a><br/></td></tr>
<tr class="separator:ga4cc435f24ace2a8f59b488ed66d9cf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3ed387d4c09d8fbfb8ad1f2db610df"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="group__juce__core-threads.html#a745e5e36d8c6a33ea1fcbbfa2fff00a3">CriticalSection::ScopedTryLockType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ga5d3ed387d4c09d8fbfb8ad1f2db610df">ScopedTryLock</a></td></tr>
<tr class="memdesc:ga5d3ed387d4c09d8fbfb8ad1f2db610df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically tries to lock and unlock a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object.  <a href="#ga5d3ed387d4c09d8fbfb8ad1f2db610df">More...</a><br/></td></tr>
<tr class="separator:ga5d3ed387d4c09d8fbfb8ad1f2db610df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classChildProcess" id="classChildProcess"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ChildProcess</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Launches and monitors a child process. </p>
<p>This class lets you launch an executable, and read its output. You can also use it to check whether the child process has finished. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a9e7be158550b4d2a470e4cceef501892"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892">StreamFlags</a> { <a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892abb52a8d118b221d35bc924efb9f48573">wantStdOut</a> = 1, 
<a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892a99e96160b71df9cd65473f410ac7090e">wantStdErr</a> = 2
 }</td></tr>
<tr class="memdesc:a9e7be158550b4d2a470e4cceef501892"><td class="mdescLeft">&#160;</td><td class="mdescRight">These flags are used by the <a class="el" href="group__juce__core-threads.html#aa5e6f939a0f0c3e87bd7c58dcec9f13c" title="Attempts to launch a child process command. ">start()</a> methods.  <a href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892">More...</a><br/></td></tr>
<tr class="separator:a9e7be158550b4d2a470e4cceef501892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a7a3ac50868578dc8b65203e4ccfb8038"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a7a3ac50868578dc8b65203e4ccfb8038">ChildProcess</a> ()</td></tr>
<tr class="memdesc:a7a3ac50868578dc8b65203e4ccfb8038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a process object.  <a href="#a7a3ac50868578dc8b65203e4ccfb8038">More...</a><br/></td></tr>
<tr class="separator:a7a3ac50868578dc8b65203e4ccfb8038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3749642d15c9fce912f9e7f9daaf52f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a3749642d15c9fce912f9e7f9daaf52f0">~ChildProcess</a> ()</td></tr>
<tr class="memdesc:a3749642d15c9fce912f9e7f9daaf52f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a3749642d15c9fce912f9e7f9daaf52f0">More...</a><br/></td></tr>
<tr class="separator:a3749642d15c9fce912f9e7f9daaf52f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e6f939a0f0c3e87bd7c58dcec9f13c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aa5e6f939a0f0c3e87bd7c58dcec9f13c">start</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;command, int streamFlags=<a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892abb52a8d118b221d35bc924efb9f48573">wantStdOut</a>|<a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892a99e96160b71df9cd65473f410ac7090e">wantStdErr</a>)</td></tr>
<tr class="memdesc:aa5e6f939a0f0c3e87bd7c58dcec9f13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to launch a child process command.  <a href="#aa5e6f939a0f0c3e87bd7c58dcec9f13c">More...</a><br/></td></tr>
<tr class="separator:aa5e6f939a0f0c3e87bd7c58dcec9f13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b54ec34a8fa09e679aed90c167cb64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae1b54ec34a8fa09e679aed90c167cb64">start</a> (const <a class="el" href="group__juce__core-text.html#classStringArray">StringArray</a> &amp;arguments, int streamFlags=<a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892abb52a8d118b221d35bc924efb9f48573">wantStdOut</a>|<a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892a99e96160b71df9cd65473f410ac7090e">wantStdErr</a>)</td></tr>
<tr class="memdesc:ae1b54ec34a8fa09e679aed90c167cb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to launch a child process command.  <a href="#ae1b54ec34a8fa09e679aed90c167cb64">More...</a><br/></td></tr>
<tr class="separator:ae1b54ec34a8fa09e679aed90c167cb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a187cc5d299c331798a7b46c3971ccd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a1a187cc5d299c331798a7b46c3971ccd">isRunning</a> () const </td></tr>
<tr class="memdesc:a1a187cc5d299c331798a7b46c3971ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the child process is alive.  <a href="#a1a187cc5d299c331798a7b46c3971ccd">More...</a><br/></td></tr>
<tr class="separator:a1a187cc5d299c331798a7b46c3971ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f8f31a8c86fadeba06b8be21e94e30"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#af6f8f31a8c86fadeba06b8be21e94e30">readProcessOutput</a> (void *destBuffer, int numBytesToRead)</td></tr>
<tr class="memdesc:af6f8f31a8c86fadeba06b8be21e94e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read some output from the child process.  <a href="#af6f8f31a8c86fadeba06b8be21e94e30">More...</a><br/></td></tr>
<tr class="separator:af6f8f31a8c86fadeba06b8be21e94e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91e215618cd1861c2e2ca13e5f4166e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-text.html#classString">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae91e215618cd1861c2e2ca13e5f4166e">readAllProcessOutput</a> ()</td></tr>
<tr class="memdesc:ae91e215618cd1861c2e2ca13e5f4166e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the process has finished, and then returns its complete output as a string.  <a href="#ae91e215618cd1861c2e2ca13e5f4166e">More...</a><br/></td></tr>
<tr class="separator:ae91e215618cd1861c2e2ca13e5f4166e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170898d07e43e68fbca86cd5f2ecca15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a170898d07e43e68fbca86cd5f2ecca15">waitForProcessToFinish</a> (int timeoutMs) const </td></tr>
<tr class="memdesc:a170898d07e43e68fbca86cd5f2ecca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the process is no longer running.  <a href="#a170898d07e43e68fbca86cd5f2ecca15">More...</a><br/></td></tr>
<tr class="separator:a170898d07e43e68fbca86cd5f2ecca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f2ca6f3bc9d38bca277e8537d579c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a46f2ca6f3bc9d38bca277e8537d579c8">getExitCode</a> () const </td></tr>
<tr class="memdesc:a46f2ca6f3bc9d38bca277e8537d579c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the process has finished, this returns its exit code.  <a href="#a46f2ca6f3bc9d38bca277e8537d579c8">More...</a><br/></td></tr>
<tr class="separator:a46f2ca6f3bc9d38bca277e8537d579c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524fd75e18a0aa94a8518ce49432413c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a524fd75e18a0aa94a8518ce49432413c">kill</a> ()</td></tr>
<tr class="memdesc:a524fd75e18a0aa94a8518ce49432413c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to kill the child process.  <a href="#a524fd75e18a0aa94a8518ce49432413c">More...</a><br/></td></tr>
<tr class="separator:a524fd75e18a0aa94a8518ce49432413c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Enumeration Documentation</h4>
<a class="anchor" id="a9e7be158550b4d2a470e4cceef501892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892">ChildProcess::StreamFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These flags are used by the <a class="el" href="group__juce__core-threads.html#aa5e6f939a0f0c3e87bd7c58dcec9f13c" title="Attempts to launch a child process command. ">start()</a> methods. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9e7be158550b4d2a470e4cceef501892abb52a8d118b221d35bc924efb9f48573"></a>wantStdOut</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e7be158550b4d2a470e4cceef501892a99e96160b71df9cd65473f410ac7090e"></a>wantStdErr</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a7a3ac50868578dc8b65203e4ccfb8038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChildProcess::ChildProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a process object. </p>
<p>To actually launch the process, use <a class="el" href="group__juce__core-threads.html#aa5e6f939a0f0c3e87bd7c58dcec9f13c" title="Attempts to launch a child process command. ">start()</a>. </p>

</div>
</div>
<a class="anchor" id="a3749642d15c9fce912f9e7f9daaf52f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ChildProcess::~ChildProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note that deleting this object won't terminate the child process. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="aa5e6f939a0f0c3e87bd7c58dcec9f13c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChildProcess::start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamFlags</em> = <code><a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892abb52a8d118b221d35bc924efb9f48573">wantStdOut</a>|<a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892a99e96160b71df9cd65473f410ac7090e">wantStdErr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to launch a child process command. </p>
<p>The command should be the name of the executable file, followed by any arguments that are required. If the process has already been launched, this will launch it again. If a problem occurs, the method will return false. The streamFlags is a combinations of values to indicate which of the child's output streams should be read and returned by <a class="el" href="group__juce__core-threads.html#af6f8f31a8c86fadeba06b8be21e94e30" title="Attempts to read some output from the child process. ">readProcessOutput()</a>. </p>

</div>
</div>
<a class="anchor" id="ae1b54ec34a8fa09e679aed90c167cb64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChildProcess::start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classStringArray">StringArray</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamFlags</em> = <code><a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892abb52a8d118b221d35bc924efb9f48573">wantStdOut</a>|<a class="el" href="group__juce__core-threads.html#a9e7be158550b4d2a470e4cceef501892a99e96160b71df9cd65473f410ac7090e">wantStdErr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to launch a child process command. </p>
<p>The first argument should be the name of the executable file, followed by any other arguments that are needed. If the process has already been launched, this will launch it again. If a problem occurs, the method will return false. The streamFlags is a combinations of values to indicate which of the child's output streams should be read and returned by <a class="el" href="group__juce__core-threads.html#af6f8f31a8c86fadeba06b8be21e94e30" title="Attempts to read some output from the child process. ">readProcessOutput()</a>. </p>

</div>
</div>
<a class="anchor" id="a1a187cc5d299c331798a7b46c3971ccd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChildProcess::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the child process is alive. </p>

</div>
</div>
<a class="anchor" id="af6f8f31a8c86fadeba06b8be21e94e30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ChildProcess::readProcessOutput </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numBytesToRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to read some output from the child process. </p>
<p>This will attempt to read up to the given number of bytes of data from the process. It returns the number of bytes that were actually read. </p>

</div>
</div>
<a class="anchor" id="ae91e215618cd1861c2e2ca13e5f4166e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-text.html#classString">String</a> ChildProcess::readAllProcessOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until the process has finished, and then returns its complete output as a string. </p>

</div>
</div>
<a class="anchor" id="a170898d07e43e68fbca86cd5f2ecca15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChildProcess::waitForProcessToFinish </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutMs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until the process is no longer running. </p>

</div>
</div>
<a class="anchor" id="a46f2ca6f3bc9d38bca277e8537d579c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> ChildProcess::getExitCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the process has finished, this returns its exit code. </p>

</div>
</div>
<a class="anchor" id="a524fd75e18a0aa94a8518ce49432413c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ChildProcess::kill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to kill the child process. </p>
<p>Returns true if it succeeded. Trying to read from the process after calling this may result in undefined behaviour. </p>

</div>
</div>

</div>
</div>
<a name="classCriticalSection" id="classCriticalSection"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class CriticalSection</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A re-entrant mutex. </p>
<p>A <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> acts as a re-entrant mutex object. The best way to lock and unlock one of these is by using RAII in the form of a local ScopedLock object - have a look through the codebase for many examples of how to do this.</p>
<p>In almost all cases you'll want to declare your <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> as a member variable. Occasionally you may want to declare one as a static variable, but in that case the usual C++ static object order-of-construction warnings should be heeded.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8" title="Automatically locks and unlocks a CriticalSection object. ">ScopedLock</a>, <a class="el" href="group__juce__core-threads.html#ga5d3ed387d4c09d8fbfb8ad1f2db610df" title="Automatically tries to lock and unlock a CriticalSection object. ">ScopedTryLock</a>, <a class="el" href="group__juce__core-threads.html#ga4cc435f24ace2a8f59b488ed66d9cf2c" title="Automatically unlocks and re-locks a CriticalSection object. ">ScopedUnlock</a>, <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a>, <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a>, <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a>, <a class="el" href="group__juce__core-threads.html#classInterProcessLock" title="Acts as a critical section which processes can use to block each other. ">InterProcessLock</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for CriticalSection:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCriticalSection__inherit__graph.svg" width="366" height="146"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a586568fcce3a9c6a0f1547518fd6ddb6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock</a><br class="typebreak"/>
&lt; <a class="el" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a586568fcce3a9c6a0f1547518fd6ddb6">ScopedLockType</a></td></tr>
<tr class="memdesc:a586568fcce3a9c6a0f1547518fd6ddb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the type of scoped lock to use with a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>.  <a href="#a586568fcce3a9c6a0f1547518fd6ddb6">More...</a><br/></td></tr>
<tr class="separator:a586568fcce3a9c6a0f1547518fd6ddb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d6b613f2638fbae341cfd06df478c7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock</a><br class="typebreak"/>
&lt; <a class="el" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a69d6b613f2638fbae341cfd06df478c7">ScopedUnlockType</a></td></tr>
<tr class="memdesc:a69d6b613f2638fbae341cfd06df478c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the type of scoped unlocker to use with a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>.  <a href="#a69d6b613f2638fbae341cfd06df478c7">More...</a><br/></td></tr>
<tr class="separator:a69d6b613f2638fbae341cfd06df478c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745e5e36d8c6a33ea1fcbbfa2fff00a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock</a><br class="typebreak"/>
&lt; <a class="el" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a745e5e36d8c6a33ea1fcbbfa2fff00a3">ScopedTryLockType</a></td></tr>
<tr class="memdesc:a745e5e36d8c6a33ea1fcbbfa2fff00a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the type of scoped try-locker to use with a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>.  <a href="#a745e5e36d8c6a33ea1fcbbfa2fff00a3">More...</a><br/></td></tr>
<tr class="separator:a745e5e36d8c6a33ea1fcbbfa2fff00a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:aaa4d9ea166cd7ce8ef369a7934e26b97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aaa4d9ea166cd7ce8ef369a7934e26b97">CriticalSection</a> () noexcept</td></tr>
<tr class="memdesc:aaa4d9ea166cd7ce8ef369a7934e26b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object.  <a href="#aaa4d9ea166cd7ce8ef369a7934e26b97">More...</a><br/></td></tr>
<tr class="separator:aaa4d9ea166cd7ce8ef369a7934e26b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ed672427d129fb5102459354d33422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae1ed672427d129fb5102459354d33422">~CriticalSection</a> () noexcept</td></tr>
<tr class="memdesc:ae1ed672427d129fb5102459354d33422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ae1ed672427d129fb5102459354d33422">More...</a><br/></td></tr>
<tr class="separator:ae1ed672427d129fb5102459354d33422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c4b0714061cc488d220b1b5a77aa1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a20c4b0714061cc488d220b1b5a77aa1c">enter</a> () const noexcept</td></tr>
<tr class="memdesc:a20c4b0714061cc488d220b1b5a77aa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock.  <a href="#a20c4b0714061cc488d220b1b5a77aa1c">More...</a><br/></td></tr>
<tr class="separator:a20c4b0714061cc488d220b1b5a77aa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c12101da7ebf8455de49652f377d313"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a2c12101da7ebf8455de49652f377d313">tryEnter</a> () const noexcept</td></tr>
<tr class="memdesc:a2c12101da7ebf8455de49652f377d313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to lock this critical section without blocking.  <a href="#a2c12101da7ebf8455de49652f377d313">More...</a><br/></td></tr>
<tr class="separator:a2c12101da7ebf8455de49652f377d313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856bbcc18f0367ae231f7277d9cb33f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a856bbcc18f0367ae231f7277d9cb33f8">exit</a> () const noexcept</td></tr>
<tr class="memdesc:a856bbcc18f0367ae231f7277d9cb33f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <a href="#a856bbcc18f0367ae231f7277d9cb33f8">More...</a><br/></td></tr>
<tr class="separator:a856bbcc18f0367ae231f7277d9cb33f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="a586568fcce3a9c6a0f1547518fd6ddb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock</a>&lt;<a class="el" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a>&gt; <a class="el" href="group__juce__core-threads.html#a586568fcce3a9c6a0f1547518fd6ddb6">CriticalSection::ScopedLockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the type of scoped lock to use with a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>. </p>

</div>
</div>
<a class="anchor" id="a69d6b613f2638fbae341cfd06df478c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock</a>&lt;<a class="el" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a>&gt; <a class="el" href="group__juce__core-threads.html#a69d6b613f2638fbae341cfd06df478c7">CriticalSection::ScopedUnlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the type of scoped unlocker to use with a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>. </p>

</div>
</div>
<a class="anchor" id="a745e5e36d8c6a33ea1fcbbfa2fff00a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock</a>&lt;<a class="el" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a>&gt; <a class="el" href="group__juce__core-threads.html#a745e5e36d8c6a33ea1fcbbfa2fff00a3">CriticalSection::ScopedTryLockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the type of scoped try-locker to use with a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="aaa4d9ea166cd7ce8ef369a7934e26b97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CriticalSection::CriticalSection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object. </p>

</div>
</div>
<a class="anchor" id="ae1ed672427d129fb5102459354d33422"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CriticalSection::~CriticalSection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If the critical section is deleted whilst locked, any subsequent behaviour is unpredictable. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a20c4b0714061cc488d220b1b5a77aa1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CriticalSection::enter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires the lock. </p>
<p>If the lock is already held by the caller thread, the method returns immediately. If the lock is currently held by another thread, this will wait until it becomes free.</p>
<p>It's strongly recommended that you never call this method directly - instead use the ScopedLock class to manage the locking using an RAII pattern instead.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a856bbcc18f0367ae231f7277d9cb33f8" title="Releases the lock. ">exit</a>, <a class="el" href="group__juce__core-threads.html#a2c12101da7ebf8455de49652f377d313" title="Attempts to lock this critical section without blocking. ">tryEnter</a>, <a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8" title="Automatically locks and unlocks a CriticalSection object. ">ScopedLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2c12101da7ebf8455de49652f377d313"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CriticalSection::tryEnter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to lock this critical section without blocking. </p>
<p>This method behaves identically to <a class="el" href="group__juce__core-threads.html#a20c4b0714061cc488d220b1b5a77aa1c" title="Acquires the lock. ">CriticalSection::enter</a>, except that the caller thread does not wait if the lock is currently held by another thread but returns false immediately.</p>
<dl class="section return"><dt>Returns</dt><dd>false if the lock is currently held by another thread, true otherwise. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a20c4b0714061cc488d220b1b5a77aa1c" title="Acquires the lock. ">enter</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a856bbcc18f0367ae231f7277d9cb33f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CriticalSection::exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock. </p>
<p>If the caller thread hasn't got the lock, this can have unpredictable results.</p>
<p>If the <a class="el" href="group__juce__core-threads.html#a20c4b0714061cc488d220b1b5a77aa1c" title="Acquires the lock. ">enter()</a> method has been called multiple times by the thread, each call must be matched by a call to <a class="el" href="group__juce__core-threads.html#a856bbcc18f0367ae231f7277d9cb33f8" title="Releases the lock. ">exit()</a> before other threads will be allowed to take over the lock.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a20c4b0714061cc488d220b1b5a77aa1c" title="Acquires the lock. ">enter</a>, <a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8" title="Automatically locks and unlocks a CriticalSection object. ">ScopedLock</a> </dd></dl>

</div>
</div>

</div>
</div>
<a name="classDummyCriticalSection" id="classDummyCriticalSection"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class DummyCriticalSection</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A class that can be used in place of a real <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object, but which doesn't perform any locking. </p>
<p>This is currently used by some templated classes, and most compilers should manage to optimise it out of existence.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, <a class="el" href="group__juce__core-containers.html#classArray" title="Holds a resizable array of primitive or copy-by-value objects. ">Array</a>, <a class="el" href="group__juce__core-containers.html#classOwnedArray" title="An array designed for holding objects. ">OwnedArray</a>, <a class="el" href="group__juce__core-containers.html#classReferenceCountedArray" title="Holds a list of objects derived from ReferenceCountedObject, or which implement basic reference-count...">ReferenceCountedArray</a> </dd></dl>
</div>
<p>Inherited by <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ActionListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ActionSet *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AllocatedObject *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AnimatedPosition::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AnimationTask *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ApplicationCommandInfo *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ApplicationCommandManagerListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AttributedString::Attribute, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioChannelSet, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioDeviceManager::AudioDeviceSetup *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioFormat *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioIODeviceCallback *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioIODeviceType *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioIODeviceType::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioPluginFormat *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioProcessor::Bus *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioProcessor::BusProperties, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioProcessorGraph::Connection *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioProcessorGraph::Node *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioProcessorListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioProcessorParameter *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; AudioSource *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; BufferedBlock *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Button::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ByteSequence, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ChangeListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ChangeMessage *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ChannelInfo *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; CodeDocument::Iterator *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; CodeDocument::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; CodeDocument::Position *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; CodeDocumentLine *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; CodeEditorComponent::ColourScheme::TokenType, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; CodeEditorLine *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ColourPoint, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ColourSetting, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ColumnInfo *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ComboBox *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ComboBox::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; CommandMapping *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Component *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ComponentBuilder::TypeHandler *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ComponentPeer *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; const PluginDescription *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; const PopupMenu *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Desktop::Displays::Display, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; DirectoryContentsList::FileInfo *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; DrawableButton *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ElementType, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ExpPtr, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; File, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; FileBrowserListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; FilenameComponentListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; FlexItem, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; float, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; FloatingType, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; FloatType, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; FocusChangeListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Function *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; GlyphInfo *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; HashEntry *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; IIRCoefficients, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; IIRFilter *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ImagePixelData::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; InAppPurchases::Download *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; InAppPurchases::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; int, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Item *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Item, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ItemLayoutProperties *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; KeyPress, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; KeyPressTime *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; KnownPluginList::PluginTree *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Label::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; littlefoot::Compiler::CodeGenerator::MarkerAndAddress, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; littlefoot::NativeFunction, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; LowLevelGraphicsPostScriptRenderer::SavedState *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MarkerList *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MarkerList::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MarkerList::Marker *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MenuBarModel::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MidiBuffer *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MidiCallbackInfo, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MidiInput *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MidiKeyboardStateListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MidiMessageSequence *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MidiMessageSequence::MidiEventHolder *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ModalItem *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MouseInactivityDetector::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MouseListener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MPEInstrument::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MPENote, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MPESynthesiserVoice *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MPEZone, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; MPEZoneLayout::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; NamedValueSet::NamedValue, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; NumericType, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; OSCArgument, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; OSCBundle::OSCBundle::Element, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; PanelHolder *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; PluginDescription *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; PopupMenu::Item *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; PositionedGlyph, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ProgressBar *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Range&lt; int &gt;, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Rectangle, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; RelativePointPath::ElementBase *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ScrollBar::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; SelectableItemType, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; size_t, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; StandalonePluginHolder::PluginInOuts, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; StatementPtr, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; String, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; SwatchComponent *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; SynthesiserSound *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; SynthesiserVoice *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TabInfo *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TableHeaderComponent::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TextButton *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TextDiff::Change, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TextEditor *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TextEditor::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TextLayout::Glyph, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TextLayout::Line *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TextLayout::Run *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TextPropertyComponent::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ThreadPoolJob *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ThreadPoolThread *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ThreadRecursionCount, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ThumbData *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ThumbnailCacheEntry *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Timer *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TimeSliceClient *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ToolbarItemComponent *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; TreeViewItem *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Type, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; uint8, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; UniformTextSection *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Upload *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Value *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Value::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ValueTree::Listener *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; Variable, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; void *, DummyCriticalSection &gt;</a>, <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; WeakReference&lt; Component &gt;, DummyCriticalSection &gt;</a>, and <a class="el" href="group__juce__core-containers.html">ArrayAllocationBase&lt; ZipEntryHolder *, DummyCriticalSection &gt;</a>.</p>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a455be3752f5f32c56fabe0b7b477b6f2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structDummyCriticalSection_1_1ScopedLockType.html">ScopedLockType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a455be3752f5f32c56fabe0b7b477b6f2">ScopedUnlockType</a></td></tr>
<tr class="memdesc:a455be3752f5f32c56fabe0b7b477b6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy scoped-unlocker type to use with a dummy critical section.  <a href="#a455be3752f5f32c56fabe0b7b477b6f2">More...</a><br/></td></tr>
<tr class="separator:a455be3752f5f32c56fabe0b7b477b6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:aed067ef6b51dcca1f25f19231a99b595"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aed067ef6b51dcca1f25f19231a99b595">DummyCriticalSection</a> () noexcept</td></tr>
<tr class="separator:aed067ef6b51dcca1f25f19231a99b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae13b7a18e9cf77c6d85792a151f2d1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aae13b7a18e9cf77c6d85792a151f2d1c">~DummyCriticalSection</a> () noexcept</td></tr>
<tr class="separator:aae13b7a18e9cf77c6d85792a151f2d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3511e9f002535174e24aa2e0983b60d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a3511e9f002535174e24aa2e0983b60d9">enter</a> () const noexcept</td></tr>
<tr class="separator:a3511e9f002535174e24aa2e0983b60d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f19ff3a0b0f91a1d025939d1c03a3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a55f19ff3a0b0f91a1d025939d1c03a3c">tryEnter</a> () const noexcept</td></tr>
<tr class="separator:a55f19ff3a0b0f91a1d025939d1c03a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00630497a7c9a449eca4630abf115fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a00630497a7c9a449eca4630abf115fa6">exit</a> () const noexcept</td></tr>
<tr class="separator:a00630497a7c9a449eca4630abf115fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="a455be3752f5f32c56fabe0b7b477b6f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structDummyCriticalSection_1_1ScopedLockType.html">ScopedLockType</a> <a class="el" href="group__juce__core-threads.html#a455be3752f5f32c56fabe0b7b477b6f2">DummyCriticalSection::ScopedUnlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dummy scoped-unlocker type to use with a dummy critical section. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="aed067ef6b51dcca1f25f19231a99b595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DummyCriticalSection::DummyCriticalSection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae13b7a18e9cf77c6d85792a151f2d1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DummyCriticalSection::~DummyCriticalSection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a3511e9f002535174e24aa2e0983b60d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DummyCriticalSection::enter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55f19ff3a0b0f91a1d025939d1c03a3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool DummyCriticalSection::tryEnter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a00630497a7c9a449eca4630abf115fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DummyCriticalSection::exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="classDynamicLibrary" id="classDynamicLibrary"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class DynamicLibrary</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Handles the opening and closing of DLLs. </p>
<p>This class can be used to open a DLL and get some function pointers from it. Since the DLL is freed when this object is deleted, it's handy for managing library lifetimes using RAII. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a7c6a13e65177869af7116175c7745e2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a7c6a13e65177869af7116175c7745e2e">DynamicLibrary</a> () noexcept</td></tr>
<tr class="memdesc:a7c6a13e65177869af7116175c7745e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an unopened <a class="el" href="group__juce__core-threads.html#classDynamicLibrary" title="Handles the opening and closing of DLLs. ">DynamicLibrary</a> object.  <a href="#a7c6a13e65177869af7116175c7745e2e">More...</a><br/></td></tr>
<tr class="separator:a7c6a13e65177869af7116175c7745e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ad02ee239000e67ff664ef4b5dfe2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#af9ad02ee239000e67ff664ef4b5dfe2c">DynamicLibrary</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;name)</td></tr>
<tr class="separator:af9ad02ee239000e67ff664ef4b5dfe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae057a9ca2d72db6b7bae77626e88342"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aae057a9ca2d72db6b7bae77626e88342">DynamicLibrary</a> (<a class="el" href="group__juce__core-threads.html#classDynamicLibrary">DynamicLibrary</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:aae057a9ca2d72db6b7bae77626e88342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#aae057a9ca2d72db6b7bae77626e88342">More...</a><br/></td></tr>
<tr class="separator:aae057a9ca2d72db6b7bae77626e88342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dd7a7cd386fbc1c8abde597c39c881"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a25dd7a7cd386fbc1c8abde597c39c881">~DynamicLibrary</a> ()</td></tr>
<tr class="memdesc:a25dd7a7cd386fbc1c8abde597c39c881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a25dd7a7cd386fbc1c8abde597c39c881">More...</a><br/></td></tr>
<tr class="separator:a25dd7a7cd386fbc1c8abde597c39c881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64b6f35270c87d0c69b422854683674"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab64b6f35270c87d0c69b422854683674">open</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;name)</td></tr>
<tr class="memdesc:ab64b6f35270c87d0c69b422854683674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a DLL.  <a href="#ab64b6f35270c87d0c69b422854683674">More...</a><br/></td></tr>
<tr class="separator:ab64b6f35270c87d0c69b422854683674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac894163d2ef226237fd6d6cfaeb77fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac894163d2ef226237fd6d6cfaeb77fce">close</a> ()</td></tr>
<tr class="memdesc:ac894163d2ef226237fd6d6cfaeb77fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the currently-open DLL, or has no effect if none was open.  <a href="#ac894163d2ef226237fd6d6cfaeb77fce">More...</a><br/></td></tr>
<tr class="separator:ac894163d2ef226237fd6d6cfaeb77fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278ed4824af45759270b5c1eeba9dcb6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a278ed4824af45759270b5c1eeba9dcb6">getFunction</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;functionName) noexcept</td></tr>
<tr class="memdesc:a278ed4824af45759270b5c1eeba9dcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to find a named function in the currently-open DLL, and returns a pointer to it.  <a href="#a278ed4824af45759270b5c1eeba9dcb6">More...</a><br/></td></tr>
<tr class="separator:a278ed4824af45759270b5c1eeba9dcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0128264e0070e40f1be2eac26073e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#acf0128264e0070e40f1be2eac26073e4">getNativeHandle</a> () const noexcept</td></tr>
<tr class="memdesc:acf0128264e0070e40f1be2eac26073e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the platform-specific native library handle.  <a href="#acf0128264e0070e40f1be2eac26073e4">More...</a><br/></td></tr>
<tr class="separator:acf0128264e0070e40f1be2eac26073e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a7c6a13e65177869af7116175c7745e2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicLibrary::DynamicLibrary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unopened <a class="el" href="group__juce__core-threads.html#classDynamicLibrary" title="Handles the opening and closing of DLLs. ">DynamicLibrary</a> object. </p>
<p>Call <a class="el" href="group__juce__core-threads.html#ab64b6f35270c87d0c69b422854683674" title="Opens a DLL. ">open()</a> to actually open one. </p>

</div>
</div>
<a class="anchor" id="af9ad02ee239000e67ff664ef4b5dfe2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicLibrary::DynamicLibrary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae057a9ca2d72db6b7bae77626e88342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicLibrary::DynamicLibrary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-threads.html#classDynamicLibrary">DynamicLibrary</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a class="anchor" id="a25dd7a7cd386fbc1c8abde597c39c881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicLibrary::~DynamicLibrary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If a library is currently open, it will be closed when this object is destroyed. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="ab64b6f35270c87d0c69b422854683674"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DynamicLibrary::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a DLL. </p>
<p>The name and the method by which it gets found is of course platform-specific, and may or may not include a path, depending on the OS. If a library is already open when this method is called, it will first close the library before attempting to load the new one. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the library was successfully found and opened. </dd></dl>

</div>
</div>
<a class="anchor" id="ac894163d2ef226237fd6d6cfaeb77fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DynamicLibrary::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the currently-open DLL, or has no effect if none was open. </p>

</div>
</div>
<a class="anchor" id="a278ed4824af45759270b5c1eeba9dcb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* DynamicLibrary::getFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>functionName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to find a named function in the currently-open DLL, and returns a pointer to it. </p>
<p>If no library is open, or if the function isn't found, this will return a null pointer. </p>

</div>
</div>
<a class="anchor" id="acf0128264e0070e40f1be2eac26073e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* DynamicLibrary::getNativeHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the platform-specific native library handle. </p>
<p>You'll need to cast this to whatever is appropriate for the OS that's in use. </p>

</div>
</div>

</div>
</div>
<a name="classHighResolutionTimer" id="classHighResolutionTimer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class HighResolutionTimer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A high-resolution periodic timer. </p>
<p>This provides accurately-timed regular callbacks. Unlike the normal <a class="el" href="group__juce__events-timers.html#classTimer" title="Makes repeated callbacks to a virtual method at a specified time interval. ">Timer</a> class, this one uses a dedicated thread, not the message thread, so is far more stable and precise.</p>
<p>You should only use this class in situations where you really need accuracy, because unlike the normal <a class="el" href="group__juce__events-timers.html#classTimer" title="Makes repeated callbacks to a virtual method at a specified time interval. ">Timer</a> class, which is very lightweight and cheap to start/stop, the <a class="el" href="group__juce__core-threads.html#classHighResolutionTimer" title="A high-resolution periodic timer. ">HighResolutionTimer</a> will use far more resources, and starting/stopping it may involve launching and killing threads.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__events-timers.html#classTimer" title="Makes repeated callbacks to a virtual method at a specified time interval. ">Timer</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a5eb450755a308ebc74e30085af52082b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a5eb450755a308ebc74e30085af52082b">~HighResolutionTimer</a> ()</td></tr>
<tr class="memdesc:a5eb450755a308ebc74e30085af52082b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5eb450755a308ebc74e30085af52082b">More...</a><br/></td></tr>
<tr class="separator:a5eb450755a308ebc74e30085af52082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fac5960301220b28b687817e4e7598"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a38fac5960301220b28b687817e4e7598">hiResTimerCallback</a> ()=0</td></tr>
<tr class="memdesc:a38fac5960301220b28b687817e4e7598"><td class="mdescLeft">&#160;</td><td class="mdescRight">The user-defined callback routine that actually gets called periodically.  <a href="#a38fac5960301220b28b687817e4e7598">More...</a><br/></td></tr>
<tr class="separator:a38fac5960301220b28b687817e4e7598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3709eee45c33f0d2095ab80121a965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9d3709eee45c33f0d2095ab80121a965">startTimer</a> (int intervalInMilliseconds)</td></tr>
<tr class="memdesc:a9d3709eee45c33f0d2095ab80121a965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the timer and sets the length of interval required.  <a href="#a9d3709eee45c33f0d2095ab80121a965">More...</a><br/></td></tr>
<tr class="separator:a9d3709eee45c33f0d2095ab80121a965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141251dfd58c8564709a15da52dffd3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a141251dfd58c8564709a15da52dffd3a">stopTimer</a> ()</td></tr>
<tr class="memdesc:a141251dfd58c8564709a15da52dffd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the timer.  <a href="#a141251dfd58c8564709a15da52dffd3a">More...</a><br/></td></tr>
<tr class="separator:a141251dfd58c8564709a15da52dffd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628e5e8a30df147af372818baa96cf96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a628e5e8a30df147af372818baa96cf96">isTimerRunning</a> () const noexcept</td></tr>
<tr class="memdesc:a628e5e8a30df147af372818baa96cf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the timer has been started.  <a href="#a628e5e8a30df147af372818baa96cf96">More...</a><br/></td></tr>
<tr class="separator:a628e5e8a30df147af372818baa96cf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e6af2a70291b57cba40155cb4cbc01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a96e6af2a70291b57cba40155cb4cbc01">getTimerInterval</a> () const noexcept</td></tr>
<tr class="memdesc:a96e6af2a70291b57cba40155cb4cbc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the timer's interval.  <a href="#a96e6af2a70291b57cba40155cb4cbc01">More...</a><br/></td></tr>
<tr class="separator:a96e6af2a70291b57cba40155cb4cbc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Member Functions</h3></td></tr>
<tr class="memitem:ac79eb2389b1d52cd4a387836fe9ce860"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac79eb2389b1d52cd4a387836fe9ce860">HighResolutionTimer</a> ()</td></tr>
<tr class="memdesc:ac79eb2389b1d52cd4a387836fe9ce860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classHighResolutionTimer" title="A high-resolution periodic timer. ">HighResolutionTimer</a>.  <a href="#ac79eb2389b1d52cd4a387836fe9ce860">More...</a><br/></td></tr>
<tr class="separator:ac79eb2389b1d52cd4a387836fe9ce860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ac79eb2389b1d52cd4a387836fe9ce860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">HighResolutionTimer::HighResolutionTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classHighResolutionTimer" title="A high-resolution periodic timer. ">HighResolutionTimer</a>. </p>
<p>When created, the timer is stopped, so use <a class="el" href="group__juce__core-threads.html#a9d3709eee45c33f0d2095ab80121a965" title="Starts the timer and sets the length of interval required. ">startTimer()</a> to get it going. </p>

</div>
</div>
<a class="anchor" id="a5eb450755a308ebc74e30085af52082b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HighResolutionTimer::~HighResolutionTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a38fac5960301220b28b687817e4e7598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void HighResolutionTimer::hiResTimerCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The user-defined callback routine that actually gets called periodically. </p>
<p>This will be called on a dedicated timer thread, so make sure your implementation is thread-safe!</p>
<p>It's perfectly ok to call <a class="el" href="group__juce__core-threads.html#a9d3709eee45c33f0d2095ab80121a965" title="Starts the timer and sets the length of interval required. ">startTimer()</a> or <a class="el" href="group__juce__core-threads.html#a141251dfd58c8564709a15da52dffd3a" title="Stops the timer. ">stopTimer()</a> from within this callback to change the subsequent intervals. </p>

</div>
</div>
<a class="anchor" id="a9d3709eee45c33f0d2095ab80121a965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HighResolutionTimer::startTimer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intervalInMilliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the timer and sets the length of interval required. </p>
<p>If the timer is already started, this will reset its counter, so the time between calling this method and the next timer callback will not be less than the interval length passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intervalInMilliseconds</td><td>the interval to use (any values less than 1 will be rounded up to 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a141251dfd58c8564709a15da52dffd3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HighResolutionTimer::stopTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the timer. </p>
<p>This method may block while it waits for pending callbacks to complete. Once it returns, no more callbacks will be made. If it is called from the timer's own thread, it will cancel the timer after the current callback returns. </p>

</div>
</div>
<a class="anchor" id="a628e5e8a30df147af372818baa96cf96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HighResolutionTimer::isTimerRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the timer has been started. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the timer is running. </dd></dl>

</div>
</div>
<a class="anchor" id="a96e6af2a70291b57cba40155cb4cbc01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int HighResolutionTimer::getTimerInterval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the timer's interval. </p>
<dl class="section return"><dt>Returns</dt><dd>the timer's interval in milliseconds if it's running, or 0 if it's not. </dd></dl>

</div>
</div>

</div>
</div>
<a name="classInterProcessLock" id="classInterProcessLock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class InterProcessLock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Acts as a critical section which processes can use to block each other. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:aa4bb20ad9b280ba608e570f8ece8351e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aa4bb20ad9b280ba608e570f8ece8351e">InterProcessLock</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;name)</td></tr>
<tr class="memdesc:aa4bb20ad9b280ba608e570f8ece8351e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a lock object.  <a href="#aa4bb20ad9b280ba608e570f8ece8351e">More...</a><br/></td></tr>
<tr class="separator:aa4bb20ad9b280ba608e570f8ece8351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464f2a7c6a841b37534f1d1cbe5c1571"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a464f2a7c6a841b37534f1d1cbe5c1571">~InterProcessLock</a> ()</td></tr>
<tr class="memdesc:a464f2a7c6a841b37534f1d1cbe5c1571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a464f2a7c6a841b37534f1d1cbe5c1571">More...</a><br/></td></tr>
<tr class="separator:a464f2a7c6a841b37534f1d1cbe5c1571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d7b9e49bf365eedc923f622e330179"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a00d7b9e49bf365eedc923f622e330179">enter</a> (int timeOutMillisecs=-1)</td></tr>
<tr class="memdesc:a00d7b9e49bf365eedc923f622e330179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to lock the critical section.  <a href="#a00d7b9e49bf365eedc923f622e330179">More...</a><br/></td></tr>
<tr class="separator:a00d7b9e49bf365eedc923f622e330179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3387e77951f1777be407cf76d2691bd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a3387e77951f1777be407cf76d2691bd0">exit</a> ()</td></tr>
<tr class="memdesc:a3387e77951f1777be407cf76d2691bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock if it's currently held by this process.  <a href="#a3387e77951f1777be407cf76d2691bd0">More...</a><br/></td></tr>
<tr class="separator:a3387e77951f1777be407cf76d2691bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="aa4bb20ad9b280ba608e570f8ece8351e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">InterProcessLock::InterProcessLock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a lock object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>a name that processes will use to identify this lock object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a464f2a7c6a841b37534f1d1cbe5c1571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InterProcessLock::~InterProcessLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This will also release the lock if it's currently held by this process. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a00d7b9e49bf365eedc923f622e330179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool InterProcessLock::enter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMillisecs</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to lock the critical section. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOutMillisecs</td><td>how many milliseconds to wait if the lock is already held by another process - a value of 0 will return immediately, negative values will wait forever </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the lock could be gained within the timeout period, or false if the timeout expired. </dd></dl>

<p>Referenced by <a class="el" href="classInterProcessLock_1_1ScopedLockType.html#a8ce60f7f55e0ca70f0e288e9000ed0c7">InterProcessLock::ScopedLockType::ScopedLockType()</a>.</p>

</div>
</div>
<a class="anchor" id="a3387e77951f1777be407cf76d2691bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void InterProcessLock::exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the lock if it's currently held by this process. </p>

</div>
</div>

</div>
</div>
<a name="classProcess" id="classProcess"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class Process</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Represents the current executable's process. </p>
<p>This contains methods for controlling the current application at the process-level.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a>, <a class="el" href="group__juce__events-messages.html#classJUCEApplicationBase" title="Abstract base class for application classes. ">JUCEApplicationBase</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:ad7b18ceb7a8c0a2b6b71856894feb6ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ad7b18ceb7a8c0a2b6b71856894feb6ef">ProcessPriority</a> { <a class="el" href="group__juce__core-threads.html#ad7b18ceb7a8c0a2b6b71856894feb6efad7f3e46785b41d6d5db5e7afab065281">LowPriority</a> = 0, 
<a class="el" href="group__juce__core-threads.html#ad7b18ceb7a8c0a2b6b71856894feb6efab8355050d1e4ef5af4c057abc20259be">NormalPriority</a> = 1, 
<a class="el" href="group__juce__core-threads.html#ad7b18ceb7a8c0a2b6b71856894feb6efaa72f09a6d0e30d394c6fe7095372a711">HighPriority</a> = 2, 
<a class="el" href="group__juce__core-threads.html#ad7b18ceb7a8c0a2b6b71856894feb6efa1ab071c1d49e25fc1df3c9663177927e">RealtimePriority</a> = 3
 }</td></tr>
<tr class="separator:ad7b18ceb7a8c0a2b6b71856894feb6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:af87785f3f355601bb542e905963c31a7"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#af87785f3f355601bb542e905963c31a7">setPriority</a> (const <a class="el" href="group__juce__core-threads.html#ad7b18ceb7a8c0a2b6b71856894feb6ef">ProcessPriority</a> priority)</td></tr>
<tr class="memdesc:af87785f3f355601bb542e905963c31a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the current process's priority.  <a href="#af87785f3f355601bb542e905963c31a7">More...</a><br/></td></tr>
<tr class="separator:af87785f3f355601bb542e905963c31a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf38d88851f9bb8e2cc8fd66f4affc3"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a2bf38d88851f9bb8e2cc8fd66f4affc3">terminate</a> ()</td></tr>
<tr class="memdesc:a2bf38d88851f9bb8e2cc8fd66f4affc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kills the current process immediately.  <a href="#a2bf38d88851f9bb8e2cc8fd66f4affc3">More...</a><br/></td></tr>
<tr class="separator:a2bf38d88851f9bb8e2cc8fd66f4affc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9bad73a7b996a2bbbdac5f848d09bd"><td class="memItemLeft" align="right" valign="top">static bool <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a7d9bad73a7b996a2bbbdac5f848d09bd">isForegroundProcess</a> ()</td></tr>
<tr class="memdesc:a7d9bad73a7b996a2bbbdac5f848d09bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this application process is the one that the user is currently using.  <a href="#a7d9bad73a7b996a2bbbdac5f848d09bd">More...</a><br/></td></tr>
<tr class="separator:a7d9bad73a7b996a2bbbdac5f848d09bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bdca982f2b357ecc9f915724b997ea"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab9bdca982f2b357ecc9f915724b997ea">makeForegroundProcess</a> ()</td></tr>
<tr class="memdesc:ab9bdca982f2b357ecc9f915724b997ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to make the current process the active one.  <a href="#ab9bdca982f2b357ecc9f915724b997ea">More...</a><br/></td></tr>
<tr class="separator:ab9bdca982f2b357ecc9f915724b997ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a7ddde215bcef03cd16587ed4b0a64"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a01a7ddde215bcef03cd16587ed4b0a64">hide</a> ()</td></tr>
<tr class="memdesc:a01a7ddde215bcef03cd16587ed4b0a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hides the application (on an OS that supports this, e.g.  <a href="#a01a7ddde215bcef03cd16587ed4b0a64">More...</a><br/></td></tr>
<tr class="separator:a01a7ddde215bcef03cd16587ed4b0a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e96b400aa54a83291406378ec0d8eaa"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a8e96b400aa54a83291406378ec0d8eaa">raisePrivilege</a> ()</td></tr>
<tr class="memdesc:a8e96b400aa54a83291406378ec0d8eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises the current process's privilege level.  <a href="#a8e96b400aa54a83291406378ec0d8eaa">More...</a><br/></td></tr>
<tr class="separator:a8e96b400aa54a83291406378ec0d8eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0153aa164ca166e209a74e8c4f811e0"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab0153aa164ca166e209a74e8c4f811e0">lowerPrivilege</a> ()</td></tr>
<tr class="memdesc:ab0153aa164ca166e209a74e8c4f811e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers the current process's privilege level.  <a href="#ab0153aa164ca166e209a74e8c4f811e0">More...</a><br/></td></tr>
<tr class="separator:ab0153aa164ca166e209a74e8c4f811e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd9f1c5682e4c95e1a3a407f6c838b3"><td class="memItemLeft" align="right" valign="top">static bool <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0bd9f1c5682e4c95e1a3a407f6c838b3">isRunningUnderDebugger</a> () noexcept</td></tr>
<tr class="memdesc:a0bd9f1c5682e4c95e1a3a407f6c838b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this process is being hosted by a debugger.  <a href="#a0bd9f1c5682e4c95e1a3a407f6c838b3">More...</a><br/></td></tr>
<tr class="separator:a0bd9f1c5682e4c95e1a3a407f6c838b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b430c0c6c182a044f67a9ce6144f43"><td class="memItemLeft" align="right" valign="top">static bool <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a05b430c0c6c182a044f67a9ce6144f43">openDocument</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;documentURL, const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;parameters)</td></tr>
<tr class="memdesc:a05b430c0c6c182a044f67a9ce6144f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to launch the OS's default reader application for a given file or <a class="el" href="group__juce__core-network.html#classURL" title="Represents a URL and has a bunch of useful functions to manipulate it. ">URL</a>.  <a href="#a05b430c0c6c182a044f67a9ce6144f43">More...</a><br/></td></tr>
<tr class="separator:a05b430c0c6c182a044f67a9ce6144f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be74f73ba52067284e129ad5478d9d1"><td class="memItemLeft" align="right" valign="top">static bool <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a7be74f73ba52067284e129ad5478d9d1">openEmailWithAttachments</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;targetEmailAddress, const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;emailSubject, const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;bodyText, const <a class="el" href="group__juce__core-text.html#classStringArray">StringArray</a> &amp;filesToAttach)</td></tr>
<tr class="memdesc:a7be74f73ba52067284e129ad5478d9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to launch the OS's default email application to let the user create a message.  <a href="#a7be74f73ba52067284e129ad5478d9d1">More...</a><br/></td></tr>
<tr class="separator:a7be74f73ba52067284e129ad5478d9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a3cbef850679516bccdab10e9a5305"><td class="memItemLeft" align="right" valign="top">static void *<a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a89a3cbef850679516bccdab10e9a5305">getCurrentModuleInstanceHandle</a> () noexcept</td></tr>
<tr class="memdesc:a89a3cbef850679516bccdab10e9a5305"><td class="mdescLeft">&#160;</td><td class="mdescRight">WINDOWS ONLY - This returns the HINSTANCE of the current module.  <a href="#a89a3cbef850679516bccdab10e9a5305">More...</a><br/></td></tr>
<tr class="separator:a89a3cbef850679516bccdab10e9a5305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a86c921a568fe5af4968de5c42adb7"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a82a86c921a568fe5af4968de5c42adb7">setCurrentModuleInstanceHandle</a> (void *newHandle) noexcept</td></tr>
<tr class="memdesc:a82a86c921a568fe5af4968de5c42adb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">WINDOWS ONLY - Sets a new module handle to be used by the library.  <a href="#a82a86c921a568fe5af4968de5c42adb7">More...</a><br/></td></tr>
<tr class="separator:a82a86c921a568fe5af4968de5c42adb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce4be274d956bdb4f7c36398e776bfb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#abce4be274d956bdb4f7c36398e776bfb">setDockIconVisible</a> (bool isVisible)</td></tr>
<tr class="memdesc:abce4be274d956bdb4f7c36398e776bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">OSX ONLY - Shows or hides the OSX dock icon for this app.  <a href="#abce4be274d956bdb4f7c36398e776bfb">More...</a><br/></td></tr>
<tr class="separator:abce4be274d956bdb4f7c36398e776bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b648877751448ff0ad0dd4b74b289f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a38b648877751448ff0ad0dd4b74b289f">setMaxNumberOfFileHandles</a> (int maxNumberOfFiles) noexcept</td></tr>
<tr class="memdesc:a38b648877751448ff0ad0dd4b74b289f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UNIX ONLY - Attempts to use setrlimit to change the maximum number of file handles that the app can open.  <a href="#a38b648877751448ff0ad0dd4b74b289f">More...</a><br/></td></tr>
<tr class="separator:a38b648877751448ff0ad0dd4b74b289f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Enumeration Documentation</h4>
<a class="anchor" id="ad7b18ceb7a8c0a2b6b71856894feb6ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__juce__core-threads.html#ad7b18ceb7a8c0a2b6b71856894feb6ef">Process::ProcessPriority</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad7b18ceb7a8c0a2b6b71856894feb6efad7f3e46785b41d6d5db5e7afab065281"></a>LowPriority</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad7b18ceb7a8c0a2b6b71856894feb6efab8355050d1e4ef5af4c057abc20259be"></a>NormalPriority</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad7b18ceb7a8c0a2b6b71856894feb6efaa72f09a6d0e30d394c6fe7095372a711"></a>HighPriority</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad7b18ceb7a8c0a2b6b71856894feb6efa1ab071c1d49e25fc1df3c9663177927e"></a>RealtimePriority</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="af87785f3f355601bb542e905963c31a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::setPriority </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-threads.html#ad7b18ceb7a8c0a2b6b71856894feb6ef">ProcessPriority</a>&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the current process's priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>the process priority, where 0=low, 1=normal, 2=high, 3=realtime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bf38d88851f9bb8e2cc8fd66f4affc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::terminate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kills the current process immediately. </p>
<p>This is an emergency process terminator that kills the application immediately - it's intended only for use only when something goes horribly wrong.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__events-messages.html#a542e212605f0aa693f687d8798998615" title="Signals that the main message loop should stop and the application should terminate. ">JUCEApplicationBase::quit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d9bad73a7b996a2bbbdac5f848d09bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::isForegroundProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this application process is the one that the user is currently using. </p>

</div>
</div>
<a class="anchor" id="ab9bdca982f2b357ecc9f915724b997ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::makeForegroundProcess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to make the current process the active one. </p>
<p>(This is not possible on some platforms). </p>

</div>
</div>
<a class="anchor" id="a01a7ddde215bcef03cd16587ed4b0a64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::hide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hides the application (on an OS that supports this, e.g. </p>
<p>OSX) </p>

</div>
</div>
<a class="anchor" id="a8e96b400aa54a83291406378ec0d8eaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::raisePrivilege </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Raises the current process's privilege level. </p>
<p>Does nothing if this isn't supported by the current OS, or if process privilege level is fixed. </p>

</div>
</div>
<a class="anchor" id="ab0153aa164ca166e209a74e8c4f811e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::lowerPrivilege </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lowers the current process's privilege level. </p>
<p>Does nothing if this isn't supported by the current OS, or if process privilege level is fixed. </p>

</div>
</div>
<a class="anchor" id="a0bd9f1c5682e4c95e1a3a407f6c838b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::isRunningUnderDebugger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this process is being hosted by a debugger. </p>

</div>
</div>
<a class="anchor" id="a05b430c0c6c182a044f67a9ce6144f43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::openDocument </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>documentURL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to launch the OS's default reader application for a given file or <a class="el" href="group__juce__core-network.html#classURL" title="Represents a URL and has a bunch of useful functions to manipulate it. ">URL</a>. </p>

</div>
</div>
<a class="anchor" id="a7be74f73ba52067284e129ad5478d9d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::openEmailWithAttachments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>targetEmailAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>emailSubject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>bodyText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classStringArray">StringArray</a> &amp;&#160;</td>
          <td class="paramname"><em>filesToAttach</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to launch the OS's default email application to let the user create a message. </p>

</div>
</div>
<a class="anchor" id="a89a3cbef850679516bccdab10e9a5305"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::getCurrentModuleInstanceHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WINDOWS ONLY - This returns the HINSTANCE of the current module. </p>
<p>The return type is a void* to avoid being dependent on windows.h - just cast it to a HINSTANCE to use it.</p>
<p>In a normal JUCE application, this will be automatically set to the module handle of the executable.</p>
<p>If you've built a DLL and plan to use any JUCE messaging or windowing classes, you'll need to make sure you call the <a class="el" href="group__juce__core-threads.html#a82a86c921a568fe5af4968de5c42adb7" title="WINDOWS ONLY - Sets a new module handle to be used by the library. ">setCurrentModuleInstanceHandle()</a> to provide the correct module handle in your DllMain() function, because the system relies on the correct instance handle when opening windows. </p>

</div>
</div>
<a class="anchor" id="a82a86c921a568fe5af4968de5c42adb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Process::setCurrentModuleInstanceHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>newHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>WINDOWS ONLY - Sets a new module handle to be used by the library. </p>
<p>The parameter type is a void* to avoid being dependent on windows.h, but it actually expects a HINSTANCE value.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a89a3cbef850679516bccdab10e9a5305" title="WINDOWS ONLY - This returns the HINSTANCE of the current module. ">getCurrentModuleInstanceHandle()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abce4be274d956bdb4f7c36398e776bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Process::setDockIconVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVisible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OSX ONLY - Shows or hides the OSX dock icon for this app. </p>

</div>
</div>
<a class="anchor" id="a38b648877751448ff0ad0dd4b74b289f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Process::setMaxNumberOfFileHandles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumberOfFiles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>UNIX ONLY - Attempts to use setrlimit to change the maximum number of file handles that the app can open. </p>
<p>Pass 0 or less as the parameter to mean 'infinite'. Returns true if it succeeds. </p>

</div>
</div>

</div>
</div>
<a name="classReadWriteLock" id="classReadWriteLock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ReadWriteLock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A critical section that allows multiple simultaneous readers. </p>
<p>Features of this type of lock are:</p>
<ul>
<li>Multiple readers can hold the lock at the same time, but only one writer can hold it at once.</li>
<li>Writers trying to gain the lock will be blocked until all readers and writers have released it</li>
<li>Readers trying to gain the lock while a writer is waiting to acquire it will be blocked until the writer has obtained and released it</li>
<li>If a thread already has a read lock and tries to obtain a write lock, it will succeed if there are no other readers</li>
<li>If a thread already has the write lock and tries to obtain a read lock, this will succeed.</li>
<li>Recursive locking is supported.</li>
</ul>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a>, <a class="el" href="group__juce__core-threads.html#classScopedWriteLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedWriteLock</a>, <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ac4d03ea1fd3a24c1813492b8487134af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac4d03ea1fd3a24c1813492b8487134af">ReadWriteLock</a> () noexcept</td></tr>
<tr class="memdesc:ac4d03ea1fd3a24c1813492b8487134af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a> object.  <a href="#ac4d03ea1fd3a24c1813492b8487134af">More...</a><br/></td></tr>
<tr class="separator:ac4d03ea1fd3a24c1813492b8487134af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57fd41f09be7654f33cc0e4aa458e5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#af57fd41f09be7654f33cc0e4aa458e5a">~ReadWriteLock</a> () noexcept</td></tr>
<tr class="memdesc:af57fd41f09be7654f33cc0e4aa458e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af57fd41f09be7654f33cc0e4aa458e5a">More...</a><br/></td></tr>
<tr class="separator:af57fd41f09be7654f33cc0e4aa458e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69612d80a6abdccfd0f911eea78bec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae69612d80a6abdccfd0f911eea78bec7">enterRead</a> () const noexcept</td></tr>
<tr class="memdesc:ae69612d80a6abdccfd0f911eea78bec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks this object for reading.  <a href="#ae69612d80a6abdccfd0f911eea78bec7">More...</a><br/></td></tr>
<tr class="separator:ae69612d80a6abdccfd0f911eea78bec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc94e3cea69acf123d343eca82bdc51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#adfc94e3cea69acf123d343eca82bdc51">tryEnterRead</a> () const noexcept</td></tr>
<tr class="memdesc:adfc94e3cea69acf123d343eca82bdc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to lock this object for reading.  <a href="#adfc94e3cea69acf123d343eca82bdc51">More...</a><br/></td></tr>
<tr class="separator:adfc94e3cea69acf123d343eca82bdc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f84fd4d0560d01674922e650c0ca4bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a4f84fd4d0560d01674922e650c0ca4bc">exitRead</a> () const noexcept</td></tr>
<tr class="memdesc:a4f84fd4d0560d01674922e650c0ca4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the read-lock.  <a href="#a4f84fd4d0560d01674922e650c0ca4bc">More...</a><br/></td></tr>
<tr class="separator:a4f84fd4d0560d01674922e650c0ca4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680913272878d262ab8dff16b3b5a4e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a680913272878d262ab8dff16b3b5a4e7">enterWrite</a> () const noexcept</td></tr>
<tr class="memdesc:a680913272878d262ab8dff16b3b5a4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks this object for writing.  <a href="#a680913272878d262ab8dff16b3b5a4e7">More...</a><br/></td></tr>
<tr class="separator:a680913272878d262ab8dff16b3b5a4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f0b0aefca34943957ac1623b97a8a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac7f0b0aefca34943957ac1623b97a8a2">tryEnterWrite</a> () const noexcept</td></tr>
<tr class="memdesc:ac7f0b0aefca34943957ac1623b97a8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to lock this object for writing.  <a href="#ac7f0b0aefca34943957ac1623b97a8a2">More...</a><br/></td></tr>
<tr class="separator:ac7f0b0aefca34943957ac1623b97a8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3368936be01cf4eb129838230098abe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a3368936be01cf4eb129838230098abe8">exitWrite</a> () const noexcept</td></tr>
<tr class="memdesc:a3368936be01cf4eb129838230098abe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the write-lock.  <a href="#a3368936be01cf4eb129838230098abe8">More...</a><br/></td></tr>
<tr class="separator:a3368936be01cf4eb129838230098abe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ac4d03ea1fd3a24c1813492b8487134af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReadWriteLock::ReadWriteLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a> object. </p>

</div>
</div>
<a class="anchor" id="af57fd41f09be7654f33cc0e4aa458e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReadWriteLock::~ReadWriteLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If the object is deleted whilst locked, any subsequent behaviour is undefined. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="ae69612d80a6abdccfd0f911eea78bec7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReadWriteLock::enterRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks this object for reading. </p>
<p>Multiple threads can simultaneously lock the object for reading, but if another thread has it locked for writing, then this will block until it releases the lock.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a4f84fd4d0560d01674922e650c0ca4bc" title="Releases the read-lock. ">exitRead</a>, <a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adfc94e3cea69acf123d343eca82bdc51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ReadWriteLock::tryEnterRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to lock this object for reading. </p>
<p>Multiple threads can simultaneously lock the object for reading, but if another thread has it locked for writing, then this will fail and return false.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the lock is successfully gained. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a4f84fd4d0560d01674922e650c0ca4bc" title="Releases the read-lock. ">exitRead</a>, <a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f84fd4d0560d01674922e650c0ca4bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReadWriteLock::exitRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the read-lock. </p>
<p>If the caller thread hasn't got the lock, this can have unpredictable results.</p>
<p>If the <a class="el" href="group__juce__core-threads.html#ae69612d80a6abdccfd0f911eea78bec7" title="Locks this object for reading. ">enterRead()</a> method has been called multiple times by the thread, each call must be matched by a call to <a class="el" href="group__juce__core-threads.html#a4f84fd4d0560d01674922e650c0ca4bc" title="Releases the read-lock. ">exitRead()</a> before other threads will be allowed to take over the lock.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#ae69612d80a6abdccfd0f911eea78bec7" title="Locks this object for reading. ">enterRead</a>, <a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a680913272878d262ab8dff16b3b5a4e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReadWriteLock::enterWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks this object for writing. </p>
<p>This will block until any other threads that have it locked for reading or writing have released their lock.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a3368936be01cf4eb129838230098abe8" title="Releases the write-lock. ">exitWrite</a>, <a class="el" href="group__juce__core-threads.html#classScopedWriteLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedWriteLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7f0b0aefca34943957ac1623b97a8a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ReadWriteLock::tryEnterWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to lock this object for writing. </p>
<p>This is like <a class="el" href="group__juce__core-threads.html#a680913272878d262ab8dff16b3b5a4e7" title="Locks this object for writing. ">enterWrite()</a>, but doesn't block - it returns true if it manages to obtain the lock.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the lock is successfully gained. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a680913272878d262ab8dff16b3b5a4e7" title="Locks this object for writing. ">enterWrite</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3368936be01cf4eb129838230098abe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReadWriteLock::exitWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the write-lock. </p>
<p>If the caller thread hasn't got the lock, this can have unpredictable results.</p>
<p>If the <a class="el" href="group__juce__core-threads.html#a680913272878d262ab8dff16b3b5a4e7" title="Locks this object for writing. ">enterWrite()</a> method has been called multiple times by the thread, each call must be matched by a call to exit() before other threads will be allowed to take over the lock.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a680913272878d262ab8dff16b3b5a4e7" title="Locks this object for writing. ">enterWrite</a>, <a class="el" href="group__juce__core-threads.html#classScopedWriteLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedWriteLock</a> </dd></dl>

</div>
</div>

</div>
</div>
<a name="classGenericScopedLock" id="classGenericScopedLock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class GenericScopedLock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class LockType&gt;<br/>
class GenericScopedLock&lt; LockType &gt;</h3>

<p>Automatically locks and unlocks a mutex object. </p>
<p>Use one of these as a local variable to provide RAII-based locking of a mutex.</p>
<p>The templated class could be a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a>, or anything else that provides enter() and exit() methods.</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><a class="code" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> myCriticalSection;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (;;)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock&lt;CriticalSection&gt;</a> myScopedLock (myCriticalSection);</div>
<div class="line">    <span class="comment">// myCriticalSection is now locked</span></div>
<div class="line"></div>
<div class="line">    ...do some stuff...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// myCriticalSection gets unlocked here.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock" title="Automatically unlocks and re-locks a mutex object. ">GenericScopedUnlock</a>, <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a>, <a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8" title="Automatically locks and unlocks a CriticalSection object. ">ScopedLock</a>, <a class="el" href="group__juce__core-threads.html#ga4cc435f24ace2a8f59b488ed66d9cf2c" title="Automatically unlocks and re-locks a CriticalSection object. ">ScopedUnlock</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:acb13a2d16339b721c40951ce85005eeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#acb13a2d16339b721c40951ce85005eeb">GenericScopedLock</a> (const LockType &amp;lock) noexcept</td></tr>
<tr class="memdesc:acb13a2d16339b721c40951ce85005eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classGenericScopedLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedLock</a>.  <a href="#acb13a2d16339b721c40951ce85005eeb">More...</a><br/></td></tr>
<tr class="separator:acb13a2d16339b721c40951ce85005eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02234589cd2f1c0ff057d4d64beb12e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a02234589cd2f1c0ff057d4d64beb12e1">~GenericScopedLock</a> () noexcept</td></tr>
<tr class="memdesc:a02234589cd2f1c0ff057d4d64beb12e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a02234589cd2f1c0ff057d4d64beb12e1">More...</a><br/></td></tr>
<tr class="separator:a02234589cd2f1c0ff057d4d64beb12e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="acb13a2d16339b721c40951ce85005eeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LockType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock</a>&lt; LockType &gt;::<a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock</a> </td>
          <td>(</td>
          <td class="paramtype">const LockType &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classGenericScopedLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedLock</a>. </p>
<p>As soon as it is created, this will acquire the lock, and when the <a class="el" href="group__juce__core-threads.html#classGenericScopedLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedLock</a> object is deleted, the lock will be released.</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! Best just to use it as a local stack object, rather than creating one with the new() operator. </p>

</div>
</div>
<a class="anchor" id="a02234589cd2f1c0ff057d4d64beb12e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LockType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock</a>&lt; LockType &gt;::~<a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The lock will be released when the destructor is called. Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! </p>

</div>
</div>

</div>
</div>
<a name="classGenericScopedUnlock" id="classGenericScopedUnlock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class GenericScopedUnlock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class LockType&gt;<br/>
class GenericScopedUnlock&lt; LockType &gt;</h3>

<p>Automatically unlocks and re-locks a mutex object. </p>
<p>This is the reverse of a <a class="el" href="group__juce__core-threads.html#classGenericScopedLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedLock</a> object - instead of locking the mutex for the lifetime of this object, it unlocks it.</p>
<p>Make sure you don't try to unlock mutexes that aren't actually locked!</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><a class="code" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> myCriticalSection;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (;;)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock&lt;CriticalSection&gt;</a> myScopedLock (myCriticalSection);</div>
<div class="line">    <span class="comment">// myCriticalSection is now locked</span></div>
<div class="line"></div>
<div class="line">    ... <span class="keywordflow">do</span> some stuff with it locked ..</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span> (xyz)</div>
<div class="line">    {</div>
<div class="line">        ... <span class="keywordflow">do</span> some stuff with it locked ..</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock&lt;CriticalSection&gt;</a> unlocker (myCriticalSection);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// myCriticalSection is now unlocked for the remainder of this block,</span></div>
<div class="line">        <span class="comment">// and re-locked at the end.</span></div>
<div class="line"></div>
<div class="line">        ...do some stuff with it unlocked ...</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// myCriticalSection gets unlocked here.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classGenericScopedLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedLock</a>, <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, <a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8" title="Automatically locks and unlocks a CriticalSection object. ">ScopedLock</a>, <a class="el" href="group__juce__core-threads.html#ga4cc435f24ace2a8f59b488ed66d9cf2c" title="Automatically unlocks and re-locks a CriticalSection object. ">ScopedUnlock</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ab2dc89287c459355d6a04fb5d58d9ce3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab2dc89287c459355d6a04fb5d58d9ce3">GenericScopedUnlock</a> (const LockType &amp;lock) noexcept</td></tr>
<tr class="memdesc:ab2dc89287c459355d6a04fb5d58d9ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock" title="Automatically unlocks and re-locks a mutex object. ">GenericScopedUnlock</a>.  <a href="#ab2dc89287c459355d6a04fb5d58d9ce3">More...</a><br/></td></tr>
<tr class="separator:ab2dc89287c459355d6a04fb5d58d9ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab979a8270fadb8bd835ef693cb5ad474"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab979a8270fadb8bd835ef693cb5ad474">~GenericScopedUnlock</a> () noexcept</td></tr>
<tr class="memdesc:ab979a8270fadb8bd835ef693cb5ad474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab979a8270fadb8bd835ef693cb5ad474">More...</a><br/></td></tr>
<tr class="separator:ab979a8270fadb8bd835ef693cb5ad474"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ab2dc89287c459355d6a04fb5d58d9ce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LockType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock</a>&lt; LockType &gt;::<a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock</a> </td>
          <td>(</td>
          <td class="paramtype">const LockType &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock" title="Automatically unlocks and re-locks a mutex object. ">GenericScopedUnlock</a>. </p>
<p>As soon as it is created, this will unlock the <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, and when the ScopedLock object is deleted, the <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> will be re-locked.</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! Best just to use it as a local stack object, rather than creating one with the new() operator. </p>

</div>
</div>
<a class="anchor" id="ab979a8270fadb8bd835ef693cb5ad474"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LockType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock</a>&lt; LockType &gt;::~<a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> will be unlocked when the destructor is called.</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! </p>

</div>
</div>

</div>
</div>
<a name="classGenericScopedTryLock" id="classGenericScopedTryLock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class GenericScopedTryLock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class LockType&gt;<br/>
class GenericScopedTryLock&lt; LockType &gt;</h3>

<p>Automatically locks and unlocks a mutex object. </p>
<p>Use one of these as a local variable to provide RAII-based locking of a mutex.</p>
<p>The templated class could be a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a>, or anything else that provides enter() and exit() methods.</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><a class="code" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> myCriticalSection;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (;;)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock&lt;CriticalSection&gt;</a> myScopedTryLock (myCriticalSection);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Unlike using a ScopedLock, this may fail to actually get the lock, so you</span></div>
<div class="line">    <span class="comment">// should test this with the isLocked() method before doing your thread-unsafe</span></div>
<div class="line">    <span class="comment">// action..</span></div>
<div class="line">    <span class="keywordflow">if</span> (myScopedTryLock.isLocked())</div>
<div class="line">    {</div>
<div class="line">       ...do some stuff...</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        ..our attempt at locking failed because another thread had already locked it..</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// myCriticalSection gets unlocked here (if it was locked)</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a2c12101da7ebf8455de49652f377d313" title="Attempts to lock this critical section without blocking. ">CriticalSection::tryEnter</a>, <a class="el" href="group__juce__core-threads.html#classGenericScopedLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedLock</a>, <a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock" title="Automatically unlocks and re-locks a mutex object. ">GenericScopedUnlock</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a2d8b85eb72c754b7d2162c3cc296f30a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a2d8b85eb72c754b7d2162c3cc296f30a">GenericScopedTryLock</a> (const LockType &amp;lock) noexcept</td></tr>
<tr class="memdesc:a2d8b85eb72c754b7d2162c3cc296f30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedTryLock</a>.  <a href="#a2d8b85eb72c754b7d2162c3cc296f30a">More...</a><br/></td></tr>
<tr class="separator:a2d8b85eb72c754b7d2162c3cc296f30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa552ec1121d42230080f6dbc614ead99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aa552ec1121d42230080f6dbc614ead99">~GenericScopedTryLock</a> () noexcept</td></tr>
<tr class="memdesc:aa552ec1121d42230080f6dbc614ead99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aa552ec1121d42230080f6dbc614ead99">More...</a><br/></td></tr>
<tr class="separator:aa552ec1121d42230080f6dbc614ead99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0504fe1e14b9a246e5e6018132578b94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0504fe1e14b9a246e5e6018132578b94">isLocked</a> () const noexcept</td></tr>
<tr class="memdesc:a0504fe1e14b9a246e5e6018132578b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the mutex was successfully locked.  <a href="#a0504fe1e14b9a246e5e6018132578b94">More...</a><br/></td></tr>
<tr class="separator:a0504fe1e14b9a246e5e6018132578b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a2d8b85eb72c754b7d2162c3cc296f30a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LockType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock</a>&lt; LockType &gt;::<a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock</a> </td>
          <td>(</td>
          <td class="paramtype">const LockType &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedTryLock</a>. </p>
<p>As soon as it is created, this will attempt to acquire the lock, and when the <a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock" title="Automatically locks and unlocks a mutex object. ">GenericScopedTryLock</a> is deleted, the lock will be released (if the lock was successfully acquired).</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! Best just to use it as a local stack object, rather than creating one with the new() operator. </p>

</div>
</div>
<a class="anchor" id="aa552ec1121d42230080f6dbc614ead99"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LockType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock</a>&lt; LockType &gt;::~<a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The mutex will be unlocked (if it had been successfully locked) when the destructor is called.</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a0504fe1e14b9a246e5e6018132578b94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LockType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__juce__core-threads.html#classGenericScopedTryLock">GenericScopedTryLock</a>&lt; LockType &gt;::isLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the mutex was successfully locked. </p>

</div>
</div>

</div>
</div>
<a name="classScopedReadLock" id="classScopedReadLock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ScopedReadLock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Automatically locks and unlocks a <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a> object. </p>
<p>Use one of these as a local variable to control access to a <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a>.</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><a class="code" href="group__juce__core-threads.html#classReadWriteLock">ReadWriteLock</a> myLock;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (;;)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classScopedReadLock">ScopedReadLock</a> myScopedLock (myLock);</div>
<div class="line">    <span class="comment">// myLock is now locked</span></div>
<div class="line"></div>
<div class="line">    ...do some stuff...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// myLock gets unlocked here.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a>, <a class="el" href="group__juce__core-threads.html#classScopedWriteLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedWriteLock</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a656bd081a1ce9eaebaf1b612ad35ea18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a656bd081a1ce9eaebaf1b612ad35ea18">ScopedReadLock</a> (const <a class="el" href="group__juce__core-threads.html#classReadWriteLock">ReadWriteLock</a> &amp;lock) noexcept</td></tr>
<tr class="memdesc:a656bd081a1ce9eaebaf1b612ad35ea18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a>.  <a href="#a656bd081a1ce9eaebaf1b612ad35ea18">More...</a><br/></td></tr>
<tr class="separator:a656bd081a1ce9eaebaf1b612ad35ea18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81becd93947c0103c2c9461e4ddbe594"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a81becd93947c0103c2c9461e4ddbe594">~ScopedReadLock</a> () noexcept</td></tr>
<tr class="memdesc:a81becd93947c0103c2c9461e4ddbe594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a81becd93947c0103c2c9461e4ddbe594">More...</a><br/></td></tr>
<tr class="separator:a81becd93947c0103c2c9461e4ddbe594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a656bd081a1ce9eaebaf1b612ad35ea18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ScopedReadLock::ScopedReadLock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-threads.html#classReadWriteLock">ReadWriteLock</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a>. </p>
<p>As soon as it is created, this will call <a class="el" href="group__juce__core-threads.html#ae69612d80a6abdccfd0f911eea78bec7" title="Locks this object for reading. ">ReadWriteLock::enterRead()</a>, and when the <a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a> object is deleted, the <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a> will be unlocked.</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! Best just to use it as a local stack object, rather than creating one with the new() operator. </p>

</div>
</div>
<a class="anchor" id="a81becd93947c0103c2c9461e4ddbe594"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ScopedReadLock::~ScopedReadLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a>'s exitRead() method will be called when the destructor is called.</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! </p>

</div>
</div>

</div>
</div>
<a name="classScopedWriteLock" id="classScopedWriteLock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ScopedWriteLock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Automatically locks and unlocks a <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a> object. </p>
<p>Use one of these as a local variable to control access to a <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a>.</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><a class="code" href="group__juce__core-threads.html#classReadWriteLock">ReadWriteLock</a> myLock;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">for</span> (;;)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classScopedWriteLock">ScopedWriteLock</a> myScopedLock (myLock);</div>
<div class="line">    <span class="comment">// myLock is now locked</span></div>
<div class="line"></div>
<div class="line">    ...do some stuff...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// myLock gets unlocked here.</span></div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a>, <a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ab06884cb60e1e7231cc0b16ed10d7004"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab06884cb60e1e7231cc0b16ed10d7004">ScopedWriteLock</a> (const <a class="el" href="group__juce__core-threads.html#classReadWriteLock">ReadWriteLock</a> &amp;lock) noexcept</td></tr>
<tr class="memdesc:ab06884cb60e1e7231cc0b16ed10d7004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classScopedWriteLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedWriteLock</a>.  <a href="#ab06884cb60e1e7231cc0b16ed10d7004">More...</a><br/></td></tr>
<tr class="separator:ab06884cb60e1e7231cc0b16ed10d7004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108b0a03c0b13ab6378b4ea68618d497"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a108b0a03c0b13ab6378b4ea68618d497">~ScopedWriteLock</a> () noexcept</td></tr>
<tr class="memdesc:a108b0a03c0b13ab6378b4ea68618d497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a108b0a03c0b13ab6378b4ea68618d497">More...</a><br/></td></tr>
<tr class="separator:a108b0a03c0b13ab6378b4ea68618d497"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ab06884cb60e1e7231cc0b16ed10d7004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ScopedWriteLock::ScopedWriteLock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-threads.html#classReadWriteLock">ReadWriteLock</a> &amp;&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classScopedWriteLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedWriteLock</a>. </p>
<p>As soon as it is created, this will call <a class="el" href="group__juce__core-threads.html#a680913272878d262ab8dff16b3b5a4e7" title="Locks this object for writing. ">ReadWriteLock::enterWrite()</a>, and when the <a class="el" href="group__juce__core-threads.html#classScopedWriteLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedWriteLock</a> object is deleted, the <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a> will be unlocked.</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! Best just to use it as a local stack object, rather than creating one with the new() operator. </p>

</div>
</div>
<a class="anchor" id="a108b0a03c0b13ab6378b4ea68618d497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ScopedWriteLock::~ScopedWriteLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The <a class="el" href="group__juce__core-threads.html#classReadWriteLock" title="A critical section that allows multiple simultaneous readers. ">ReadWriteLock</a>'s exitWrite() method will be called when the destructor is called.</p>
<p>Make sure this object is created and deleted by the same thread, otherwise there are no guarantees what will happen! </p>

</div>
</div>

</div>
</div>
<a name="classSpinLock" id="classSpinLock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class SpinLock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations. </p>
<p>Note that unlike a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, this type of lock is not re-entrant, and may be less efficient when used it a highly contended situation, but it's very small and requires almost no initialisation. It's most appropriate for simple situations where you're only going to hold the lock for a very brief time.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a8239db74a56ce60a114cd369ed6a41f0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock</a><br class="typebreak"/>
&lt; <a class="el" href="group__juce__core-threads.html#classSpinLock">SpinLock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a8239db74a56ce60a114cd369ed6a41f0">ScopedLockType</a></td></tr>
<tr class="memdesc:a8239db74a56ce60a114cd369ed6a41f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the type of scoped lock to use for locking a <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a>.  <a href="#a8239db74a56ce60a114cd369ed6a41f0">More...</a><br/></td></tr>
<tr class="separator:a8239db74a56ce60a114cd369ed6a41f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae531d71996d5122e0caa8a10212cf585"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock</a><br class="typebreak"/>
&lt; <a class="el" href="group__juce__core-threads.html#classSpinLock">SpinLock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae531d71996d5122e0caa8a10212cf585">ScopedUnlockType</a></td></tr>
<tr class="memdesc:ae531d71996d5122e0caa8a10212cf585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the type of scoped unlocker to use with a <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a>.  <a href="#ae531d71996d5122e0caa8a10212cf585">More...</a><br/></td></tr>
<tr class="separator:ae531d71996d5122e0caa8a10212cf585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a204af2b708c1678699ce0a235c229c64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a204af2b708c1678699ce0a235c229c64">SpinLock</a> () noexcept</td></tr>
<tr class="separator:a204af2b708c1678699ce0a235c229c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ac2bc2ea9faeb66d861ea0b9cdc7cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae5ac2bc2ea9faeb66d861ea0b9cdc7cd">~SpinLock</a> () noexcept</td></tr>
<tr class="separator:ae5ac2bc2ea9faeb66d861ea0b9cdc7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9079933ef4fdd1527fd0bf90f1062e02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9079933ef4fdd1527fd0bf90f1062e02">enter</a> () const noexcept</td></tr>
<tr class="memdesc:a9079933ef4fdd1527fd0bf90f1062e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock.  <a href="#a9079933ef4fdd1527fd0bf90f1062e02">More...</a><br/></td></tr>
<tr class="separator:a9079933ef4fdd1527fd0bf90f1062e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4581a24b50dad1a9803b19f65af70aaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a4581a24b50dad1a9803b19f65af70aaf">tryEnter</a> () const noexcept</td></tr>
<tr class="memdesc:a4581a24b50dad1a9803b19f65af70aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to acquire the lock, returning true if this was successful.  <a href="#a4581a24b50dad1a9803b19f65af70aaf">More...</a><br/></td></tr>
<tr class="separator:a4581a24b50dad1a9803b19f65af70aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a3a2f0d2a659b493a9c6e93e8d95f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a13a3a2f0d2a659b493a9c6e93e8d95f8">exit</a> () const noexcept</td></tr>
<tr class="memdesc:a13a3a2f0d2a659b493a9c6e93e8d95f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock.  <a href="#a13a3a2f0d2a659b493a9c6e93e8d95f8">More...</a><br/></td></tr>
<tr class="separator:a13a3a2f0d2a659b493a9c6e93e8d95f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="a8239db74a56ce60a114cd369ed6a41f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedLock">GenericScopedLock</a>&lt;<a class="el" href="group__juce__core-threads.html#classSpinLock">SpinLock</a>&gt; <a class="el" href="group__juce__core-threads.html#a8239db74a56ce60a114cd369ed6a41f0">SpinLock::ScopedLockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the type of scoped lock to use for locking a <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a>. </p>

</div>
</div>
<a class="anchor" id="ae531d71996d5122e0caa8a10212cf585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-threads.html#classGenericScopedUnlock">GenericScopedUnlock</a>&lt;<a class="el" href="group__juce__core-threads.html#classSpinLock">SpinLock</a>&gt; <a class="el" href="group__juce__core-threads.html#ae531d71996d5122e0caa8a10212cf585">SpinLock::ScopedUnlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the type of scoped unlocker to use with a <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a>. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a204af2b708c1678699ce0a235c229c64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpinLock::SpinLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5ac2bc2ea9faeb66d861ea0b9cdc7cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpinLock::~SpinLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a9079933ef4fdd1527fd0bf90f1062e02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SpinLock::enter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires the lock. </p>
<p>This will block until the lock has been successfully acquired by this thread. Note that a <a class="el" href="group__juce__core-threads.html#classSpinLock" title="A simple spin-lock class that can be used as a simple, low-overhead mutex for uncontended situations...">SpinLock</a> is NOT re-entrant, and is not smart enough to know whether the caller thread already has the lock - so if a thread tries to acquire a lock that it already holds, this method will never return!</p>
<p>It's strongly recommended that you never call this method directly - instead use the ScopedLockType class to manage the locking using an RAII pattern instead. </p>

</div>
</div>
<a class="anchor" id="a4581a24b50dad1a9803b19f65af70aaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SpinLock::tryEnter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to acquire the lock, returning true if this was successful. </p>

</div>
</div>
<a class="anchor" id="a13a3a2f0d2a659b493a9c6e93e8d95f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SpinLock::exit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock. </p>

<p>References <a class="el" href="group__juce__core-system.html#ga1f96ab6751237979b907a54f52a7296a">jassert</a>.</p>

</div>
</div>

</div>
</div>
<a name="classThread" id="classThread"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class Thread</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Encapsulates a thread. </p>
<p>Subclasses derive from <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a> and implement the <a class="el" href="group__juce__core-threads.html#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code. ">run()</a> method, in which they do their business. The thread can then be started with the <a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983" title="Starts the thread running. ">startThread()</a> method and controlled with various other methods.</p>
<p>This class also contains some thread-related static methods, such as <a class="el" href="group__juce__core-threads.html#a4ee1ddee32aa82ac90bc567cb7427926">sleep()</a>, <a class="el" href="group__juce__core-threads.html#aaf47a344b3b715e49ffcbc6119c72cdc" title="Yields the calling thread&#39;s current time-slot. ">yield()</a>, <a class="el" href="group__juce__core-threads.html#abd4762b20144186ffc28280cedd224e9" title="Returns an id that identifies the caller thread. ">getCurrentThreadId()</a> etc.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, <a class="el" href="group__juce__core-threads.html#classWaitableEvent" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a>, <a class="el" href="group__juce__core-threads.html#classProcess" title="Represents the current executable&#39;s process. ">Process</a>, <a class="el" href="group__juce__gui__basics-windows.html#classThreadWithProgressWindow" title="A thread that automatically pops up a modal dialog box with a progress bar and cancel button while it...">ThreadWithProgressWindow</a>, <a class="el" href="group__juce__events-messages.html#classMessageManagerLock" title="Used to make sure that the calling thread has exclusive access to the message loop. ">MessageManagerLock</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for Thread:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classThread__inherit__graph.svg" width="675" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a57e37e78ad201531166b450b64c428b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__juce__core-threads.html#a57e37e78ad201531166b450b64c428b6a0ee7fcab9f979f4e867c718460ce5503">realtimeAudioPriority</a> = -1
 }</td></tr>
<tr class="memdesc:a57e37e78ad201531166b450b64c428b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special realtime audio thread priority.  <a href="group__juce__core-threads.html#a57e37e78ad201531166b450b64c428b6">More...</a><br/></td></tr>
<tr class="separator:a57e37e78ad201531166b450b64c428b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077e20855a3c974c2fc6f9e7caa8412c"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">ThreadID</a></td></tr>
<tr class="memdesc:a077e20855a3c974c2fc6f9e7caa8412c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value type used for thread IDs.  <a href="#a077e20855a3c974c2fc6f9e7caa8412c">More...</a><br/></td></tr>
<tr class="separator:a077e20855a3c974c2fc6f9e7caa8412c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a9105c0abed75dd620b80c8c5e8b01603"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9105c0abed75dd620b80c8c5e8b01603">Thread</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;threadName, size_t threadStackSize=0)</td></tr>
<tr class="memdesc:a9105c0abed75dd620b80c8c5e8b01603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread.  <a href="#a9105c0abed75dd620b80c8c5e8b01603">More...</a><br/></td></tr>
<tr class="separator:a9105c0abed75dd620b80c8c5e8b01603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026b23628e1727050e864e00489c0baf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a026b23628e1727050e864e00489c0baf">~Thread</a> ()</td></tr>
<tr class="memdesc:a026b23628e1727050e864e00489c0baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a026b23628e1727050e864e00489c0baf">More...</a><br/></td></tr>
<tr class="separator:a026b23628e1727050e864e00489c0baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae90dfabab3e1776cf01a26e7ee3a620"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aae90dfabab3e1776cf01a26e7ee3a620">run</a> ()=0</td></tr>
<tr class="memdesc:aae90dfabab3e1776cf01a26e7ee3a620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be implemented to perform the thread's actual code.  <a href="#aae90dfabab3e1776cf01a26e7ee3a620">More...</a><br/></td></tr>
<tr class="separator:aae90dfabab3e1776cf01a26e7ee3a620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5502205d727c00752f95af27a063d983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983">startThread</a> ()</td></tr>
<tr class="memdesc:a5502205d727c00752f95af27a063d983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the thread running.  <a href="#a5502205d727c00752f95af27a063d983">More...</a><br/></td></tr>
<tr class="separator:a5502205d727c00752f95af27a063d983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4aff2ceb97b0f16a0a08132315a900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#acc4aff2ceb97b0f16a0a08132315a900">startThread</a> (int priority)</td></tr>
<tr class="memdesc:acc4aff2ceb97b0f16a0a08132315a900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the thread with a given priority.  <a href="#acc4aff2ceb97b0f16a0a08132315a900">More...</a><br/></td></tr>
<tr class="separator:acc4aff2ceb97b0f16a0a08132315a900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18583d51411d6a34c59b63f0adff4697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a18583d51411d6a34c59b63f0adff4697">stopThread</a> (int timeOutMilliseconds)</td></tr>
<tr class="memdesc:a18583d51411d6a34c59b63f0adff4697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to stop the thread running.  <a href="#a18583d51411d6a34c59b63f0adff4697">More...</a><br/></td></tr>
<tr class="separator:a18583d51411d6a34c59b63f0adff4697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02ad2d11a2dacfea4a78b06224a3e87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab02ad2d11a2dacfea4a78b06224a3e87">isThreadRunning</a> () const </td></tr>
<tr class="memdesc:ab02ad2d11a2dacfea4a78b06224a3e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the thread is currently active.  <a href="#ab02ad2d11a2dacfea4a78b06224a3e87">More...</a><br/></td></tr>
<tr class="separator:ab02ad2d11a2dacfea4a78b06224a3e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe168e27c6ee50b0d10522810772268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#affe168e27c6ee50b0d10522810772268">signalThreadShouldExit</a> ()</td></tr>
<tr class="memdesc:affe168e27c6ee50b0d10522810772268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag to tell the thread it should stop.  <a href="#affe168e27c6ee50b0d10522810772268">More...</a><br/></td></tr>
<tr class="separator:affe168e27c6ee50b0d10522810772268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8fdce313d3c0db6c5adbb78c4352b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4">threadShouldExit</a> () const </td></tr>
<tr class="memdesc:a0a8fdce313d3c0db6c5adbb78c4352b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the thread has been told to stop running.  <a href="#a0a8fdce313d3c0db6c5adbb78c4352b4">More...</a><br/></td></tr>
<tr class="separator:a0a8fdce313d3c0db6c5adbb78c4352b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277e5e91d52626bbdac85b44972dd46a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a277e5e91d52626bbdac85b44972dd46a">waitForThreadToExit</a> (int timeOutMilliseconds) const </td></tr>
<tr class="memdesc:a277e5e91d52626bbdac85b44972dd46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the thread to stop.  <a href="#a277e5e91d52626bbdac85b44972dd46a">More...</a><br/></td></tr>
<tr class="separator:a277e5e91d52626bbdac85b44972dd46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0975d9ee9f403f5f82287fcce4a7168f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0975d9ee9f403f5f82287fcce4a7168f">setPriority</a> (int priority)</td></tr>
<tr class="memdesc:a0975d9ee9f403f5f82287fcce4a7168f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the thread's priority.  <a href="#a0975d9ee9f403f5f82287fcce4a7168f">More...</a><br/></td></tr>
<tr class="separator:a0975d9ee9f403f5f82287fcce4a7168f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614605563fceeac6f03d507bc35bdce4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a614605563fceeac6f03d507bc35bdce4">setAffinityMask</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> affinityMask)</td></tr>
<tr class="memdesc:a614605563fceeac6f03d507bc35bdce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the affinity mask for the thread.  <a href="#a614605563fceeac6f03d507bc35bdce4">More...</a><br/></td></tr>
<tr class="separator:a614605563fceeac6f03d507bc35bdce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17aca9c9609310f830298d6a0206d18d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a17aca9c9609310f830298d6a0206d18d">wait</a> (int timeOutMilliseconds) const </td></tr>
<tr class="memdesc:a17aca9c9609310f830298d6a0206d18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the thread wait for a notification.  <a href="#a17aca9c9609310f830298d6a0206d18d">More...</a><br/></td></tr>
<tr class="separator:a17aca9c9609310f830298d6a0206d18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e6408f187557bb06c8fff07c4100b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae0e6408f187557bb06c8fff07c4100b7">notify</a> () const </td></tr>
<tr class="memdesc:ae0e6408f187557bb06c8fff07c4100b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up the thread.  <a href="#ae0e6408f187557bb06c8fff07c4100b7">More...</a><br/></td></tr>
<tr class="separator:ae0e6408f187557bb06c8fff07c4100b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca822734b9b20ab32eeba774c9a803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">ThreadID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a39ca822734b9b20ab32eeba774c9a803">getThreadId</a> () const noexcept</td></tr>
<tr class="memdesc:a39ca822734b9b20ab32eeba774c9a803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this thread.  <a href="#a39ca822734b9b20ab32eeba774c9a803">More...</a><br/></td></tr>
<tr class="separator:a39ca822734b9b20ab32eeba774c9a803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ae21de0884d0814efe13de1ff475be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a04ae21de0884d0814efe13de1ff475be">getThreadName</a> () const noexcept</td></tr>
<tr class="memdesc:a04ae21de0884d0814efe13de1ff475be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the thread.  <a href="#a04ae21de0884d0814efe13de1ff475be">More...</a><br/></td></tr>
<tr class="separator:a04ae21de0884d0814efe13de1ff475be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:a0a1c520e431e3e5101ce2da8606baf26"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0a1c520e431e3e5101ce2da8606baf26">launch</a> (<a class="el" href="group__juce__core-misc.html#classstd_1_1function">std::function</a>&lt; void()&gt; functionToRun)</td></tr>
<tr class="memdesc:a0a1c520e431e3e5101ce2da8606baf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a lambda or function on its own thread.  <a href="#a0a1c520e431e3e5101ce2da8606baf26">More...</a><br/></td></tr>
<tr class="separator:a0a1c520e431e3e5101ce2da8606baf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92778089556fd0b5ab9c31557669ce8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac92778089556fd0b5ab9c31557669ce8">currentThreadShouldExit</a> ()</td></tr>
<tr class="memdesc:ac92778089556fd0b5ab9c31557669ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the current thread has been told to stop running.  <a href="#ac92778089556fd0b5ab9c31557669ce8">More...</a><br/></td></tr>
<tr class="separator:ac92778089556fd0b5ab9c31557669ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a777202bb5aa9ce7f57605674b100f4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9a777202bb5aa9ce7f57605674b100f4">setCurrentThreadPriority</a> (int priority)</td></tr>
<tr class="memdesc:a9a777202bb5aa9ce7f57605674b100f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the priority of the caller thread.  <a href="#a9a777202bb5aa9ce7f57605674b100f4">More...</a><br/></td></tr>
<tr class="separator:a9a777202bb5aa9ce7f57605674b100f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21eb5ae8c32bc2ecacba904f3411802"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac21eb5ae8c32bc2ecacba904f3411802">setCurrentThreadAffinityMask</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> affinityMask)</td></tr>
<tr class="memdesc:ac21eb5ae8c32bc2ecacba904f3411802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the affinity mask for the caller thread.  <a href="#ac21eb5ae8c32bc2ecacba904f3411802">More...</a><br/></td></tr>
<tr class="separator:ac21eb5ae8c32bc2ecacba904f3411802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee1ddee32aa82ac90bc567cb7427926"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a4ee1ddee32aa82ac90bc567cb7427926">sleep</a> (int milliseconds)</td></tr>
<tr class="separator:a4ee1ddee32aa82ac90bc567cb7427926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf47a344b3b715e49ffcbc6119c72cdc"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aaf47a344b3b715e49ffcbc6119c72cdc">yield</a> ()</td></tr>
<tr class="memdesc:aaf47a344b3b715e49ffcbc6119c72cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the calling thread's current time-slot.  <a href="#aaf47a344b3b715e49ffcbc6119c72cdc">More...</a><br/></td></tr>
<tr class="separator:aaf47a344b3b715e49ffcbc6119c72cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4762b20144186ffc28280cedd224e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">ThreadID</a> <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#abd4762b20144186ffc28280cedd224e9">getCurrentThreadId</a> ()</td></tr>
<tr class="memdesc:abd4762b20144186ffc28280cedd224e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an id that identifies the caller thread.  <a href="#abd4762b20144186ffc28280cedd224e9">More...</a><br/></td></tr>
<tr class="separator:abd4762b20144186ffc28280cedd224e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9f45ea3ff9a7d39a50f78059640cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-threads.html#classThread">Thread</a> *<a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a40a9f45ea3ff9a7d39a50f78059640cd">getCurrentThread</a> ()</td></tr>
<tr class="memdesc:a40a9f45ea3ff9a7d39a50f78059640cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the thread object that is currently running.  <a href="#a40a9f45ea3ff9a7d39a50f78059640cd">More...</a><br/></td></tr>
<tr class="separator:a40a9f45ea3ff9a7d39a50f78059640cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba2a683ea8111c08db83092360b7226"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a8ba2a683ea8111c08db83092360b7226">setCurrentThreadName</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;newThreadName)</td></tr>
<tr class="memdesc:a8ba2a683ea8111c08db83092360b7226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name of the caller thread.  <a href="#a8ba2a683ea8111c08db83092360b7226">More...</a><br/></td></tr>
<tr class="separator:a8ba2a683ea8111c08db83092360b7226"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="a077e20855a3c974c2fc6f9e7caa8412c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">Thread::ThreadID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value type used for thread IDs. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#abd4762b20144186ffc28280cedd224e9" title="Returns an id that identifies the caller thread. ">getCurrentThreadId()</a>, <a class="el" href="group__juce__core-threads.html#a39ca822734b9b20ab32eeba774c9a803" title="Returns the ID of this thread. ">getThreadId()</a> </dd></dl>

</div>
</div>
<h4 class="groupheader">Member Enumeration Documentation</h4>
<a class="anchor" id="a57e37e78ad201531166b450b64c428b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special realtime audio thread priority. </p>
<p>This priority will create a high-priority thread which is best suited for realtime audio processing.</p>
<p>Currently, this priority is identical to priority 9, except when building for Android with OpenSL support.</p>
<p>In this case, JUCE will ask OpenSL to consturct a super high priority thread specifically for realtime audio processing.</p>
<p>Note that this priority can only be set <b>before</b> the thread has started. Switching to this priority, or from this priority to a different priority, is not supported under Android and will assert.</p>
<p>For best performance this thread should yield at regular intervals and not call any blocking APIS.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983" title="Starts the thread running. ">startThread</a>, <a class="el" href="group__juce__core-threads.html#a0975d9ee9f403f5f82287fcce4a7168f" title="Changes the thread&#39;s priority. ">setPriority</a>, <a class="el" href="group__juce__core-threads.html#a4ee1ddee32aa82ac90bc567cb7427926">sleep</a>, <a class="el" href="group__juce__core-threads.html#classWaitableEvent" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a57e37e78ad201531166b450b64c428b6a0ee7fcab9f979f4e867c718460ce5503"></a>realtimeAudioPriority</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a9105c0abed75dd620b80c8c5e8b01603"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Thread::Thread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>threadName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threadStackSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread. </p>
<p>When first created, the thread is not running. Use the <a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983" title="Starts the thread running. ">startThread()</a> method to start it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threadName</td><td>The name of the thread which typically appears in debug logs and profiles. </td></tr>
    <tr><td class="paramname">threadStackSize</td><td>The size of the stack of the thread. If this value is zero then the default stack size of the OS will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a026b23628e1727050e864e00489c0baf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Thread::~Thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>You must never attempt to delete a <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a> object while it's still running - always call <a class="el" href="group__juce__core-threads.html#a18583d51411d6a34c59b63f0adff4697" title="Attempts to stop the thread running. ">stopThread()</a> and make sure your thread has stopped before deleting the object. Failing to do so will throw an assertion, and put you firmly into undefined behaviour territory. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="aae90dfabab3e1776cf01a26e7ee3a620"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Thread::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must be implemented to perform the thread's actual code. </p>
<p>Remember that the thread must regularly check the <a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4" title="Checks whether the thread has been told to stop running. ">threadShouldExit()</a> method whilst running, and if this returns true it should return from the <a class="el" href="group__juce__core-threads.html#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code. ">run()</a> method as soon as possible to avoid being forcibly killed.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4" title="Checks whether the thread has been told to stop running. ">threadShouldExit</a>, <a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983" title="Starts the thread running. ">startThread</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5502205d727c00752f95af27a063d983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::startThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the thread running. </p>
<p>This will cause the thread's <a class="el" href="group__juce__core-threads.html#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code. ">run()</a> method to be called by a new thread. If this thread is already running, <a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983" title="Starts the thread running. ">startThread()</a> won't do anything.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a18583d51411d6a34c59b63f0adff4697" title="Attempts to stop the thread running. ">stopThread</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acc4aff2ceb97b0f16a0a08132315a900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::startThread </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the thread with a given priority. </p>
<p>Launches the thread with a given priority, where 0 = lowest, 10 = highest. If the thread is already running, its priority will be changed.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983" title="Starts the thread running. ">startThread</a>, <a class="el" href="group__juce__core-threads.html#a0975d9ee9f403f5f82287fcce4a7168f" title="Changes the thread&#39;s priority. ">setPriority</a>, <a class="el" href="group__juce__core-threads.html#a57e37e78ad201531166b450b64c428b6a0ee7fcab9f979f4e867c718460ce5503">realtimeAudioPriority</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a18583d51411d6a34c59b63f0adff4697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::stopThread </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMilliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to stop the thread running. </p>
<p>This method will cause the <a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4" title="Checks whether the thread has been told to stop running. ">threadShouldExit()</a> method to return true and call <a class="el" href="group__juce__core-threads.html#ae0e6408f187557bb06c8fff07c4100b7" title="Wakes up the thread. ">notify()</a> in case the thread is currently waiting.</p>
<p>Hopefully the thread will then respond to this by exiting cleanly, and the stopThread method will wait for a given time-period for this to happen.</p>
<p>If the thread is stuck and fails to respond after the time-out, it gets forcibly killed, which is a very bad thing to happen, as it could still be holding locks, etc. which are needed by other parts of your program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOutMilliseconds</td><td>The number of milliseconds to wait for the thread to finish before killing it by force. A negative value in here will wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread was cleanly stopped before the timeout, or false if it had to be killed by force. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#affe168e27c6ee50b0d10522810772268" title="Sets a flag to tell the thread it should stop. ">signalThreadShouldExit</a>, <a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4" title="Checks whether the thread has been told to stop running. ">threadShouldExit</a>, <a class="el" href="group__juce__core-threads.html#a277e5e91d52626bbdac85b44972dd46a" title="Waits for the thread to stop. ">waitForThreadToExit</a>, <a class="el" href="group__juce__core-threads.html#ab02ad2d11a2dacfea4a78b06224a3e87" title="Returns true if the thread is currently active. ">isThreadRunning</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a1c520e431e3e5101ce2da8606baf26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Thread::launch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-misc.html#classstd_1_1function">std::function</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>functionToRun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invokes a lambda or function on its own thread. </p>
<p>This will spin up a <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a> object which calls the function and then exits. Bear in mind that starting and stopping a thread can be a fairly heavyweight operation, so you might prefer to use a <a class="el" href="group__juce__core-threads.html#classThreadPool" title="A set of threads that will run a list of jobs. ">ThreadPool</a> if you're kicking off a lot of short background tasks. Also note that using an anonymous thread makes it very difficult to interrupt the function when you need to stop it, e.g. when your app quits. So it's up to you to deal with situations where the function may fail to stop in time. </p>

</div>
</div>
<a class="anchor" id="ab02ad2d11a2dacfea4a78b06224a3e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::isThreadRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the thread is currently active. </p>

</div>
</div>
<a class="anchor" id="affe168e27c6ee50b0d10522810772268"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::signalThreadShouldExit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a flag to tell the thread it should stop. </p>
<p>Calling this means that the <a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4" title="Checks whether the thread has been told to stop running. ">threadShouldExit()</a> method will then return true. The thread should be regularly checking this to see whether it should exit.</p>
<p>If your thread makes use of <a class="el" href="group__juce__core-threads.html#a17aca9c9609310f830298d6a0206d18d" title="Makes the thread wait for a notification. ">wait()</a>, you might want to call <a class="el" href="group__juce__core-threads.html#ae0e6408f187557bb06c8fff07c4100b7" title="Wakes up the thread. ">notify()</a> after calling this method, to interrupt any waits that might be in progress, and allow it to reach a point where it can exit.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4" title="Checks whether the thread has been told to stop running. ">threadShouldExit</a> </dd>
<dd>
<a class="el" href="group__juce__core-threads.html#a277e5e91d52626bbdac85b44972dd46a" title="Waits for the thread to stop. ">waitForThreadToExit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0a8fdce313d3c0db6c5adbb78c4352b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::threadShouldExit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the thread has been told to stop running. </p>
<p>Threads need to check this regularly, and if it returns true, they should return from their <a class="el" href="group__juce__core-threads.html#aae90dfabab3e1776cf01a26e7ee3a620" title="Must be implemented to perform the thread&#39;s actual code. ">run()</a> method at the first possible opportunity.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#affe168e27c6ee50b0d10522810772268" title="Sets a flag to tell the thread it should stop. ">signalThreadShouldExit</a>, <a class="el" href="group__juce__core-threads.html#ac92778089556fd0b5ab9c31557669ce8" title="Checks whether the current thread has been told to stop running. ">currentThreadShouldExit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac92778089556fd0b5ab9c31557669ce8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Thread::currentThreadShouldExit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the current thread has been told to stop running. </p>
<p>On the message thread, this will always return false, otherwise it will return <a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4" title="Checks whether the thread has been told to stop running. ">threadShouldExit()</a> called on the current thread.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4" title="Checks whether the thread has been told to stop running. ">threadShouldExit</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a277e5e91d52626bbdac85b44972dd46a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::waitForThreadToExit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMilliseconds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for the thread to stop. </p>
<p>This will wait until <a class="el" href="group__juce__core-threads.html#ab02ad2d11a2dacfea4a78b06224a3e87" title="Returns true if the thread is currently active. ">isThreadRunning()</a> is false or until a timeout expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOutMilliseconds</td><td>the time to wait, in milliseconds. If this value is less than zero, it will wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the thread exits, or false if the timeout expires first. </dd></dl>

</div>
</div>
<a class="anchor" id="a0975d9ee9f403f5f82287fcce4a7168f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::setPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the thread's priority. </p>
<p>May return false if for some reason the priority can't be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>the new priority, in the range 0 (lowest) to 10 (highest). A priority of 5 is normal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a57e37e78ad201531166b450b64c428b6a0ee7fcab9f979f4e867c718460ce5503">realtimeAudioPriority</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a777202bb5aa9ce7f57605674b100f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Thread::setCurrentThreadPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the priority of the caller thread. </p>
<p>Similar to <a class="el" href="group__juce__core-threads.html#a0975d9ee9f403f5f82287fcce4a7168f" title="Changes the thread&#39;s priority. ">setPriority()</a>, but this static method acts on the caller thread. May return false if for some reason the priority can't be changed.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a0975d9ee9f403f5f82287fcce4a7168f" title="Changes the thread&#39;s priority. ">setPriority</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a614605563fceeac6f03d507bc35bdce4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::setAffinityMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>affinityMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the affinity mask for the thread. </p>
<p>This will only have an effect next time the thread is started - i.e. if the thread is already running when called, it'll have no effect.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#ac21eb5ae8c32bc2ecacba904f3411802" title="Changes the affinity mask for the caller thread. ">setCurrentThreadAffinityMask</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac21eb5ae8c32bc2ecacba904f3411802"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::setCurrentThreadAffinityMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>affinityMask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the affinity mask for the caller thread. </p>
<p>This will change the affinity mask for the thread that calls this static method. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a614605563fceeac6f03d507bc35bdce4" title="Sets the affinity mask for the thread. ">setAffinityMask</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4ee1ddee32aa82ac90bc567cb7427926"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::sleep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf47a344b3b715e49ffcbc6119c72cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Yields the calling thread's current time-slot. </p>

</div>
</div>
<a class="anchor" id="a17aca9c9609310f830298d6a0206d18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Thread::wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMilliseconds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the thread wait for a notification. </p>
<p>This puts the thread to sleep until either the timeout period expires, or another thread calls the <a class="el" href="group__juce__core-threads.html#ae0e6408f187557bb06c8fff07c4100b7" title="Wakes up the thread. ">notify()</a> method to wake it up.</p>
<p>A negative time-out value means that the method will wait indefinitely.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the event has been signalled, false if the timeout expires. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0e6408f187557bb06c8fff07c4100b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Thread::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wakes up the thread. </p>
<p>If the thread has called the <a class="el" href="group__juce__core-threads.html#a17aca9c9609310f830298d6a0206d18d" title="Makes the thread wait for a notification. ">wait()</a> method, this will wake it up.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a17aca9c9609310f830298d6a0206d18d" title="Makes the thread wait for a notification. ">wait</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd4762b20144186ffc28280cedd224e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">ThreadID</a> <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::getCurrentThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an id that identifies the caller thread. </p>
<p>To find the ID of a particular thread object, use <a class="el" href="group__juce__core-threads.html#a39ca822734b9b20ab32eeba774c9a803" title="Returns the ID of this thread. ">getThreadId()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique identifier that identifies the calling thread. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a39ca822734b9b20ab32eeba774c9a803" title="Returns the ID of this thread. ">getThreadId</a> </dd></dl>

<p>Referenced by <a class="el" href="group__juce__core-threads.html#a0350ab3d9b5d1877dec3244d5b4e71e9">ThreadLocalValue&lt; Type &gt;::get()</a>, and <a class="el" href="group__juce__core-threads.html#a78af45671b2b057f0f584a75f79ff5b5">ThreadLocalValue&lt; Type &gt;::releaseCurrentThreadStorage()</a>.</p>

</div>
</div>
<a class="anchor" id="a40a9f45ea3ff9a7d39a50f78059640cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__juce__core-threads.html#classThread">Thread</a>* <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::getCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the thread object that is currently running. </p>
<p>Note that the main UI thread (or other non-Juce threads) don't have a <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a> object associated with them, so this will return nullptr. </p>

</div>
</div>
<a class="anchor" id="a39ca822734b9b20ab32eeba774c9a803"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">ThreadID</a> Thread::getThreadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this thread. </p>
<p>That means the ID of this thread object - not of the thread that's calling the method. This can change when the thread is started and stopped, and will be invalid if the thread's not actually running. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#abd4762b20144186ffc28280cedd224e9" title="Returns an id that identifies the caller thread. ">getCurrentThreadId</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a04ae21de0884d0814efe13de1ff475be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__juce__core-text.html#classString">String</a>&amp; Thread::getThreadName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the thread. </p>
<p>This is the name that gets set in the constructor. </p>

</div>
</div>
<a class="anchor" id="a8ba2a683ea8111c08db83092360b7226"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a> Thread::setCurrentThreadName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>newThreadName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the name of the caller thread. </p>
<p>Different OSes may place different length or content limits on this name. </p>

</div>
</div>

</div>
</div>
<a name="classThreadLocalValue" id="classThreadLocalValue"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ThreadLocalValue</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Type&gt;<br/>
class ThreadLocalValue&lt; Type &gt;</h3>

<p>Provides cross-platform support for thread-local objects. </p>
<p>This class holds an internal list of objects of the templated type, keeping an instance for each thread that requests one. The first time a thread attempts to access its value, an object is created and added to the list for that thread.</p>
<p>Typically, you'll probably want to create a static instance of a <a class="el" href="group__juce__core-threads.html#classThreadLocalValue" title="Provides cross-platform support for thread-local objects. ">ThreadLocalValue</a> object, or hold one within a singleton.</p>
<p>The templated class for your value must be a primitive type, or a simple POD struct.</p>
<p>When a thread no longer needs to use its value, it can call <a class="el" href="group__juce__core-threads.html#a78af45671b2b057f0f584a75f79ff5b5" title="Called by a thread before it terminates, to allow this class to release any storage associated with t...">releaseCurrentThreadStorage()</a> to allow the storage to be re-used by another thread. If a thread exits without calling this method, the object storage will be left allocated until the <a class="el" href="group__juce__core-threads.html#classThreadLocalValue" title="Provides cross-platform support for thread-local objects. ">ThreadLocalValue</a> object is deleted. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a6cfe38fdd495adcfdad8dc3dc736f371"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a6cfe38fdd495adcfdad8dc3dc736f371">ThreadLocalValue</a> () noexcept</td></tr>
<tr class="separator:a6cfe38fdd495adcfdad8dc3dc736f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f84ce8c97c0c3d76be387b0d9cd5feb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a5f84ce8c97c0c3d76be387b0d9cd5feb">~ThreadLocalValue</a> ()</td></tr>
<tr class="memdesc:a5f84ce8c97c0c3d76be387b0d9cd5feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a5f84ce8c97c0c3d76be387b0d9cd5feb">More...</a><br/></td></tr>
<tr class="separator:a5f84ce8c97c0c3d76be387b0d9cd5feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8681a3805c7023574a7c8e8905e7bbcb"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a8681a3805c7023574a7c8e8905e7bbcb">operator*</a> () const noexcept</td></tr>
<tr class="memdesc:a8681a3805c7023574a7c8e8905e7bbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to this thread's instance of the value.  <a href="#a8681a3805c7023574a7c8e8905e7bbcb">More...</a><br/></td></tr>
<tr class="separator:a8681a3805c7023574a7c8e8905e7bbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe0fe7fcfbd6511094512d01d3cdd16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#acbe0fe7fcfbd6511094512d01d3cdd16">operator Type *</a> () const noexcept</td></tr>
<tr class="memdesc:acbe0fe7fcfbd6511094512d01d3cdd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to this thread's instance of the value.  <a href="#acbe0fe7fcfbd6511094512d01d3cdd16">More...</a><br/></td></tr>
<tr class="separator:acbe0fe7fcfbd6511094512d01d3cdd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6112bf0cd51dcaa7cad94268984836a6"><td class="memItemLeft" align="right" valign="top">Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a6112bf0cd51dcaa7cad94268984836a6">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a6112bf0cd51dcaa7cad94268984836a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses a method or field of the value object.  <a href="#a6112bf0cd51dcaa7cad94268984836a6">More...</a><br/></td></tr>
<tr class="separator:a6112bf0cd51dcaa7cad94268984836a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa218704cf23c89a7a68b283f2d623e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aa218704cf23c89a7a68b283f2d623e57">operator=</a> (const Type &amp;newValue)</td></tr>
<tr class="memdesc:aa218704cf23c89a7a68b283f2d623e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a new value to the thread-local object.  <a href="#aa218704cf23c89a7a68b283f2d623e57">More...</a><br/></td></tr>
<tr class="separator:aa218704cf23c89a7a68b283f2d623e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0350ab3d9b5d1877dec3244d5b4e71e9"><td class="memItemLeft" align="right" valign="top">Type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0350ab3d9b5d1877dec3244d5b4e71e9">get</a> () const noexcept</td></tr>
<tr class="memdesc:a0350ab3d9b5d1877dec3244d5b4e71e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to this thread's instance of the value.  <a href="#a0350ab3d9b5d1877dec3244d5b4e71e9">More...</a><br/></td></tr>
<tr class="separator:a0350ab3d9b5d1877dec3244d5b4e71e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78af45671b2b057f0f584a75f79ff5b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a78af45671b2b057f0f584a75f79ff5b5">releaseCurrentThreadStorage</a> ()</td></tr>
<tr class="memdesc:a78af45671b2b057f0f584a75f79ff5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by a thread before it terminates, to allow this class to release any storage associated with the thread.  <a href="#a78af45671b2b057f0f584a75f79ff5b5">More...</a><br/></td></tr>
<tr class="separator:a78af45671b2b057f0f584a75f79ff5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a6cfe38fdd495adcfdad8dc3dc736f371"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&lt; Type &gt;::<a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f84ce8c97c0c3d76be387b0d9cd5feb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&lt; Type &gt;::~<a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>When this object is deleted, all the value objects for all threads will be deleted. </p>

<p>References <a class="el" href="group__juce__core-memory.html#ad39856229e8d4e3da9088d31bad55b9e">Atomic&lt; Type &gt;::get()</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a8681a3805c7023574a7c8e8905e7bbcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type&amp; <a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&lt; Type &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to this thread's instance of the value. </p>
<p>Note that the first time a thread tries to access the value, an instance of the value object will be created - so if your value's class has a non-trivial constructor, be aware that this method could invoke it. </p>

</div>
</div>
<a class="anchor" id="acbe0fe7fcfbd6511094512d01d3cdd16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&lt; Type &gt;::operator Type * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to this thread's instance of the value. </p>
<p>Note that the first time a thread tries to access the value, an instance of the value object will be created - so if your value's class has a non-trivial constructor, be aware that this method could invoke it. </p>

</div>
</div>
<a class="anchor" id="a6112bf0cd51dcaa7cad94268984836a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* <a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&lt; Type &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesses a method or field of the value object. </p>
<p>Note that the first time a thread tries to access the value, an instance of the value object will be created - so if your value's class has a non-trivial constructor, be aware that this method could invoke it. </p>

</div>
</div>
<a class="anchor" id="aa218704cf23c89a7a68b283f2d623e57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&amp; <a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a new value to the thread-local object. </p>

</div>
</div>
<a class="anchor" id="a0350ab3d9b5d1877dec3244d5b4e71e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type&amp; <a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&lt; Type &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to this thread's instance of the value. </p>
<p>Note that the first time a thread tries to access the value, an instance of the value object will be created - so if your value's class has a non-trivial constructor, be aware that this method could invoke it. </p>

<p>References <a class="el" href="group__juce__core-memory.html#a9c0966a21db3a9d4649f8c869bb38fa0">Atomic&lt; Type &gt;::compareAndSetBool()</a>, <a class="el" href="group__juce__core-memory.html#ad39856229e8d4e3da9088d31bad55b9e">Atomic&lt; Type &gt;::get()</a>, and <a class="el" href="group__juce__core-threads.html#abd4762b20144186ffc28280cedd224e9">Thread::getCurrentThreadId()</a>.</p>

</div>
</div>
<a class="anchor" id="a78af45671b2b057f0f584a75f79ff5b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-threads.html#classThreadLocalValue">ThreadLocalValue</a>&lt; Type &gt;::releaseCurrentThreadStorage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by a thread before it terminates, to allow this class to release any storage associated with the thread. </p>

<p>References <a class="el" href="group__juce__core-memory.html#ad39856229e8d4e3da9088d31bad55b9e">Atomic&lt; Type &gt;::get()</a>, and <a class="el" href="group__juce__core-threads.html#abd4762b20144186ffc28280cedd224e9">Thread::getCurrentThreadId()</a>.</p>

</div>
</div>

</div>
</div>
<a name="classThreadPoolJob" id="classThreadPoolJob"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ThreadPoolJob</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A task that is executed by a <a class="el" href="group__juce__core-threads.html#classThreadPool" title="A set of threads that will run a list of jobs. ">ThreadPool</a> object. </p>
<p>A <a class="el" href="group__juce__core-threads.html#classThreadPool" title="A set of threads that will run a list of jobs. ">ThreadPool</a> keeps a list of <a class="el" href="group__juce__core-threads.html#classThreadPoolJob" title="A task that is executed by a ThreadPool object. ">ThreadPoolJob</a> objects which are executed by its threads.</p>
<p>The <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method needs to be implemented to do the task, and if the code that does the work takes a significant time to run, it must keep checking the <a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea" title="Returns true if something is trying to interrupt this job and make it stop. ">shouldExit()</a> method to see if something is trying to interrupt the job. If <a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea" title="Returns true if something is trying to interrupt this job and make it stop. ">shouldExit()</a> returns true, the <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method must return immediately.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classThreadPool" title="A set of threads that will run a list of jobs. ">ThreadPool</a>, <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a534c077f3c60168d88555ade062420b3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3">JobStatus</a> { <a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3a390a063ef5f8b769a682f1daefc64e72">jobHasFinished</a> = 0, 
<a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3a42789d58048631dd96008ce23911a545">jobNeedsRunningAgain</a>
 }</td></tr>
<tr class="memdesc:a534c077f3c60168d88555ade062420b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">These are the values that can be returned by the <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method.  <a href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3">More...</a><br/></td></tr>
<tr class="separator:a534c077f3c60168d88555ade062420b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a701138425809122d1271561fcfa1c20d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a701138425809122d1271561fcfa1c20d">ThreadPoolJob</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;name)</td></tr>
<tr class="memdesc:a701138425809122d1271561fcfa1c20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread pool job object.  <a href="#a701138425809122d1271561fcfa1c20d">More...</a><br/></td></tr>
<tr class="separator:a701138425809122d1271561fcfa1c20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519d648535cefc3aed07455dd5dd9e5b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a519d648535cefc3aed07455dd5dd9e5b">~ThreadPoolJob</a> ()</td></tr>
<tr class="memdesc:a519d648535cefc3aed07455dd5dd9e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a519d648535cefc3aed07455dd5dd9e5b">More...</a><br/></td></tr>
<tr class="separator:a519d648535cefc3aed07455dd5dd9e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab786cc3b8eeb4de3ec3ab30e67280155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-text.html#classString">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab786cc3b8eeb4de3ec3ab30e67280155">getJobName</a> () const </td></tr>
<tr class="memdesc:ab786cc3b8eeb4de3ec3ab30e67280155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this job.  <a href="#ab786cc3b8eeb4de3ec3ab30e67280155">More...</a><br/></td></tr>
<tr class="separator:ab786cc3b8eeb4de3ec3ab30e67280155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0005910260394539b8117a858f5b4cfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0005910260394539b8117a858f5b4cfb">setJobName</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;newName)</td></tr>
<tr class="memdesc:a0005910260394539b8117a858f5b4cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the job's name.  <a href="#a0005910260394539b8117a858f5b4cfb">More...</a><br/></td></tr>
<tr class="separator:a0005910260394539b8117a858f5b4cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec49c01680e563257c79088dc87bc0d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3">JobStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9">runJob</a> ()=0</td></tr>
<tr class="memdesc:aec49c01680e563257c79088dc87bc0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peforms the actual work that this job needs to do.  <a href="#aec49c01680e563257c79088dc87bc0d9">More...</a><br/></td></tr>
<tr class="separator:aec49c01680e563257c79088dc87bc0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807c21e00f00548037cd10d4bab64347"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a807c21e00f00548037cd10d4bab64347">isRunning</a> () const noexcept</td></tr>
<tr class="memdesc:a807c21e00f00548037cd10d4bab64347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this job is currently running its <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method.  <a href="#a807c21e00f00548037cd10d4bab64347">More...</a><br/></td></tr>
<tr class="separator:a807c21e00f00548037cd10d4bab64347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441a94cba7ec96242fd7268371d9c5ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea">shouldExit</a> () const noexcept</td></tr>
<tr class="memdesc:a441a94cba7ec96242fd7268371d9c5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if something is trying to interrupt this job and make it stop.  <a href="#a441a94cba7ec96242fd7268371d9c5ea">More...</a><br/></td></tr>
<tr class="separator:a441a94cba7ec96242fd7268371d9c5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf58a7de172ae74d6ebb4a9fb59ed4d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#acf58a7de172ae74d6ebb4a9fb59ed4d3">signalJobShouldExit</a> ()</td></tr>
<tr class="memdesc:acf58a7de172ae74d6ebb4a9fb59ed4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calling this will cause the <a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea" title="Returns true if something is trying to interrupt this job and make it stop. ">shouldExit()</a> method to return true, and the job should (if it's been implemented correctly) stop as soon as possible.  <a href="#acf58a7de172ae74d6ebb4a9fb59ed4d3">More...</a><br/></td></tr>
<tr class="separator:acf58a7de172ae74d6ebb4a9fb59ed4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:ac9524c73da9de5444dd13d5936e238ee"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac9524c73da9de5444dd13d5936e238ee">getCurrentThreadPoolJob</a> ()</td></tr>
<tr class="memdesc:ac9524c73da9de5444dd13d5936e238ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the calling thread is being invoked inside a <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method, this will return the <a class="el" href="group__juce__core-threads.html#classThreadPoolJob" title="A task that is executed by a ThreadPool object. ">ThreadPoolJob</a> that it belongs to.  <a href="#ac9524c73da9de5444dd13d5936e238ee">More...</a><br/></td></tr>
<tr class="separator:ac9524c73da9de5444dd13d5936e238ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Enumeration Documentation</h4>
<a class="anchor" id="a534c077f3c60168d88555ade062420b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3">ThreadPoolJob::JobStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These are the values that can be returned by the <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a534c077f3c60168d88555ade062420b3a390a063ef5f8b769a682f1daefc64e72"></a>jobHasFinished</em>&#160;</td><td class="fielddoc">
<p>indicates that the job has finished and can be removed from the pool. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a534c077f3c60168d88555ade062420b3a42789d58048631dd96008ce23911a545"></a>jobNeedsRunningAgain</em>&#160;</td><td class="fielddoc">
<p>indicates that the job would like to be called again when a thread is free. </p>
</td></tr>
</table>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a701138425809122d1271561fcfa1c20d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ThreadPoolJob::ThreadPoolJob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a thread pool job object. </p>
<p>After creating your job, add it to a thread pool with <a class="el" href="group__juce__core-threads.html#ad46e866e912868092fff107dc555443b" title="Adds a job to the queue. ">ThreadPool::addJob()</a>. </p>

</div>
</div>
<a class="anchor" id="a519d648535cefc3aed07455dd5dd9e5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ThreadPoolJob::~ThreadPoolJob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="ab786cc3b8eeb4de3ec3ab30e67280155"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-text.html#classString">String</a> ThreadPoolJob::getJobName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of this job. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a0005910260394539b8117a858f5b4cfb" title="Changes the job&#39;s name. ">setJobName</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0005910260394539b8117a858f5b4cfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPoolJob::setJobName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>newName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the job's name. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#ab786cc3b8eeb4de3ec3ab30e67280155" title="Returns the name of this job. ">getJobName</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aec49c01680e563257c79088dc87bc0d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3">JobStatus</a> ThreadPoolJob::runJob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peforms the actual work that this job needs to do. </p>
<p>Your subclass must implement this method, in which is does its work.</p>
<p>If the code in this method takes a significant time to run, it must repeatedly check the <a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea" title="Returns true if something is trying to interrupt this job and make it stop. ">shouldExit()</a> method to see if something is trying to interrupt the job. If <a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea" title="Returns true if something is trying to interrupt this job and make it stop. ">shouldExit()</a> ever returns true, the <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method must return immediately.</p>
<p>If this method returns jobHasFinished, then the job will be removed from the pool immediately. If it returns jobNeedsRunningAgain, then the job will be left in the pool and will get a chance to run again as soon as a thread is free.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea" title="Returns true if something is trying to interrupt this job and make it stop. ">shouldExit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a807c21e00f00548037cd10d4bab64347"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPoolJob::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this job is currently running its <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method. </p>

</div>
</div>
<a class="anchor" id="a441a94cba7ec96242fd7268371d9c5ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPoolJob::shouldExit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if something is trying to interrupt this job and make it stop. </p>
<p>Your <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method must call this whenever it gets a chance, and if it ever returns true, the <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method must return immediately.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#acf58a7de172ae74d6ebb4a9fb59ed4d3" title="Calling this will cause the shouldExit() method to return true, and the job should (if it&#39;s been impl...">signalJobShouldExit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acf58a7de172ae74d6ebb4a9fb59ed4d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPoolJob::signalJobShouldExit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calling this will cause the <a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea" title="Returns true if something is trying to interrupt this job and make it stop. ">shouldExit()</a> method to return true, and the job should (if it's been implemented correctly) stop as soon as possible. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a441a94cba7ec96242fd7268371d9c5ea" title="Returns true if something is trying to interrupt this job and make it stop. ">shouldExit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac9524c73da9de5444dd13d5936e238ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a>* ThreadPoolJob::getCurrentThreadPoolJob </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the calling thread is being invoked inside a <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">runJob()</a> method, this will return the <a class="el" href="group__juce__core-threads.html#classThreadPoolJob" title="A task that is executed by a ThreadPool object. ">ThreadPoolJob</a> that it belongs to. </p>

</div>
</div>

</div>
</div>
<a name="classThreadPool" id="classThreadPool"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ThreadPool</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A set of threads that will run a list of jobs. </p>
<p>When a <a class="el" href="group__juce__core-threads.html#classThreadPoolJob" title="A task that is executed by a ThreadPool object. ">ThreadPoolJob</a> object is added to the <a class="el" href="group__juce__core-threads.html#classThreadPool" title="A set of threads that will run a list of jobs. ">ThreadPool</a>'s list, its runJob() method will be called by the next pooled thread that becomes free.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classThreadPoolJob" title="A task that is executed by a ThreadPool object. ">ThreadPoolJob</a>, <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ae55fe4a480fa7144d8e87bbd0a917b14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae55fe4a480fa7144d8e87bbd0a917b14">ThreadPool</a> (int numberOfThreads, size_t threadStackSize=0)</td></tr>
<tr class="memdesc:ae55fe4a480fa7144d8e87bbd0a917b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread pool.  <a href="#ae55fe4a480fa7144d8e87bbd0a917b14">More...</a><br/></td></tr>
<tr class="separator:ae55fe4a480fa7144d8e87bbd0a917b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3225e86aa7835545b3f6c2c8d363d5e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a3225e86aa7835545b3f6c2c8d363d5e5">ThreadPool</a> ()</td></tr>
<tr class="memdesc:a3225e86aa7835545b3f6c2c8d363d5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread pool with one thread per CPU core.  <a href="#a3225e86aa7835545b3f6c2c8d363d5e5">More...</a><br/></td></tr>
<tr class="separator:a3225e86aa7835545b3f6c2c8d363d5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d3d2ab618970605e684efc216655eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a44d3d2ab618970605e684efc216655eb">~ThreadPool</a> ()</td></tr>
<tr class="memdesc:a44d3d2ab618970605e684efc216655eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a44d3d2ab618970605e684efc216655eb">More...</a><br/></td></tr>
<tr class="separator:a44d3d2ab618970605e684efc216655eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46e866e912868092fff107dc555443b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ad46e866e912868092fff107dc555443b">addJob</a> (<a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *job, bool deleteJobWhenFinished)</td></tr>
<tr class="memdesc:ad46e866e912868092fff107dc555443b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a job to the queue.  <a href="#ad46e866e912868092fff107dc555443b">More...</a><br/></td></tr>
<tr class="separator:ad46e866e912868092fff107dc555443b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67017032e17cc020cfb22ca1fdee73ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a67017032e17cc020cfb22ca1fdee73ba">addJob</a> (<a class="el" href="group__juce__core-misc.html#classstd_1_1function">std::function</a>&lt; <a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3">ThreadPoolJob::JobStatus</a>()&gt; job)</td></tr>
<tr class="memdesc:a67017032e17cc020cfb22ca1fdee73ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a lambda function to be called as a job.  <a href="#a67017032e17cc020cfb22ca1fdee73ba">More...</a><br/></td></tr>
<tr class="separator:a67017032e17cc020cfb22ca1fdee73ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451c2a4d40a477e234ff314b350650d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a451c2a4d40a477e234ff314b350650d8">addJob</a> (<a class="el" href="group__juce__core-misc.html#classstd_1_1function">std::function</a>&lt; void()&gt; job)</td></tr>
<tr class="memdesc:a451c2a4d40a477e234ff314b350650d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a lambda function to be called as a job.  <a href="#a451c2a4d40a477e234ff314b350650d8">More...</a><br/></td></tr>
<tr class="separator:a451c2a4d40a477e234ff314b350650d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10da7494ab922d7157a5929d0689bf54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a10da7494ab922d7157a5929d0689bf54">removeJob</a> (<a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *job, bool interruptIfRunning, int timeOutMilliseconds)</td></tr>
<tr class="memdesc:a10da7494ab922d7157a5929d0689bf54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to remove a job from the pool.  <a href="#a10da7494ab922d7157a5929d0689bf54">More...</a><br/></td></tr>
<tr class="separator:a10da7494ab922d7157a5929d0689bf54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621253ea8de07a09a6c18238f8d33ced"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a621253ea8de07a09a6c18238f8d33ced">removeAllJobs</a> (bool interruptRunningJobs, int timeOutMilliseconds, <a class="el" href="classThreadPool_1_1JobSelector.html">JobSelector</a> *selectedJobsToRemove=nullptr)</td></tr>
<tr class="memdesc:a621253ea8de07a09a6c18238f8d33ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to remove all jobs from the pool.  <a href="#a621253ea8de07a09a6c18238f8d33ced">More...</a><br/></td></tr>
<tr class="separator:a621253ea8de07a09a6c18238f8d33ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9ba7e536f1978a255a36bc54f641ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9e9ba7e536f1978a255a36bc54f641ed">getNumJobs</a> () const </td></tr>
<tr class="memdesc:a9e9ba7e536f1978a255a36bc54f641ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of jobs currently running or queued.  <a href="#a9e9ba7e536f1978a255a36bc54f641ed">More...</a><br/></td></tr>
<tr class="separator:a9e9ba7e536f1978a255a36bc54f641ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c683ee9fb983a07ef5937ea2a3a6599"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0c683ee9fb983a07ef5937ea2a3a6599">getNumThreads</a> () const </td></tr>
<tr class="memdesc:a0c683ee9fb983a07ef5937ea2a3a6599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads assigned to this thread pool.  <a href="#a0c683ee9fb983a07ef5937ea2a3a6599">More...</a><br/></td></tr>
<tr class="separator:a0c683ee9fb983a07ef5937ea2a3a6599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52987dfd5d41443a914c4c20045c12c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aa52987dfd5d41443a914c4c20045c12c">getJob</a> (int <a class="el" href="group__juce__audio__processors-format__types.html#gab57c9d4e7c6d9726b6ea1da3521e4792">index</a>) const </td></tr>
<tr class="memdesc:aa52987dfd5d41443a914c4c20045c12c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the jobs in the queue.  <a href="#aa52987dfd5d41443a914c4c20045c12c">More...</a><br/></td></tr>
<tr class="separator:aa52987dfd5d41443a914c4c20045c12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ec36868d7215a33a5658f8ca8797c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a86ec36868d7215a33a5658f8ca8797c8">contains</a> (const <a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *job) const </td></tr>
<tr class="memdesc:a86ec36868d7215a33a5658f8ca8797c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given job is currently queued or running.  <a href="#a86ec36868d7215a33a5658f8ca8797c8">More...</a><br/></td></tr>
<tr class="separator:a86ec36868d7215a33a5658f8ca8797c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa5595e971322109a2eeef2f1bdda2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a6aa5595e971322109a2eeef2f1bdda2b">isJobRunning</a> (const <a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *job) const </td></tr>
<tr class="memdesc:a6aa5595e971322109a2eeef2f1bdda2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given job is currently being run by a thread.  <a href="#a6aa5595e971322109a2eeef2f1bdda2b">More...</a><br/></td></tr>
<tr class="separator:a6aa5595e971322109a2eeef2f1bdda2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada78c3d08d41bb195006b5c96a6514f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ada78c3d08d41bb195006b5c96a6514f5">waitForJobToFinish</a> (const <a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *job, int timeOutMilliseconds) const </td></tr>
<tr class="memdesc:ada78c3d08d41bb195006b5c96a6514f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a job has finished running and has been removed from the pool.  <a href="#ada78c3d08d41bb195006b5c96a6514f5">More...</a><br/></td></tr>
<tr class="separator:ada78c3d08d41bb195006b5c96a6514f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520f25cf327b0f000f2edff89b07aff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-text.html#classStringArray">StringArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a520f25cf327b0f000f2edff89b07aff2">getNamesOfAllJobs</a> (bool onlyReturnActiveJobs) const </td></tr>
<tr class="memdesc:a520f25cf327b0f000f2edff89b07aff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of the names of all the jobs currently running or queued.  <a href="#a520f25cf327b0f000f2edff89b07aff2">More...</a><br/></td></tr>
<tr class="separator:a520f25cf327b0f000f2edff89b07aff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f69128c07cb778cf6ab981b1b9be650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a3f69128c07cb778cf6ab981b1b9be650">setThreadPriorities</a> (int newPriority)</td></tr>
<tr class="memdesc:a3f69128c07cb778cf6ab981b1b9be650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the priority of all the threads.  <a href="#a3f69128c07cb778cf6ab981b1b9be650">More...</a><br/></td></tr>
<tr class="separator:a3f69128c07cb778cf6ab981b1b9be650"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ae55fe4a480fa7144d8e87bbd0a917b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOfThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>threadStackSize</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a thread pool. </p>
<p>Once you've created a pool, you can give it some jobs by calling <a class="el" href="group__juce__core-threads.html#ad46e866e912868092fff107dc555443b" title="Adds a job to the queue. ">addJob()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numberOfThreads</td><td>the number of threads to run. These will be started immediately, and will run until the pool is deleted. </td></tr>
    <tr><td class="paramname">threadStackSize</td><td>the size of the stack of each thread. If this value is zero then the default stack size of the OS will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3225e86aa7835545b3f6c2c8d363d5e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a thread pool with one thread per CPU core. </p>
<p>Once you've created a pool, you can give it some jobs by calling <a class="el" href="group__juce__core-threads.html#ad46e866e912868092fff107dc555443b" title="Adds a job to the queue. ">addJob()</a>. If you want to specify the number of threads, use the other constructor; this one creates a pool which has one thread for each CPU core. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-system.html#a2fa9257a60a26848174b2b8bd6cbb970" title="Returns the number of logical CPU cores. ">SystemStats::getNumCpus()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a44d3d2ab618970605e684efc216655eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ThreadPool::~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This will attempt to remove all the jobs before deleting, but if you want to specify a timeout, you should call <a class="el" href="group__juce__core-threads.html#a621253ea8de07a09a6c18238f8d33ced" title="Tries to remove all jobs from the pool. ">removeAllJobs()</a> explicitly before deleting the pool. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="ad46e866e912868092fff107dc555443b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::addJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteJobWhenFinished</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a job to the queue. </p>
<p>Once a job has been added, then the next time a thread is free, it will run the job's <a class="el" href="group__juce__core-threads.html#aec49c01680e563257c79088dc87bc0d9" title="Peforms the actual work that this job needs to do. ">ThreadPoolJob::runJob()</a> method. Depending on the return value of the runJob() method, the pool will either remove the job from the pool or add it to the back of the queue to be run again.</p>
<p>If deleteJobWhenFinished is true, then the job object will be owned and deleted by the pool when not needed - if you do this, make sure that your object's destructor is thread-safe.</p>
<p>If deleteJobWhenFinished is false, the pointer will be used but not deleted, and the caller is responsible for making sure the object is not deleted before it has been removed from the pool. </p>

</div>
</div>
<a class="anchor" id="a67017032e17cc020cfb22ca1fdee73ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::addJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-misc.html#classstd_1_1function">std::function</a>&lt; <a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3">ThreadPoolJob::JobStatus</a>()&gt;&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a lambda function to be called as a job. </p>
<p>This will create an internal <a class="el" href="group__juce__core-threads.html#classThreadPoolJob" title="A task that is executed by a ThreadPool object. ">ThreadPoolJob</a> object to encapsulate and call the lambda. </p>

</div>
</div>
<a class="anchor" id="a451c2a4d40a477e234ff314b350650d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ThreadPool::addJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-misc.html#classstd_1_1function">std::function</a>&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a lambda function to be called as a job. </p>
<p>This will create an internal <a class="el" href="group__juce__core-threads.html#classThreadPoolJob" title="A task that is executed by a ThreadPool object. ">ThreadPoolJob</a> object to encapsulate and call the lambda. </p>

</div>
</div>
<a class="anchor" id="a10da7494ab922d7157a5929d0689bf54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPool::removeJob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interruptIfRunning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMilliseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to remove a job from the pool. </p>
<p>If the job isn't yet running, this will simply remove it. If it is running, it will wait for it to finish.</p>
<p>If the timeout period expires before the job finishes running, then the job will be left in the pool and this will return false. It returns true if the job is successfully stopped and removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">job</td><td>the job to remove </td></tr>
    <tr><td class="paramname">interruptIfRunning</td><td>if true, then if the job is currently busy, its <a class="el" href="group__juce__core-threads.html#acf58a7de172ae74d6ebb4a9fb59ed4d3" title="Calling this will cause the shouldExit() method to return true, and the job should (if it&#39;s been impl...">ThreadPoolJob::signalJobShouldExit()</a> method will be called to try to interrupt it. If false, then if the job will be allowed to run until it stops normally (or the timeout expires) </td></tr>
    <tr><td class="paramname">timeOutMilliseconds</td><td>the length of time this method should wait for the job to finish before giving up and returning false </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a621253ea8de07a09a6c18238f8d33ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPool::removeAllJobs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interruptRunningJobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMilliseconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classThreadPool_1_1JobSelector.html">JobSelector</a> *&#160;</td>
          <td class="paramname"><em>selectedJobsToRemove</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to remove all jobs from the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptRunningJobs</td><td>if true, then all running jobs will have their <a class="el" href="group__juce__core-threads.html#acf58a7de172ae74d6ebb4a9fb59ed4d3" title="Calling this will cause the shouldExit() method to return true, and the job should (if it&#39;s been impl...">ThreadPoolJob::signalJobShouldExit()</a> methods called to try to interrupt them </td></tr>
    <tr><td class="paramname">timeOutMilliseconds</td><td>the length of time this method should wait for all the jobs to finish before giving up and returning false </td></tr>
    <tr><td class="paramname">selectedJobsToRemove</td><td>if this is not a nullptr, the <a class="el" href="classThreadPool_1_1JobSelector.html" title="A callback class used when you need to select which ThreadPoolJob objects are suitable for some kind ...">JobSelector</a> object is asked to decide which jobs should be removed. If it is a nullptr, all jobs are removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all jobs are successfully stopped and removed; false if the timeout period expires while waiting for one or more jobs to stop </dd></dl>

</div>
</div>
<a class="anchor" id="a9e9ba7e536f1978a255a36bc54f641ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ThreadPool::getNumJobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of jobs currently running or queued. </p>

</div>
</div>
<a class="anchor" id="a0c683ee9fb983a07ef5937ea2a3a6599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ThreadPool::getNumThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of threads assigned to this thread pool. </p>

</div>
</div>
<a class="anchor" id="aa52987dfd5d41443a914c4c20045c12c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a>* ThreadPool::getJob </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one of the jobs in the queue. </p>
<p>Note that this can be a very volatile list as jobs might be continuously getting shifted around in the list, and this method may return nullptr if the index is currently out-of-range. </p>

</div>
</div>
<a class="anchor" id="a86ec36868d7215a33a5658f8ca8797c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPool::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given job is currently queued or running. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a6aa5595e971322109a2eeef2f1bdda2b" title="Returns true if the given job is currently being run by a thread. ">isJobRunning()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6aa5595e971322109a2eeef2f1bdda2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPool::isJobRunning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *&#160;</td>
          <td class="paramname"><em>job</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given job is currently being run by a thread. </p>

</div>
</div>
<a class="anchor" id="ada78c3d08d41bb195006b5c96a6514f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPool::waitForJobToFinish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-threads.html#classThreadPoolJob">ThreadPoolJob</a> *&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMilliseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a job has finished running and has been removed from the pool. </p>
<p>This will wait until the job is no longer in the pool - i.e. until its runJob() method returns <a class="el" href="group__juce__core-threads.html#a534c077f3c60168d88555ade062420b3a390a063ef5f8b769a682f1daefc64e72" title="indicates that the job has finished and can be removed from the pool. ">ThreadPoolJob::jobHasFinished</a>.</p>
<p>If the timeout period expires before the job finishes, this will return false; it returns true if the job has finished successfully. </p>

</div>
</div>
<a class="anchor" id="a520f25cf327b0f000f2edff89b07aff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-text.html#classStringArray">StringArray</a> ThreadPool::getNamesOfAllJobs </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyReturnActiveJobs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of the names of all the jobs currently running or queued. </p>
<p>If onlyReturnActiveJobs is true, only the ones currently running are returned. </p>

</div>
</div>
<a class="anchor" id="a3f69128c07cb778cf6ab981b1b9be650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ThreadPool::setThreadPriorities </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the priority of all the threads. </p>
<p>This will call <a class="el" href="group__juce__core-threads.html#a0975d9ee9f403f5f82287fcce4a7168f" title="Changes the thread&#39;s priority. ">Thread::setPriority()</a> for each thread in the pool. May return false if for some reason the priority can't be changed. </p>

</div>
</div>

</div>
</div>
<a name="classTimeSliceClient" id="classTimeSliceClient"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class TimeSliceClient</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Used by the <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a> class. </p>
<p>To register your class with a <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a>, derive from this class and use the <a class="el" href="group__juce__core-threads.html#a32774664744aed47f22d255889fd50f2" title="Adds a client to the list. ">TimeSliceThread::addTimeSliceClient()</a> method to add it to the list.</p>
<p>Make sure you always call <a class="el" href="group__juce__core-threads.html#a63268fd875e85e7bf705fd608e2988cf" title="Removes a client from the list. ">TimeSliceThread::removeTimeSliceClient()</a> before deleting your client!</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for TimeSliceClient:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTimeSliceClient__inherit__graph.svg" width="507" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ab97fd6407f33b2004534066c0b959e61"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab97fd6407f33b2004534066c0b959e61">~TimeSliceClient</a> ()</td></tr>
<tr class="memdesc:ab97fd6407f33b2004534066c0b959e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ab97fd6407f33b2004534066c0b959e61">More...</a><br/></td></tr>
<tr class="separator:ab97fd6407f33b2004534066c0b959e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272b0868c9bd0b5c281cf09dbaa69a9c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a272b0868c9bd0b5c281cf09dbaa69a9c">useTimeSlice</a> ()=0</td></tr>
<tr class="memdesc:a272b0868c9bd0b5c281cf09dbaa69a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called back by a <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a>.  <a href="#a272b0868c9bd0b5c281cf09dbaa69a9c">More...</a><br/></td></tr>
<tr class="separator:a272b0868c9bd0b5c281cf09dbaa69a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ab97fd6407f33b2004534066c0b959e61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TimeSliceClient::~TimeSliceClient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a272b0868c9bd0b5c281cf09dbaa69a9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int TimeSliceClient::useTimeSlice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called back by a <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a>. </p>
<p>When you register this class with it, a <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a> will repeatedly call this method.</p>
<p>The implementation of this method should use its time-slice to do something that's quick - never block for longer than absolutely necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>Your method should return the number of milliseconds which it would like to wait before being called again. Returning 0 will make the thread call again as soon as possible (after possibly servicing other busy clients). If you return a value below zero, your client will be removed from the list of clients, and won't be called again. The value you specify isn't a guaranteee, and is only used as a hint by the thread - the actual time before the next callback may be more or less than specified. You can force the <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a> to wake up and poll again immediately by calling its notify() method. </dd></dl>

</div>
</div>

</div>
</div>
<a name="classTimeSliceThread" id="classTimeSliceThread"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class TimeSliceThread</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run some sort of short task. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classTimeSliceClient" title="Used by the TimeSliceThread class. ">TimeSliceClient</a>, <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for TimeSliceThread:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTimeSliceThread__inherit__graph.svg" width="131" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ad2fa29d3076a7c0b600e297cc18fc9d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ad2fa29d3076a7c0b600e297cc18fc9d9">TimeSliceThread</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;threadName)</td></tr>
<tr class="memdesc:ad2fa29d3076a7c0b600e297cc18fc9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a>.  <a href="#ad2fa29d3076a7c0b600e297cc18fc9d9">More...</a><br/></td></tr>
<tr class="separator:ad2fa29d3076a7c0b600e297cc18fc9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4374e45b3ffabac2abd5ebc04594b8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aa4374e45b3ffabac2abd5ebc04594b8d">~TimeSliceThread</a> ()</td></tr>
<tr class="memdesc:aa4374e45b3ffabac2abd5ebc04594b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aa4374e45b3ffabac2abd5ebc04594b8d">More...</a><br/></td></tr>
<tr class="separator:aa4374e45b3ffabac2abd5ebc04594b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32774664744aed47f22d255889fd50f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a32774664744aed47f22d255889fd50f2">addTimeSliceClient</a> (<a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a> *clientToAdd, int millisecondsBeforeStarting=0)</td></tr>
<tr class="memdesc:a32774664744aed47f22d255889fd50f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a client to the list.  <a href="#a32774664744aed47f22d255889fd50f2">More...</a><br/></td></tr>
<tr class="separator:a32774664744aed47f22d255889fd50f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690e5733cc918dcad9d9e4d98f2326f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a690e5733cc918dcad9d9e4d98f2326f5">moveToFrontOfQueue</a> (<a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a> *clientToMove)</td></tr>
<tr class="memdesc:a690e5733cc918dcad9d9e4d98f2326f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given client is waiting in the queue, it will be moved to the front and given a time-slice as soon as possible.  <a href="#a690e5733cc918dcad9d9e4d98f2326f5">More...</a><br/></td></tr>
<tr class="separator:a690e5733cc918dcad9d9e4d98f2326f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63268fd875e85e7bf705fd608e2988cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a63268fd875e85e7bf705fd608e2988cf">removeTimeSliceClient</a> (<a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a> *clientToRemove)</td></tr>
<tr class="memdesc:a63268fd875e85e7bf705fd608e2988cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a client from the list.  <a href="#a63268fd875e85e7bf705fd608e2988cf">More...</a><br/></td></tr>
<tr class="separator:a63268fd875e85e7bf705fd608e2988cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8c1f22111376a440e79498127701a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a6a8c1f22111376a440e79498127701a0">removeAllClients</a> ()</td></tr>
<tr class="memdesc:a6a8c1f22111376a440e79498127701a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all the active and pending clients from the list.  <a href="#a6a8c1f22111376a440e79498127701a0">More...</a><br/></td></tr>
<tr class="separator:a6a8c1f22111376a440e79498127701a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b440ac33a366ddc6ee8507a840d2eb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a2b440ac33a366ddc6ee8507a840d2eb2">getNumClients</a> () const </td></tr>
<tr class="memdesc:a2b440ac33a366ddc6ee8507a840d2eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of registered clients.  <a href="#a2b440ac33a366ddc6ee8507a840d2eb2">More...</a><br/></td></tr>
<tr class="separator:a2b440ac33a366ddc6ee8507a840d2eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0a576b2e96543282f342a5b9b470e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a13a0a576b2e96543282f342a5b9b470e">getClient</a> (int <a class="el" href="group__juce__audio__processors-format__types.html#gab57c9d4e7c6d9726b6ea1da3521e4792">index</a>) const </td></tr>
<tr class="memdesc:a13a0a576b2e96543282f342a5b9b470e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the registered clients.  <a href="#a13a0a576b2e96543282f342a5b9b470e">More...</a><br/></td></tr>
<tr class="separator:a13a0a576b2e96543282f342a5b9b470e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_group__juce__core-threads"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_group__juce__core-threads')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="group__juce__core-threads.html#classThread">Thread</a></td></tr>
<tr class="memitem:a9105c0abed75dd620b80c8c5e8b01603 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9105c0abed75dd620b80c8c5e8b01603">Thread</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;threadName, size_t threadStackSize=0)</td></tr>
<tr class="memdesc:a9105c0abed75dd620b80c8c5e8b01603 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a thread.  <a href="#a9105c0abed75dd620b80c8c5e8b01603">More...</a><br/></td></tr>
<tr class="separator:a9105c0abed75dd620b80c8c5e8b01603 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026b23628e1727050e864e00489c0baf inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a026b23628e1727050e864e00489c0baf">~Thread</a> ()</td></tr>
<tr class="memdesc:a026b23628e1727050e864e00489c0baf inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a026b23628e1727050e864e00489c0baf">More...</a><br/></td></tr>
<tr class="separator:a026b23628e1727050e864e00489c0baf inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae90dfabab3e1776cf01a26e7ee3a620 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aae90dfabab3e1776cf01a26e7ee3a620">run</a> ()=0</td></tr>
<tr class="memdesc:aae90dfabab3e1776cf01a26e7ee3a620 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be implemented to perform the thread's actual code.  <a href="#aae90dfabab3e1776cf01a26e7ee3a620">More...</a><br/></td></tr>
<tr class="separator:aae90dfabab3e1776cf01a26e7ee3a620 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5502205d727c00752f95af27a063d983 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983">startThread</a> ()</td></tr>
<tr class="memdesc:a5502205d727c00752f95af27a063d983 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the thread running.  <a href="#a5502205d727c00752f95af27a063d983">More...</a><br/></td></tr>
<tr class="separator:a5502205d727c00752f95af27a063d983 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4aff2ceb97b0f16a0a08132315a900 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#acc4aff2ceb97b0f16a0a08132315a900">startThread</a> (int priority)</td></tr>
<tr class="memdesc:acc4aff2ceb97b0f16a0a08132315a900 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the thread with a given priority.  <a href="#acc4aff2ceb97b0f16a0a08132315a900">More...</a><br/></td></tr>
<tr class="separator:acc4aff2ceb97b0f16a0a08132315a900 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18583d51411d6a34c59b63f0adff4697 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a18583d51411d6a34c59b63f0adff4697">stopThread</a> (int timeOutMilliseconds)</td></tr>
<tr class="memdesc:a18583d51411d6a34c59b63f0adff4697 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to stop the thread running.  <a href="#a18583d51411d6a34c59b63f0adff4697">More...</a><br/></td></tr>
<tr class="separator:a18583d51411d6a34c59b63f0adff4697 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02ad2d11a2dacfea4a78b06224a3e87 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ab02ad2d11a2dacfea4a78b06224a3e87">isThreadRunning</a> () const </td></tr>
<tr class="memdesc:ab02ad2d11a2dacfea4a78b06224a3e87 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the thread is currently active.  <a href="#ab02ad2d11a2dacfea4a78b06224a3e87">More...</a><br/></td></tr>
<tr class="separator:ab02ad2d11a2dacfea4a78b06224a3e87 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe168e27c6ee50b0d10522810772268 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#affe168e27c6ee50b0d10522810772268">signalThreadShouldExit</a> ()</td></tr>
<tr class="memdesc:affe168e27c6ee50b0d10522810772268 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag to tell the thread it should stop.  <a href="#affe168e27c6ee50b0d10522810772268">More...</a><br/></td></tr>
<tr class="separator:affe168e27c6ee50b0d10522810772268 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8fdce313d3c0db6c5adbb78c4352b4 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0a8fdce313d3c0db6c5adbb78c4352b4">threadShouldExit</a> () const </td></tr>
<tr class="memdesc:a0a8fdce313d3c0db6c5adbb78c4352b4 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the thread has been told to stop running.  <a href="#a0a8fdce313d3c0db6c5adbb78c4352b4">More...</a><br/></td></tr>
<tr class="separator:a0a8fdce313d3c0db6c5adbb78c4352b4 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277e5e91d52626bbdac85b44972dd46a inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a277e5e91d52626bbdac85b44972dd46a">waitForThreadToExit</a> (int timeOutMilliseconds) const </td></tr>
<tr class="memdesc:a277e5e91d52626bbdac85b44972dd46a inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the thread to stop.  <a href="#a277e5e91d52626bbdac85b44972dd46a">More...</a><br/></td></tr>
<tr class="separator:a277e5e91d52626bbdac85b44972dd46a inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0975d9ee9f403f5f82287fcce4a7168f inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0975d9ee9f403f5f82287fcce4a7168f">setPriority</a> (int priority)</td></tr>
<tr class="memdesc:a0975d9ee9f403f5f82287fcce4a7168f inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the thread's priority.  <a href="#a0975d9ee9f403f5f82287fcce4a7168f">More...</a><br/></td></tr>
<tr class="separator:a0975d9ee9f403f5f82287fcce4a7168f inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614605563fceeac6f03d507bc35bdce4 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a614605563fceeac6f03d507bc35bdce4">setAffinityMask</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> affinityMask)</td></tr>
<tr class="memdesc:a614605563fceeac6f03d507bc35bdce4 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the affinity mask for the thread.  <a href="#a614605563fceeac6f03d507bc35bdce4">More...</a><br/></td></tr>
<tr class="separator:a614605563fceeac6f03d507bc35bdce4 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17aca9c9609310f830298d6a0206d18d inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a17aca9c9609310f830298d6a0206d18d">wait</a> (int timeOutMilliseconds) const </td></tr>
<tr class="memdesc:a17aca9c9609310f830298d6a0206d18d inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the thread wait for a notification.  <a href="#a17aca9c9609310f830298d6a0206d18d">More...</a><br/></td></tr>
<tr class="separator:a17aca9c9609310f830298d6a0206d18d inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e6408f187557bb06c8fff07c4100b7 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ae0e6408f187557bb06c8fff07c4100b7">notify</a> () const </td></tr>
<tr class="memdesc:ae0e6408f187557bb06c8fff07c4100b7 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up the thread.  <a href="#ae0e6408f187557bb06c8fff07c4100b7">More...</a><br/></td></tr>
<tr class="separator:ae0e6408f187557bb06c8fff07c4100b7 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ca822734b9b20ab32eeba774c9a803 inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">ThreadID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a39ca822734b9b20ab32eeba774c9a803">getThreadId</a> () const noexcept</td></tr>
<tr class="memdesc:a39ca822734b9b20ab32eeba774c9a803 inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this thread.  <a href="#a39ca822734b9b20ab32eeba774c9a803">More...</a><br/></td></tr>
<tr class="separator:a39ca822734b9b20ab32eeba774c9a803 inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ae21de0884d0814efe13de1ff475be inherit pub_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a04ae21de0884d0814efe13de1ff475be">getThreadName</a> () const noexcept</td></tr>
<tr class="memdesc:a04ae21de0884d0814efe13de1ff475be inherit pub_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the thread.  <a href="#a04ae21de0884d0814efe13de1ff475be">More...</a><br/></td></tr>
<tr class="separator:a04ae21de0884d0814efe13de1ff475be inherit pub_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_group__juce__core-threads"><td colspan="2" onclick="javascript:toggleInherit('pub_types_group__juce__core-threads')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="group__juce__core-threads.html#classThread">Thread</a></td></tr>
<tr class="memitem:a57e37e78ad201531166b450b64c428b6 inherit pub_types_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__juce__core-threads.html#a57e37e78ad201531166b450b64c428b6a0ee7fcab9f979f4e867c718460ce5503">realtimeAudioPriority</a> = -1
 }</td></tr>
<tr class="memdesc:a57e37e78ad201531166b450b64c428b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special realtime audio thread priority.  <a href="group__juce__core-threads.html#a57e37e78ad201531166b450b64c428b6">More...</a><br/></td></tr>
<tr class="separator:a57e37e78ad201531166b450b64c428b6 inherit pub_types_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077e20855a3c974c2fc6f9e7caa8412c inherit pub_types_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">ThreadID</a></td></tr>
<tr class="memdesc:a077e20855a3c974c2fc6f9e7caa8412c inherit pub_types_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value type used for thread IDs.  <a href="#a077e20855a3c974c2fc6f9e7caa8412c">More...</a><br/></td></tr>
<tr class="separator:a077e20855a3c974c2fc6f9e7caa8412c inherit pub_types_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_group__juce__core-threads"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_group__juce__core-threads')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="group__juce__core-threads.html#classThread">Thread</a></td></tr>
<tr class="memitem:a0a1c520e431e3e5101ce2da8606baf26 inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a0a1c520e431e3e5101ce2da8606baf26">launch</a> (<a class="el" href="group__juce__core-misc.html#classstd_1_1function">std::function</a>&lt; void()&gt; functionToRun)</td></tr>
<tr class="memdesc:a0a1c520e431e3e5101ce2da8606baf26 inherit pub_static_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a lambda or function on its own thread.  <a href="#a0a1c520e431e3e5101ce2da8606baf26">More...</a><br/></td></tr>
<tr class="separator:a0a1c520e431e3e5101ce2da8606baf26 inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92778089556fd0b5ab9c31557669ce8 inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac92778089556fd0b5ab9c31557669ce8">currentThreadShouldExit</a> ()</td></tr>
<tr class="memdesc:ac92778089556fd0b5ab9c31557669ce8 inherit pub_static_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the current thread has been told to stop running.  <a href="#ac92778089556fd0b5ab9c31557669ce8">More...</a><br/></td></tr>
<tr class="separator:ac92778089556fd0b5ab9c31557669ce8 inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a777202bb5aa9ce7f57605674b100f4 inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9a777202bb5aa9ce7f57605674b100f4">setCurrentThreadPriority</a> (int priority)</td></tr>
<tr class="memdesc:a9a777202bb5aa9ce7f57605674b100f4 inherit pub_static_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the priority of the caller thread.  <a href="#a9a777202bb5aa9ce7f57605674b100f4">More...</a><br/></td></tr>
<tr class="separator:a9a777202bb5aa9ce7f57605674b100f4 inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21eb5ae8c32bc2ecacba904f3411802 inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#ac21eb5ae8c32bc2ecacba904f3411802">setCurrentThreadAffinityMask</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> affinityMask)</td></tr>
<tr class="memdesc:ac21eb5ae8c32bc2ecacba904f3411802 inherit pub_static_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the affinity mask for the caller thread.  <a href="#ac21eb5ae8c32bc2ecacba904f3411802">More...</a><br/></td></tr>
<tr class="separator:ac21eb5ae8c32bc2ecacba904f3411802 inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee1ddee32aa82ac90bc567cb7427926 inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a4ee1ddee32aa82ac90bc567cb7427926">sleep</a> (int milliseconds)</td></tr>
<tr class="separator:a4ee1ddee32aa82ac90bc567cb7427926 inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf47a344b3b715e49ffcbc6119c72cdc inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aaf47a344b3b715e49ffcbc6119c72cdc">yield</a> ()</td></tr>
<tr class="memdesc:aaf47a344b3b715e49ffcbc6119c72cdc inherit pub_static_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the calling thread's current time-slot.  <a href="#aaf47a344b3b715e49ffcbc6119c72cdc">More...</a><br/></td></tr>
<tr class="separator:aaf47a344b3b715e49ffcbc6119c72cdc inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4762b20144186ffc28280cedd224e9 inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-threads.html#a077e20855a3c974c2fc6f9e7caa8412c">ThreadID</a> <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#abd4762b20144186ffc28280cedd224e9">getCurrentThreadId</a> ()</td></tr>
<tr class="memdesc:abd4762b20144186ffc28280cedd224e9 inherit pub_static_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an id that identifies the caller thread.  <a href="#abd4762b20144186ffc28280cedd224e9">More...</a><br/></td></tr>
<tr class="separator:abd4762b20144186ffc28280cedd224e9 inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9f45ea3ff9a7d39a50f78059640cd inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-threads.html#classThread">Thread</a> *<a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a40a9f45ea3ff9a7d39a50f78059640cd">getCurrentThread</a> ()</td></tr>
<tr class="memdesc:a40a9f45ea3ff9a7d39a50f78059640cd inherit pub_static_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the thread object that is currently running.  <a href="#a40a9f45ea3ff9a7d39a50f78059640cd">More...</a><br/></td></tr>
<tr class="separator:a40a9f45ea3ff9a7d39a50f78059640cd inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba2a683ea8111c08db83092360b7226 inherit pub_static_methods_group__juce__core-threads"><td class="memItemLeft" align="right" valign="top">static void <a class="el" href="group__juce__core-system.html#gaf0b3f78ca801d88a7912f4c6bbf50e58">JUCE_CALLTYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a8ba2a683ea8111c08db83092360b7226">setCurrentThreadName</a> (const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;newThreadName)</td></tr>
<tr class="memdesc:a8ba2a683ea8111c08db83092360b7226 inherit pub_static_methods_group__juce__core-threads"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name of the caller thread.  <a href="#a8ba2a683ea8111c08db83092360b7226">More...</a><br/></td></tr>
<tr class="separator:a8ba2a683ea8111c08db83092360b7226 inherit pub_static_methods_group__juce__core-threads"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ad2fa29d3076a7c0b600e297cc18fc9d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TimeSliceThread::TimeSliceThread </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-text.html#classString">String</a> &amp;&#160;</td>
          <td class="paramname"><em>threadName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classTimeSliceThread" title="A thread that keeps a list of clients, and calls each one in turn, giving them all a chance to run so...">TimeSliceThread</a>. </p>
<p>When first created, the thread is not running. Use the <a class="el" href="group__juce__core-threads.html#a5502205d727c00752f95af27a063d983" title="Starts the thread running. ">startThread()</a> method to start it. </p>

</div>
</div>
<a class="anchor" id="aa4374e45b3ffabac2abd5ebc04594b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimeSliceThread::~TimeSliceThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Deleting a <a class="el" href="group__juce__core-threads.html#classThread" title="Encapsulates a thread. ">Thread</a> object that is running will only give the thread a brief opportunity to stop itself cleanly, so it's recommended that you should always call <a class="el" href="group__juce__core-threads.html#a18583d51411d6a34c59b63f0adff4697" title="Attempts to stop the thread running. ">stopThread()</a> with a decent timeout before deleting, to avoid the thread being forcibly killed (which is a Bad Thing). </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a32774664744aed47f22d255889fd50f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeSliceThread::addTimeSliceClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a> *&#160;</td>
          <td class="paramname"><em>clientToAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>millisecondsBeforeStarting</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a client to the list. </p>
<p>The client's callbacks will start after the number of milliseconds specified by millisecondsBeforeStarting (and this may happen before this method has returned). </p>

</div>
</div>
<a class="anchor" id="a690e5733cc918dcad9d9e4d98f2326f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeSliceThread::moveToFrontOfQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a> *&#160;</td>
          <td class="paramname"><em>clientToMove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the given client is waiting in the queue, it will be moved to the front and given a time-slice as soon as possible. </p>
<p>If the specified client has not been added, nothing will happen. </p>

</div>
</div>
<a class="anchor" id="a63268fd875e85e7bf705fd608e2988cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeSliceThread::removeTimeSliceClient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a> *&#160;</td>
          <td class="paramname"><em>clientToRemove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a client from the list. </p>
<p>This method will make sure that all callbacks to the client have completely finished before the method returns. </p>

</div>
</div>
<a class="anchor" id="a6a8c1f22111376a440e79498127701a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeSliceThread::removeAllClients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all the active and pending clients from the list. </p>
<p>This method will make sure that all callbacks to clients have finished before the method returns. </p>

</div>
</div>
<a class="anchor" id="a2b440ac33a366ddc6ee8507a840d2eb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TimeSliceThread::getNumClients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of registered clients. </p>

</div>
</div>
<a class="anchor" id="a13a0a576b2e96543282f342a5b9b470e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-threads.html#classTimeSliceClient">TimeSliceClient</a>* TimeSliceThread::getClient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns one of the registered clients. </p>

</div>
</div>

</div>
</div>
<a name="classWaitableEvent" id="classWaitableEvent"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class WaitableEvent</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Allows threads to wait for events triggered by other threads. </p>
<p>A thread can call <a class="el" href="group__juce__core-threads.html#aade120bc7686f4fabfc740aff8f56dfa" title="Suspends the calling thread until the event has been signalled. ">wait()</a> on a WaitableObject, and this will suspend the calling thread until another thread wakes it up by calling the <a class="el" href="group__juce__core-threads.html#a9afdf2e8cb15c457a44e85af3bffbf72" title="Wakes up any threads that are currently waiting on this object. ">signal()</a> method. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:aa3622062e48a177ec721120443ea17d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aa3622062e48a177ec721120443ea17d2">WaitableEvent</a> (bool manualReset=false) noexcept</td></tr>
<tr class="memdesc:aa3622062e48a177ec721120443ea17d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-threads.html#classWaitableEvent" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> object.  <a href="#aa3622062e48a177ec721120443ea17d2">More...</a><br/></td></tr>
<tr class="separator:aa3622062e48a177ec721120443ea17d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af071eb054ec0ce9b69eb98bd9508c2cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#af071eb054ec0ce9b69eb98bd9508c2cf">~WaitableEvent</a> () noexcept</td></tr>
<tr class="memdesc:af071eb054ec0ce9b69eb98bd9508c2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af071eb054ec0ce9b69eb98bd9508c2cf">More...</a><br/></td></tr>
<tr class="separator:af071eb054ec0ce9b69eb98bd9508c2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade120bc7686f4fabfc740aff8f56dfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aade120bc7686f4fabfc740aff8f56dfa">wait</a> (int timeOutMilliseconds=-1) const noexcept</td></tr>
<tr class="memdesc:aade120bc7686f4fabfc740aff8f56dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends the calling thread until the event has been signalled.  <a href="#aade120bc7686f4fabfc740aff8f56dfa">More...</a><br/></td></tr>
<tr class="separator:aade120bc7686f4fabfc740aff8f56dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afdf2e8cb15c457a44e85af3bffbf72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#a9afdf2e8cb15c457a44e85af3bffbf72">signal</a> () const noexcept</td></tr>
<tr class="memdesc:a9afdf2e8cb15c457a44e85af3bffbf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakes up any threads that are currently waiting on this object.  <a href="#a9afdf2e8cb15c457a44e85af3bffbf72">More...</a><br/></td></tr>
<tr class="separator:a9afdf2e8cb15c457a44e85af3bffbf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b3db111ba17e13d5e74360367bcc9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-threads.html#aa9b3db111ba17e13d5e74360367bcc9b">reset</a> () const noexcept</td></tr>
<tr class="memdesc:aa9b3db111ba17e13d5e74360367bcc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the event to an unsignalled state.  <a href="#aa9b3db111ba17e13d5e74360367bcc9b">More...</a><br/></td></tr>
<tr class="separator:aa9b3db111ba17e13d5e74360367bcc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="aa3622062e48a177ec721120443ea17d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WaitableEvent::WaitableEvent </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>manualReset</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-threads.html#classWaitableEvent" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> object. </p>
<p>The object is initially in an unsignalled state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manualReset</td><td>If this is false, the event will be reset automatically when the <a class="el" href="group__juce__core-threads.html#aade120bc7686f4fabfc740aff8f56dfa" title="Suspends the calling thread until the event has been signalled. ">wait()</a> method is called. If manualReset is true, then once the event is signalled, the only way to reset it will be by calling the <a class="el" href="group__juce__core-threads.html#aa9b3db111ba17e13d5e74360367bcc9b" title="Resets the event to an unsignalled state. ">reset()</a> method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af071eb054ec0ce9b69eb98bd9508c2cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">WaitableEvent::~WaitableEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If other threads are waiting on this object when it gets deleted, this can cause nasty errors, so be careful! </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="aade120bc7686f4fabfc740aff8f56dfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool WaitableEvent::wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMilliseconds</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspends the calling thread until the event has been signalled. </p>
<p>This will wait until the object's <a class="el" href="group__juce__core-threads.html#a9afdf2e8cb15c457a44e85af3bffbf72" title="Wakes up any threads that are currently waiting on this object. ">signal()</a> method is called by another thread, or until the timeout expires.</p>
<p>After the event has been signalled, this method will return true and if manualReset was set to false in the <a class="el" href="group__juce__core-threads.html#classWaitableEvent" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a>'s constructor, then the event will be reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeOutMilliseconds</td><td>the maximum time to wait, in milliseconds. A negative value will cause it to wait forever.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object has been signalled, false if the timeout expires first. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a9afdf2e8cb15c457a44e85af3bffbf72" title="Wakes up any threads that are currently waiting on this object. ">signal</a>, <a class="el" href="group__juce__core-threads.html#aa9b3db111ba17e13d5e74360367bcc9b" title="Resets the event to an unsignalled state. ">reset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9afdf2e8cb15c457a44e85af3bffbf72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaitableEvent::signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wakes up any threads that are currently waiting on this object. </p>
<p>If <a class="el" href="group__juce__core-threads.html#a9afdf2e8cb15c457a44e85af3bffbf72" title="Wakes up any threads that are currently waiting on this object. ">signal()</a> is called when nothing is waiting, the next thread to call <a class="el" href="group__juce__core-threads.html#aade120bc7686f4fabfc740aff8f56dfa" title="Suspends the calling thread until the event has been signalled. ">wait()</a> will return immediately and reset the signal.</p>
<p>If the <a class="el" href="group__juce__core-threads.html#classWaitableEvent" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> is manual reset, all current and future threads that wait upon this object will be woken, until <a class="el" href="group__juce__core-threads.html#aa9b3db111ba17e13d5e74360367bcc9b" title="Resets the event to an unsignalled state. ">reset()</a> is explicitly called.</p>
<p>If the <a class="el" href="group__juce__core-threads.html#classWaitableEvent" title="Allows threads to wait for events triggered by other threads. ">WaitableEvent</a> is automatic reset, and one or more threads is waiting upon the object, then one of them will be woken up. If no threads are currently waiting, then the next thread to call <a class="el" href="group__juce__core-threads.html#aade120bc7686f4fabfc740aff8f56dfa" title="Suspends the calling thread until the event has been signalled. ">wait()</a> will be woken up. As soon as a thread is woken, the signal is automatically reset.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#aade120bc7686f4fabfc740aff8f56dfa" title="Suspends the calling thread until the event has been signalled. ">wait</a>, <a class="el" href="group__juce__core-threads.html#aa9b3db111ba17e13d5e74360367bcc9b" title="Resets the event to an unsignalled state. ">reset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa9b3db111ba17e13d5e74360367bcc9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WaitableEvent::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the event to an unsignalled state. </p>
<p>If it's not already signalled, this does nothing. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gacedaa6fb1373c96d2d15e7a617a5cec8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-threads.html#a586568fcce3a9c6a0f1547518fd6ddb6">CriticalSection::ScopedLockType</a> <a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8">ScopedLock</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically locks and unlocks a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object. </p>
<p>You can use a ScopedLock as a local variable to provide RAII-based locking of a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>.</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyObject</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> objectLock;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// assuming that this example function will be called by multiple threads</span></div>
<div class="line">    <span class="keywordtype">void</span> foo()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classGenericScopedLock">ScopedLock</a> myScopedLock (objectLock);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// objectLock is now locked..</span></div>
<div class="line"></div>
<div class="line">        ...do some thread-safe work here...</div>
<div class="line"></div>
<div class="line">        <span class="comment">// ..and objectLock gets unlocked here, as myScopedLock goes out of</span></div>
<div class="line">        <span class="comment">// scope at the end of the block</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, <a class="el" href="group__juce__core-threads.html#ga4cc435f24ace2a8f59b488ed66d9cf2c" title="Automatically unlocks and re-locks a CriticalSection object. ">ScopedUnlock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4cc435f24ace2a8f59b488ed66d9cf2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-threads.html#a69d6b613f2638fbae341cfd06df478c7">CriticalSection::ScopedUnlockType</a> <a class="el" href="group__juce__core-threads.html#ga4cc435f24ace2a8f59b488ed66d9cf2c">ScopedUnlock</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically unlocks and re-locks a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object. </p>
<p>This is the reverse of a ScopedLock object - instead of locking the critical section for the lifetime of this object, it unlocks it.</p>
<p>Make sure you don't try to unlock critical sections that aren't actually locked!</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyObject</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> objectLock;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> foo()</div>
<div class="line">    {</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classGenericScopedLock">ScopedLock</a> myScopedLock (objectLock);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// objectLock is now locked..</span></div>
<div class="line"></div>
<div class="line">            {</div>
<div class="line">                <a class="code" href="group__juce__core-threads.html#classGenericScopedUnlock">ScopedUnlock</a> myUnlocker (objectLock);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// ..and now unlocked..</span></div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// ..and now locked again..</span></div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// ..and finally unlocked.</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>, <a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8" title="Automatically locks and unlocks a CriticalSection object. ">ScopedLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d3ed387d4c09d8fbfb8ad1f2db610df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-threads.html#a745e5e36d8c6a33ea1fcbbfa2fff00a3">CriticalSection::ScopedTryLockType</a> <a class="el" href="group__juce__core-threads.html#ga5d3ed387d4c09d8fbfb8ad1f2db610df">ScopedTryLock</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Automatically tries to lock and unlock a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a> object. </p>
<p>Use one of these as a local variable to control access to a <a class="el" href="group__juce__core-threads.html#classCriticalSection" title="A re-entrant mutex. ">CriticalSection</a>.</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyObject</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__juce__core-threads.html#classCriticalSection">CriticalSection</a> objectLock;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> foo()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group__juce__core-threads.html#classGenericScopedTryLock">ScopedTryLock</a> myScopedTryLock (objectLock);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Unlike using a ScopedLock, this may fail to actually get the lock, so you</span></div>
<div class="line">        <span class="comment">// must call the isLocked() method before making any assumptions..</span></div>
<div class="line">        <span class="keywordflow">if</span> (myScopedTryLock.isLocked())</div>
<div class="line">        {</div>
<div class="line">           ...safely <span class="keywordflow">do</span> some work...</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// If we get here, then our attempt at locking failed because another thread had already locked it..</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-threads.html#a2c12101da7ebf8455de49652f377d313" title="Attempts to lock this critical section without blocking. ">CriticalSection::tryEnter</a>, <a class="el" href="group__juce__core-threads.html#gacedaa6fb1373c96d2d15e7a617a5cec8" title="Automatically locks and unlocks a CriticalSection object. ">ScopedLock</a>, <a class="el" href="group__juce__core-threads.html#ga4cc435f24ace2a8f59b488ed66d9cf2c" title="Automatically unlocks and re-locks a CriticalSection object. ">ScopedUnlock</a>, <a class="el" href="group__juce__core-threads.html#classScopedReadLock" title="Automatically locks and unlocks a ReadWriteLock object. ">ScopedReadLock</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 20 2017 01:00:41 for JUCE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
