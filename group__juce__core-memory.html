<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>JUCE: memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">JUCE
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">memory<div class="ingroups"><a class="el" href="group__juce__core.html">juce_core</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:classAtomic"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic&lt; Type &gt;</a></td></tr>
<tr class="memdesc:classAtomic"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class to hold a primitive value and perform atomic operations on it.  <a href="group__juce__core-memory.html#classAtomic">More...</a><br/></td></tr>
<tr class="separator:classAtomic"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classByteOrder"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classByteOrder">ByteOrder</a></td></tr>
<tr class="memdesc:classByteOrder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains static methods for converting the byte order between different endiannesses.  <a href="group__juce__core-memory.html#classByteOrder">More...</a><br/></td></tr>
<tr class="separator:classByteOrder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structContainerDeletePolicy"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#structContainerDeletePolicy">ContainerDeletePolicy&lt; ObjectType &gt;</a></td></tr>
<tr class="memdesc:structContainerDeletePolicy"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by container classes as an indirect way to delete an object of a particular type.  <a href="group__juce__core-memory.html#structContainerDeletePolicy">More...</a><br/></td></tr>
<tr class="separator:structContainerDeletePolicy"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classHeapBlock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock&lt; ElementType, throwOnFailure &gt;</a></td></tr>
<tr class="memdesc:classHeapBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very simple container class to hold a pointer to some data on the heap.  <a href="group__juce__core-memory.html#classHeapBlock">More...</a><br/></td></tr>
<tr class="separator:classHeapBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classLeakedObjectDetector"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector&lt; OwnerClass &gt;</a></td></tr>
<tr class="memdesc:classLeakedObjectDetector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Embedding an instance of this class inside another class can be used as a low-overhead way of detecting leaked instances.  <a href="group__juce__core-memory.html#classLeakedObjectDetector">More...</a><br/></td></tr>
<tr class="separator:classLeakedObjectDetector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classScopedAutoReleasePool"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classScopedAutoReleasePool">ScopedAutoReleasePool</a></td></tr>
<tr class="memdesc:classScopedAutoReleasePool"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy C++ wrapper that creates and deletes an NSAutoreleasePool object using RAII.  <a href="group__juce__core-memory.html#classScopedAutoReleasePool">More...</a><br/></td></tr>
<tr class="separator:classScopedAutoReleasePool"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classMemoryBlock"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a></td></tr>
<tr class="memdesc:classMemoryBlock"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to hold a resizable block of raw data.  <a href="group__juce__core-memory.html#classMemoryBlock">More...</a><br/></td></tr>
<tr class="separator:classMemoryBlock"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classOptionalScopedPointer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer&lt; ObjectType &gt;</a></td></tr>
<tr class="memdesc:classOptionalScopedPointer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope.  <a href="group__juce__core-memory.html#classOptionalScopedPointer">More...</a><br/></td></tr>
<tr class="separator:classOptionalScopedPointer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classReferenceCountedObject"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObject">ReferenceCountedObject</a></td></tr>
<tr class="memdesc:classReferenceCountedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class which provides methods for reference-counting.  <a href="group__juce__core-memory.html#classReferenceCountedObject">More...</a><br/></td></tr>
<tr class="separator:classReferenceCountedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classSingleThreadedReferenceCountedObject"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classSingleThreadedReferenceCountedObject">SingleThreadedReferenceCountedObject</a></td></tr>
<tr class="memdesc:classSingleThreadedReferenceCountedObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds reference-counting to an object.  <a href="group__juce__core-memory.html#classSingleThreadedReferenceCountedObject">More...</a><br/></td></tr>
<tr class="separator:classSingleThreadedReferenceCountedObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classReferenceCountedObjectPtr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr&lt; ReferenceCountedObjectClass &gt;</a></td></tr>
<tr class="memdesc:classReferenceCountedObjectPtr"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart-pointer class which points to a reference-counted object.  <a href="group__juce__core-memory.html#classReferenceCountedObjectPtr">More...</a><br/></td></tr>
<tr class="separator:classReferenceCountedObjectPtr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classScopedPointer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer&lt; ObjectType &gt;</a></td></tr>
<tr class="memdesc:classScopedPointer"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a pointer which is automatically deleted when this object goes out of scope.  <a href="group__juce__core-memory.html#classScopedPointer">More...</a><br/></td></tr>
<tr class="separator:classScopedPointer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classSharedResourcePointer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer&lt; SharedObjectType &gt;</a></td></tr>
<tr class="memdesc:classSharedResourcePointer"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart-pointer that automatically creates and manages the lifetime of a shared static instance of a class.  <a href="group__juce__core-memory.html#classSharedResourcePointer">More...</a><br/></td></tr>
<tr class="separator:classSharedResourcePointer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classWeakReference"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference&lt; ObjectType, ReferenceCountingType &gt;</a></td></tr>
<tr class="memdesc:classWeakReference"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as a pointer which will automatically become null if the object to which it points is deleted.  <a href="group__juce__core-memory.html#classWeakReference">More...</a><br/></td></tr>
<tr class="separator:classWeakReference"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab3639a79598b35f2116f4572af0d93f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gab3639a79598b35f2116f4572af0d93f1">JUCE_LEAK_DETECTOR</a>(OwnerClass)</td></tr>
<tr class="memdesc:gab3639a79598b35f2116f4572af0d93f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro lets you embed a leak-detecting object inside a class.  <a href="#gab3639a79598b35f2116f4572af0d93f1">More...</a><br/></td></tr>
<tr class="separator:gab3639a79598b35f2116f4572af0d93f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73fadcd76040b11a626d5bdf833ad49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gad73fadcd76040b11a626d5bdf833ad49">JUCE_AUTORELEASEPOOL</a>&#160;&#160;&#160;@autoreleasepool</td></tr>
<tr class="memdesc:gad73fadcd76040b11a626d5bdf833ad49"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro that can be used to easily declare a local <a class="el" href="group__juce__core-memory.html#classScopedAutoReleasePool" title="A handy C++ wrapper that creates and deletes an NSAutoreleasePool object using RAII. ">ScopedAutoReleasePool</a> object for RAII-based obj-C autoreleasing.  <a href="#gad73fadcd76040b11a626d5bdf833ad49">More...</a><br/></td></tr>
<tr class="separator:gad73fadcd76040b11a626d5bdf833ad49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881926ad904a631336e5d4b15f05c548"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga881926ad904a631336e5d4b15f05c548">juce_UseDebuggingNewOperator</a></td></tr>
<tr class="memdesc:ga881926ad904a631336e5d4b15f05c548"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated) This was a Windows-specific way of checking for object leaks - now please use the JUCE_LEAK_DETECTOR instead.  <a href="#ga881926ad904a631336e5d4b15f05c548">More...</a><br/></td></tr>
<tr class="separator:ga881926ad904a631336e5d4b15f05c548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac46b66c5d38d6bd3a937af241d152a44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gac46b66c5d38d6bd3a937af241d152a44">juce_DeclareSingleton</a>(classname, doNotRecreateAfterDeletion)</td></tr>
<tr class="memdesc:gac46b66c5d38d6bd3a937af241d152a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to declare member variables and methods for a singleton class.  <a href="#gac46b66c5d38d6bd3a937af241d152a44">More...</a><br/></td></tr>
<tr class="separator:gac46b66c5d38d6bd3a937af241d152a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514301c5c269b87e3a3e3da3a6640f8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga514301c5c269b87e3a3e3da3a6640f8f">juce_ImplementSingleton</a>(classname)</td></tr>
<tr class="memdesc:ga514301c5c269b87e3a3e3da3a6640f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a counterpart to the juce_DeclareSingleton macro.  <a href="#ga514301c5c269b87e3a3e3da3a6640f8f">More...</a><br/></td></tr>
<tr class="separator:ga514301c5c269b87e3a3e3da3a6640f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253f51f3a9ac2b4795e2ce08b2a756d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga253f51f3a9ac2b4795e2ce08b2a756d9">juce_DeclareSingleton_SingleThreaded</a>(classname, doNotRecreateAfterDeletion)</td></tr>
<tr class="memdesc:ga253f51f3a9ac2b4795e2ce08b2a756d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to declare member variables and methods for a singleton class.  <a href="#ga253f51f3a9ac2b4795e2ce08b2a756d9">More...</a><br/></td></tr>
<tr class="separator:ga253f51f3a9ac2b4795e2ce08b2a756d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354e37d287b39d02097f4f74be14af51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga354e37d287b39d02097f4f74be14af51">juce_DeclareSingleton_SingleThreaded_Minimal</a>(classname)</td></tr>
<tr class="memdesc:ga354e37d287b39d02097f4f74be14af51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to declare member variables and methods for a singleton class.  <a href="#ga354e37d287b39d02097f4f74be14af51">More...</a><br/></td></tr>
<tr class="separator:ga354e37d287b39d02097f4f74be14af51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4404ed444ce628bab43d7fb68f7f1884"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga4404ed444ce628bab43d7fb68f7f1884">juce_ImplementSingleton_SingleThreaded</a>(classname)</td></tr>
<tr class="memdesc:ga4404ed444ce628bab43d7fb68f7f1884"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a counterpart to the juce_DeclareSingleton_SingleThreaded macro.  <a href="#ga4404ed444ce628bab43d7fb68f7f1884">More...</a><br/></td></tr>
<tr class="separator:ga4404ed444ce628bab43d7fb68f7f1884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga48fb9b158a3767e6573d27a8160956ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga48fb9b158a3767e6573d27a8160956ea">zeromem</a> (void *memory, size_t numBytes) noexcept</td></tr>
<tr class="memdesc:ga48fb9b158a3767e6573d27a8160956ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a block of memory with zeros.  <a href="#ga48fb9b158a3767e6573d27a8160956ea">More...</a><br/></td></tr>
<tr class="separator:ga48fb9b158a3767e6573d27a8160956ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f3dbe374ad9280ed9ba72f510d8e5b0"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga1f3dbe374ad9280ed9ba72f510d8e5b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga1f3dbe374ad9280ed9ba72f510d8e5b0">zerostruct</a> (Type &amp;structure) noexcept</td></tr>
<tr class="memdesc:ga1f3dbe374ad9280ed9ba72f510d8e5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites a structure or object with zeros.  <a href="#ga1f3dbe374ad9280ed9ba72f510d8e5b0">More...</a><br/></td></tr>
<tr class="separator:ga1f3dbe374ad9280ed9ba72f510d8e5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4163b928fab6bebea5691e97c72fc4fa"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga4163b928fab6bebea5691e97c72fc4fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga4163b928fab6bebea5691e97c72fc4fa">deleteAndZero</a> (Type &amp;pointer)</td></tr>
<tr class="memdesc:ga4163b928fab6bebea5691e97c72fc4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an object pointer, and sets the pointer to null.  <a href="#ga4163b928fab6bebea5691e97c72fc4fa">More...</a><br/></td></tr>
<tr class="separator:ga4163b928fab6bebea5691e97c72fc4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec283d962b8cbfef5e73f51129305913"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename IntegerType &gt; </td></tr>
<tr class="memitem:gaec283d962b8cbfef5e73f51129305913"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaec283d962b8cbfef5e73f51129305913">addBytesToPointer</a> (Type *basePointer, IntegerType bytes) noexcept</td></tr>
<tr class="memdesc:gaec283d962b8cbfef5e73f51129305913"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy function which adds a number of bytes to any type of pointer and returns the result.  <a href="#gaec283d962b8cbfef5e73f51129305913">More...</a><br/></td></tr>
<tr class="separator:gaec283d962b8cbfef5e73f51129305913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4503bc356769b69967532e23cb5595f1"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename IntegerType &gt; </td></tr>
<tr class="memitem:ga4503bc356769b69967532e23cb5595f1"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga4503bc356769b69967532e23cb5595f1">snapPointerToAlignment</a> (Type *basePointer, IntegerType alignmentBytes) noexcept</td></tr>
<tr class="memdesc:ga4503bc356769b69967532e23cb5595f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy function to round up a pointer to the nearest multiple of a given number of bytes.  <a href="#ga4503bc356769b69967532e23cb5595f1">More...</a><br/></td></tr>
<tr class="separator:ga4503bc356769b69967532e23cb5595f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga667897ead2d6fd7f9f682bd8f75da26a"><td class="memTemplParams" colspan="2">template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:ga667897ead2d6fd7f9f682bd8f75da26a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga667897ead2d6fd7f9f682bd8f75da26a">getAddressDifference</a> (Type1 *pointer1, Type2 *pointer2) noexcept</td></tr>
<tr class="memdesc:ga667897ead2d6fd7f9f682bd8f75da26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy function which returns the difference between any two pointers, in bytes.  <a href="#ga667897ead2d6fd7f9f682bd8f75da26a">More...</a><br/></td></tr>
<tr class="separator:ga667897ead2d6fd7f9f682bd8f75da26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab622db353f778dfccede23f101ec86bb"><td class="memTemplParams" colspan="2">template&lt;class Type &gt; </td></tr>
<tr class="memitem:gab622db353f778dfccede23f101ec86bb"><td class="memTemplItemLeft" align="right" valign="top">Type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gab622db353f778dfccede23f101ec86bb">createCopyIfNotNull</a> (const Type *objectToCopy)</td></tr>
<tr class="memdesc:gab622db353f778dfccede23f101ec86bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a pointer is non-null, this returns a new copy of the object that it points to, or safely returns nullptr if the pointer is null.  <a href="#gab622db353f778dfccede23f101ec86bb">More...</a><br/></td></tr>
<tr class="separator:gab622db353f778dfccede23f101ec86bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e1363d40774f5bb55f6324c4ab1414"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gad4e1363d40774f5bb55f6324c4ab1414"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gad4e1363d40774f5bb55f6324c4ab1414">readUnaligned</a> (const void *srcPtr) noexcept</td></tr>
<tr class="memdesc:gad4e1363d40774f5bb55f6324c4ab1414"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy function to read un-aligned memory without a performance penalty or bus-error.  <a href="#gad4e1363d40774f5bb55f6324c4ab1414">More...</a><br/></td></tr>
<tr class="separator:gad4e1363d40774f5bb55f6324c4ab1414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab39db7640be10d1fab314769f20d1ee5"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gab39db7640be10d1fab314769f20d1ee5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gab39db7640be10d1fab314769f20d1ee5">writeUnaligned</a> (void *dstPtr, Type <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gab39db7640be10d1fab314769f20d1ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy function to write un-aligned memory without a performance penalty or bus-error.  <a href="#gab39db7640be10d1fab314769f20d1ee5">More...</a><br/></td></tr>
<tr class="separator:gab39db7640be10d1fab314769f20d1ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe3092d0a699f09ea15287dd040181a"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceCountedObjectClass &gt; </td></tr>
<tr class="memitem:ga9fe3092d0a699f09ea15287dd040181a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga9fe3092d0a699f09ea15287dd040181a">operator==</a> (const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;object1, ReferenceCountedObjectClass *const object2) noexcept</td></tr>
<tr class="memdesc:ga9fe3092d0a699f09ea15287dd040181a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ReferenceCountedObjectPtrs.  <a href="#ga9fe3092d0a699f09ea15287dd040181a">More...</a><br/></td></tr>
<tr class="separator:ga9fe3092d0a699f09ea15287dd040181a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1955b9309ddae26fc9abb53ecbdbec0"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceCountedObjectClass &gt; </td></tr>
<tr class="memitem:gaa1955b9309ddae26fc9abb53ecbdbec0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaa1955b9309ddae26fc9abb53ecbdbec0">operator==</a> (const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;object1, const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;object2) noexcept</td></tr>
<tr class="memdesc:gaa1955b9309ddae26fc9abb53ecbdbec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ReferenceCountedObjectPtrs.  <a href="#gaa1955b9309ddae26fc9abb53ecbdbec0">More...</a><br/></td></tr>
<tr class="separator:gaa1955b9309ddae26fc9abb53ecbdbec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e78dbcfa8a842e773fb030c2f3d9781"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceCountedObjectClass &gt; </td></tr>
<tr class="memitem:ga5e78dbcfa8a842e773fb030c2f3d9781"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga5e78dbcfa8a842e773fb030c2f3d9781">operator==</a> (ReferenceCountedObjectClass *object1, const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;object2) noexcept</td></tr>
<tr class="memdesc:ga5e78dbcfa8a842e773fb030c2f3d9781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ReferenceCountedObjectPtrs.  <a href="#ga5e78dbcfa8a842e773fb030c2f3d9781">More...</a><br/></td></tr>
<tr class="separator:ga5e78dbcfa8a842e773fb030c2f3d9781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d9adee99bce84b370ccdbf0dda395b"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceCountedObjectClass &gt; </td></tr>
<tr class="memitem:ga98d9adee99bce84b370ccdbf0dda395b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga98d9adee99bce84b370ccdbf0dda395b">operator!=</a> (const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;object1, const ReferenceCountedObjectClass *object2) noexcept</td></tr>
<tr class="memdesc:ga98d9adee99bce84b370ccdbf0dda395b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ReferenceCountedObjectPtrs.  <a href="#ga98d9adee99bce84b370ccdbf0dda395b">More...</a><br/></td></tr>
<tr class="separator:ga98d9adee99bce84b370ccdbf0dda395b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ccf60dc1326abbf6445b7ca8ff9bb53"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceCountedObjectClass &gt; </td></tr>
<tr class="memitem:ga4ccf60dc1326abbf6445b7ca8ff9bb53"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga4ccf60dc1326abbf6445b7ca8ff9bb53">operator!=</a> (const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;object1, const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;object2) noexcept</td></tr>
<tr class="memdesc:ga4ccf60dc1326abbf6445b7ca8ff9bb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ReferenceCountedObjectPtrs.  <a href="#ga4ccf60dc1326abbf6445b7ca8ff9bb53">More...</a><br/></td></tr>
<tr class="separator:ga4ccf60dc1326abbf6445b7ca8ff9bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3def35798a4ee95b9863d175deaeadfc"><td class="memTemplParams" colspan="2">template&lt;typename ReferenceCountedObjectClass &gt; </td></tr>
<tr class="memitem:ga3def35798a4ee95b9863d175deaeadfc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga3def35798a4ee95b9863d175deaeadfc">operator!=</a> (ReferenceCountedObjectClass *object1, const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;object2) noexcept</td></tr>
<tr class="memdesc:ga3def35798a4ee95b9863d175deaeadfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ReferenceCountedObjectPtrs.  <a href="#ga3def35798a4ee95b9863d175deaeadfc">More...</a><br/></td></tr>
<tr class="separator:ga3def35798a4ee95b9863d175deaeadfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44c6f65eba15909069b2ae838cbd96d1"><td class="memTemplParams" colspan="2">template&lt;class ObjectType &gt; </td></tr>
<tr class="memitem:ga44c6f65eba15909069b2ae838cbd96d1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga44c6f65eba15909069b2ae838cbd96d1">operator==</a> (const <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;pointer1, ObjectType *const pointer2) noexcept</td></tr>
<tr class="memdesc:ga44c6f65eba15909069b2ae838cbd96d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> with another pointer.  <a href="#ga44c6f65eba15909069b2ae838cbd96d1">More...</a><br/></td></tr>
<tr class="separator:ga44c6f65eba15909069b2ae838cbd96d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ebf907fd87957ebdc43e49eb5cfccd"><td class="memTemplParams" colspan="2">template&lt;class ObjectType &gt; </td></tr>
<tr class="memitem:ga08ebf907fd87957ebdc43e49eb5cfccd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga08ebf907fd87957ebdc43e49eb5cfccd">operator!=</a> (const <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;pointer1, ObjectType *const pointer2) noexcept</td></tr>
<tr class="memdesc:ga08ebf907fd87957ebdc43e49eb5cfccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> with another pointer.  <a href="#ga08ebf907fd87957ebdc43e49eb5cfccd">More...</a><br/></td></tr>
<tr class="separator:ga08ebf907fd87957ebdc43e49eb5cfccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b033fd8e98d9c4dfbb57a88466d62f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gac2b033fd8e98d9c4dfbb57a88466d62f">ByteOrder::swap</a> (<a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gac2b033fd8e98d9c4dfbb57a88466d62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the upper and lower bytes of a 16-bit integer.  <a href="#gac2b033fd8e98d9c4dfbb57a88466d62f">More...</a><br/></td></tr>
<tr class="separator:gac2b033fd8e98d9c4dfbb57a88466d62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039a6658618d891f825cdec00929356a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga039a6658618d891f825cdec00929356a">ByteOrder::swap</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga039a6658618d891f825cdec00929356a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the 4 bytes in a 32-bit integer.  <a href="#ga039a6658618d891f825cdec00929356a">More...</a><br/></td></tr>
<tr class="separator:ga039a6658618d891f825cdec00929356a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa754df407abe7487660dd3f223c87324"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaa754df407abe7487660dd3f223c87324">ByteOrder::swap</a> (<a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gaa754df407abe7487660dd3f223c87324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the 8 bytes in a 64-bit integer.  <a href="#gaa754df407abe7487660dd3f223c87324">More...</a><br/></td></tr>
<tr class="separator:gaa754df407abe7487660dd3f223c87324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8461d39c7370a6adb9556d3235cbdbe1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga8461d39c7370a6adb9556d3235cbdbe1">ByteOrder::swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga8461d39c7370a6adb9556d3235cbdbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 16-bit unsigned int if the CPU is big-endian.  <a href="#ga8461d39c7370a6adb9556d3235cbdbe1">More...</a><br/></td></tr>
<tr class="separator:ga8461d39c7370a6adb9556d3235cbdbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433cad5a04c392b9c97658eb6de79aef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga433cad5a04c392b9c97658eb6de79aef">ByteOrder::swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga433cad5a04c392b9c97658eb6de79aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit unsigned int if the CPU is big-endian.  <a href="#ga433cad5a04c392b9c97658eb6de79aef">More...</a><br/></td></tr>
<tr class="separator:ga433cad5a04c392b9c97658eb6de79aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3568cb8775a1fa8f67bec0a889582ade"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga3568cb8775a1fa8f67bec0a889582ade">ByteOrder::swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga3568cb8775a1fa8f67bec0a889582ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit unsigned int if the CPU is big-endian.  <a href="#ga3568cb8775a1fa8f67bec0a889582ade">More...</a><br/></td></tr>
<tr class="separator:ga3568cb8775a1fa8f67bec0a889582ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878689f08a7a6ea436cd550c6538ee4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga878689f08a7a6ea436cd550c6538ee4a">ByteOrder::swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga878689f08a7a6ea436cd550c6538ee4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 16-bit signed int if the CPU is big-endian.  <a href="#ga878689f08a7a6ea436cd550c6538ee4a">More...</a><br/></td></tr>
<tr class="separator:ga878689f08a7a6ea436cd550c6538ee4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee1facdbe64e044d394093aad0042ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga2ee1facdbe64e044d394093aad0042ce">ByteOrder::swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga2ee1facdbe64e044d394093aad0042ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit signed int if the CPU is big-endian.  <a href="#ga2ee1facdbe64e044d394093aad0042ce">More...</a><br/></td></tr>
<tr class="separator:ga2ee1facdbe64e044d394093aad0042ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9869ab64491231b02a6cca33d6ff9f60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga9869ab64491231b02a6cca33d6ff9f60">ByteOrder::swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga9869ab64491231b02a6cca33d6ff9f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit signed int if the CPU is big-endian.  <a href="#ga9869ab64491231b02a6cca33d6ff9f60">More...</a><br/></td></tr>
<tr class="separator:ga9869ab64491231b02a6cca33d6ff9f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b284220a53da3852b131d98dd85fdbb"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga9b284220a53da3852b131d98dd85fdbb">ByteOrder::swapIfBigEndian</a> (float <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga9b284220a53da3852b131d98dd85fdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit float if the CPU is big-endian.  <a href="#ga9b284220a53da3852b131d98dd85fdbb">More...</a><br/></td></tr>
<tr class="separator:ga9b284220a53da3852b131d98dd85fdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92060f5baff564c7e346309473326b69"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga92060f5baff564c7e346309473326b69">ByteOrder::swapIfBigEndian</a> (double <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga92060f5baff564c7e346309473326b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit float if the CPU is big-endian.  <a href="#ga92060f5baff564c7e346309473326b69">More...</a><br/></td></tr>
<tr class="separator:ga92060f5baff564c7e346309473326b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374444379b6a0f2010e36fa985175b9d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga374444379b6a0f2010e36fa985175b9d">ByteOrder::swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga374444379b6a0f2010e36fa985175b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 16-bit unsigned int if the CPU is little-endian.  <a href="#ga374444379b6a0f2010e36fa985175b9d">More...</a><br/></td></tr>
<tr class="separator:ga374444379b6a0f2010e36fa985175b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6108916f94343a894fd7a146d48000"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga4a6108916f94343a894fd7a146d48000">ByteOrder::swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga4a6108916f94343a894fd7a146d48000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit unsigned int if the CPU is little-endian.  <a href="#ga4a6108916f94343a894fd7a146d48000">More...</a><br/></td></tr>
<tr class="separator:ga4a6108916f94343a894fd7a146d48000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ca5e947cb823fc208ede0635387695"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga08ca5e947cb823fc208ede0635387695">ByteOrder::swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga08ca5e947cb823fc208ede0635387695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit unsigned int if the CPU is little-endian.  <a href="#ga08ca5e947cb823fc208ede0635387695">More...</a><br/></td></tr>
<tr class="separator:ga08ca5e947cb823fc208ede0635387695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744b0ba49fa5cd0323fbd0cb663a64a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga744b0ba49fa5cd0323fbd0cb663a64a1">ByteOrder::swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga744b0ba49fa5cd0323fbd0cb663a64a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 16-bit signed int if the CPU is little-endian.  <a href="#ga744b0ba49fa5cd0323fbd0cb663a64a1">More...</a><br/></td></tr>
<tr class="separator:ga744b0ba49fa5cd0323fbd0cb663a64a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00631878bb112db9e31cb7987cd0114"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gae00631878bb112db9e31cb7987cd0114">ByteOrder::swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gae00631878bb112db9e31cb7987cd0114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit signed int if the CPU is little-endian.  <a href="#gae00631878bb112db9e31cb7987cd0114">More...</a><br/></td></tr>
<tr class="separator:gae00631878bb112db9e31cb7987cd0114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531090b4ee8e06c95c8c6d0536aadd64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga531090b4ee8e06c95c8c6d0536aadd64">ByteOrder::swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga531090b4ee8e06c95c8c6d0536aadd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit signed int if the CPU is little-endian.  <a href="#ga531090b4ee8e06c95c8c6d0536aadd64">More...</a><br/></td></tr>
<tr class="separator:ga531090b4ee8e06c95c8c6d0536aadd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde05ef314c29aeb9f49c1dbe13f6fb2"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gabde05ef314c29aeb9f49c1dbe13f6fb2">ByteOrder::swapIfLittleEndian</a> (float <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gabde05ef314c29aeb9f49c1dbe13f6fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit float if the CPU is little-endian.  <a href="#gabde05ef314c29aeb9f49c1dbe13f6fb2">More...</a><br/></td></tr>
<tr class="separator:gabde05ef314c29aeb9f49c1dbe13f6fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51aa557077c032ab3fec337e0b47b5f0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga51aa557077c032ab3fec337e0b47b5f0">ByteOrder::swapIfLittleEndian</a> (double <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga51aa557077c032ab3fec337e0b47b5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit float if the CPU is little-endian.  <a href="#ga51aa557077c032ab3fec337e0b47b5f0">More...</a><br/></td></tr>
<tr class="separator:ga51aa557077c032ab3fec337e0b47b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee16f591feb0902fddb472eb4057293"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga5ee16f591feb0902fddb472eb4057293">ByteOrder::littleEndianInt</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:ga5ee16f591feb0902fddb472eb4057293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 4 bytes into a little-endian integer.  <a href="#ga5ee16f591feb0902fddb472eb4057293">More...</a><br/></td></tr>
<tr class="separator:ga5ee16f591feb0902fddb472eb4057293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68dab24810f92bd18f08471ca2b2bba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaa68dab24810f92bd18f08471ca2b2bba">ByteOrder::littleEndianInt64</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:gaa68dab24810f92bd18f08471ca2b2bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 8 bytes into a little-endian integer.  <a href="#gaa68dab24810f92bd18f08471ca2b2bba">More...</a><br/></td></tr>
<tr class="separator:gaa68dab24810f92bd18f08471ca2b2bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa2888cce7d46ea40f54fceb49b544c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gabfa2888cce7d46ea40f54fceb49b544c">ByteOrder::littleEndianShort</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:gabfa2888cce7d46ea40f54fceb49b544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 2 bytes into a little-endian integer.  <a href="#gabfa2888cce7d46ea40f54fceb49b544c">More...</a><br/></td></tr>
<tr class="separator:gabfa2888cce7d46ea40f54fceb49b544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1a20a5825bcbef1f7b6920e3eee99f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaca1a20a5825bcbef1f7b6920e3eee99f">ByteOrder::bigEndianInt</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:gaca1a20a5825bcbef1f7b6920e3eee99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 4 bytes into a big-endian integer.  <a href="#gaca1a20a5825bcbef1f7b6920e3eee99f">More...</a><br/></td></tr>
<tr class="separator:gaca1a20a5825bcbef1f7b6920e3eee99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c126f0a1015a0c9f5b91aac2991620"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaf7c126f0a1015a0c9f5b91aac2991620">ByteOrder::bigEndianInt64</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:gaf7c126f0a1015a0c9f5b91aac2991620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 8 bytes into a big-endian integer.  <a href="#gaf7c126f0a1015a0c9f5b91aac2991620">More...</a><br/></td></tr>
<tr class="separator:gaf7c126f0a1015a0c9f5b91aac2991620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7716b1b156320f4668d93142c69d7a3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga7716b1b156320f4668d93142c69d7a3b">ByteOrder::bigEndianShort</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:ga7716b1b156320f4668d93142c69d7a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 2 bytes into a big-endian integer.  <a href="#ga7716b1b156320f4668d93142c69d7a3b">More...</a><br/></td></tr>
<tr class="separator:ga7716b1b156320f4668d93142c69d7a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579da6322ef30e565507fdbf0b9faefb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga579da6322ef30e565507fdbf0b9faefb">ByteOrder::isBigEndian</a> () noexcept</td></tr>
<tr class="memdesc:ga579da6322ef30e565507fdbf0b9faefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current CPU is big-endian.  <a href="#ga579da6322ef30e565507fdbf0b9faefb">More...</a><br/></td></tr>
<tr class="separator:ga579da6322ef30e565507fdbf0b9faefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35200b99bb4420fe1401bb9f3bae52a2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga35200b99bb4420fe1401bb9f3bae52a2">ByteOrder::littleEndian24Bit</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:ga35200b99bb4420fe1401bb9f3bae52a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 3 little-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits).  <a href="#ga35200b99bb4420fe1401bb9f3bae52a2">More...</a><br/></td></tr>
<tr class="separator:ga35200b99bb4420fe1401bb9f3bae52a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dffd4f0e34fdd69453104e89996507d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga0dffd4f0e34fdd69453104e89996507d">ByteOrder::bigEndian24Bit</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:ga0dffd4f0e34fdd69453104e89996507d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 3 big-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits).  <a href="#ga0dffd4f0e34fdd69453104e89996507d">More...</a><br/></td></tr>
<tr class="separator:ga0dffd4f0e34fdd69453104e89996507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287ad85e68c599c8dcfdb329aecefda7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga287ad85e68c599c8dcfdb329aecefda7">ByteOrder::littleEndian24BitToChars</a> (int <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>, void *destBytes) noexcept</td></tr>
<tr class="memdesc:ga287ad85e68c599c8dcfdb329aecefda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 24-bit number to 3 little-endian bytes.  <a href="#ga287ad85e68c599c8dcfdb329aecefda7">More...</a><br/></td></tr>
<tr class="separator:ga287ad85e68c599c8dcfdb329aecefda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30f589309d051d2e3476c4c62a698b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaf30f589309d051d2e3476c4c62a698b0">ByteOrder::bigEndian24BitToChars</a> (int <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>, void *destBytes) noexcept</td></tr>
<tr class="memdesc:gaf30f589309d051d2e3476c4c62a698b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 24-bit number to 3 big-endian bytes.  <a href="#gaf30f589309d051d2e3476c4c62a698b0">More...</a><br/></td></tr>
<tr class="separator:gaf30f589309d051d2e3476c4c62a698b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="classAtomic" id="classAtomic"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class Atomic</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Type&gt;<br/>
class Atomic&lt; Type &gt;</h3>

<p>Simple class to hold a primitive value and perform atomic operations on it. </p>
<p>The type used must be a 32 or 64 bit primitive, like an int, pointer, etc. There are methods to perform most of the basic atomic operations. </p>
</div>
<p>Inherits AtomicBase&lt; Type &gt;.</p>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a1e72933a773e5f84bac851aec9ec7b03"><td class="memItemLeft" align="right" valign="top">typedef AtomicBase&lt; Type &gt;<br class="typebreak"/>
::<a class="el" href="group__juce__core-memory.html#a1e72933a773e5f84bac851aec9ec7b03">DiffType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a1e72933a773e5f84bac851aec9ec7b03">DiffType</a></td></tr>
<tr class="memdesc:a1e72933a773e5f84bac851aec9ec7b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resulting type when subtracting the underlying Type.  <a href="#a1e72933a773e5f84bac851aec9ec7b03">More...</a><br/></td></tr>
<tr class="separator:a1e72933a773e5f84bac851aec9ec7b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a903ef283284109ee6bdaa43d9b477224"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a903ef283284109ee6bdaa43d9b477224">Atomic</a> () noexcept</td></tr>
<tr class="memdesc:a903ef283284109ee6bdaa43d9b477224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new value, initialised to zero.  <a href="#a903ef283284109ee6bdaa43d9b477224">More...</a><br/></td></tr>
<tr class="separator:a903ef283284109ee6bdaa43d9b477224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd78cad5b124a086688f112f2d24aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aa5bd78cad5b124a086688f112f2d24aa">Atomic</a> (const Type initialValue) noexcept</td></tr>
<tr class="memdesc:aa5bd78cad5b124a086688f112f2d24aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new value, with a given initial value.  <a href="#aa5bd78cad5b124a086688f112f2d24aa">More...</a><br/></td></tr>
<tr class="separator:aa5bd78cad5b124a086688f112f2d24aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482fb9fec9e47b18884a5d1f1ac4c815"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a482fb9fec9e47b18884a5d1f1ac4c815">Atomic</a> (const <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a482fb9fec9e47b18884a5d1f1ac4c815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another value (atomically).  <a href="#a482fb9fec9e47b18884a5d1f1ac4c815">More...</a><br/></td></tr>
<tr class="separator:a482fb9fec9e47b18884a5d1f1ac4c815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b0fe07fad7cfd1cf68bd02d7da2a3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a25b0fe07fad7cfd1cf68bd02d7da2a3f">~Atomic</a> () noexcept</td></tr>
<tr class="memdesc:a25b0fe07fad7cfd1cf68bd02d7da2a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a25b0fe07fad7cfd1cf68bd02d7da2a3f">More...</a><br/></td></tr>
<tr class="separator:a25b0fe07fad7cfd1cf68bd02d7da2a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39856229e8d4e3da9088d31bad55b9e"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ad39856229e8d4e3da9088d31bad55b9e">get</a> () const noexcept</td></tr>
<tr class="memdesc:ad39856229e8d4e3da9088d31bad55b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically reads and returns the current value.  <a href="#ad39856229e8d4e3da9088d31bad55b9e">More...</a><br/></td></tr>
<tr class="separator:ad39856229e8d4e3da9088d31bad55b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8b91de965363416796ee90ff84d0e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aee8b91de965363416796ee90ff84d0e2">operator=</a> (const <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aee8b91de965363416796ee90ff84d0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another value into this one (atomically).  <a href="#aee8b91de965363416796ee90ff84d0e2">More...</a><br/></td></tr>
<tr class="separator:aee8b91de965363416796ee90ff84d0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac488f361f635427647ed56151d1a9591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ac488f361f635427647ed56151d1a9591">operator=</a> (const Type newValue) noexcept</td></tr>
<tr class="memdesc:ac488f361f635427647ed56151d1a9591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another value into this one (atomically).  <a href="#ac488f361f635427647ed56151d1a9591">More...</a><br/></td></tr>
<tr class="separator:ac488f361f635427647ed56151d1a9591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52abf7d407845b5ff44b46b1c96f00d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a52abf7d407845b5ff44b46b1c96f00d1">set</a> (Type newValue) noexcept</td></tr>
<tr class="memdesc:a52abf7d407845b5ff44b46b1c96f00d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically sets the current value.  <a href="#a52abf7d407845b5ff44b46b1c96f00d1">More...</a><br/></td></tr>
<tr class="separator:a52abf7d407845b5ff44b46b1c96f00d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac224791c1725400f6cb6a37aa7b4dd7f"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ac224791c1725400f6cb6a37aa7b4dd7f">exchange</a> (Type v) noexcept</td></tr>
<tr class="memdesc:ac224791c1725400f6cb6a37aa7b4dd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically sets the current value, returning the value that was replaced.  <a href="#ac224791c1725400f6cb6a37aa7b4dd7f">More...</a><br/></td></tr>
<tr class="separator:ac224791c1725400f6cb6a37aa7b4dd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7ba896941874fb59a3f128913a3aaf"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a4a7ba896941874fb59a3f128913a3aaf">operator+=</a> (<a class="el" href="group__juce__core-memory.html#a1e72933a773e5f84bac851aec9ec7b03">DiffType</a> amountToAdd) noexcept</td></tr>
<tr class="memdesc:a4a7ba896941874fb59a3f128913a3aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically adds a number to this value, returning the new value.  <a href="#a4a7ba896941874fb59a3f128913a3aaf">More...</a><br/></td></tr>
<tr class="separator:a4a7ba896941874fb59a3f128913a3aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07571339cdc9cb7b5f3e92f6e7542b14"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a07571339cdc9cb7b5f3e92f6e7542b14">operator-=</a> (<a class="el" href="group__juce__core-memory.html#a1e72933a773e5f84bac851aec9ec7b03">DiffType</a> amountToSubtract) noexcept</td></tr>
<tr class="memdesc:a07571339cdc9cb7b5f3e92f6e7542b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically subtracts a number from this value, returning the new value.  <a href="#a07571339cdc9cb7b5f3e92f6e7542b14">More...</a><br/></td></tr>
<tr class="separator:a07571339cdc9cb7b5f3e92f6e7542b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc5a6c2e1f07cc097317fe1685819dd"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a9cc5a6c2e1f07cc097317fe1685819dd">operator++</a> () noexcept</td></tr>
<tr class="memdesc:a9cc5a6c2e1f07cc097317fe1685819dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increments this value, returning the new value.  <a href="#a9cc5a6c2e1f07cc097317fe1685819dd">More...</a><br/></td></tr>
<tr class="separator:a9cc5a6c2e1f07cc097317fe1685819dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3a3f87cb87e822d678dfb67f458895"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#adf3a3f87cb87e822d678dfb67f458895">operator--</a> () noexcept</td></tr>
<tr class="memdesc:adf3a3f87cb87e822d678dfb67f458895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically decrements this value, returning the new value.  <a href="#adf3a3f87cb87e822d678dfb67f458895">More...</a><br/></td></tr>
<tr class="separator:adf3a3f87cb87e822d678dfb67f458895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0966a21db3a9d4649f8c869bb38fa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a9c0966a21db3a9d4649f8c869bb38fa0">compareAndSetBool</a> (Type newValue, Type valueToCompare) noexcept</td></tr>
<tr class="memdesc:a9c0966a21db3a9d4649f8c869bb38fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compares this value with a target value, and if it is equal, sets this to be equal to a new value.  <a href="#a9c0966a21db3a9d4649f8c869bb38fa0">More...</a><br/></td></tr>
<tr class="separator:a9c0966a21db3a9d4649f8c869bb38fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d80abdbdf76b8afd9cbf9baf8851910"><td class="memItemLeft" align="right" valign="top">Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a9d80abdbdf76b8afd9cbf9baf8851910">compareAndSetValue</a> (Type newValue, Type valueToCompare) noexcept</td></tr>
<tr class="memdesc:a9d80abdbdf76b8afd9cbf9baf8851910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically compares this value with a target value, and if it is equal, sets this to be equal to a new value.  <a href="#a9d80abdbdf76b8afd9cbf9baf8851910">More...</a><br/></td></tr>
<tr class="separator:a9d80abdbdf76b8afd9cbf9baf8851910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:af427d87b6e491f44d6b57551815c89d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af427d87b6e491f44d6b57551815c89d5">memoryBarrier</a> () noexcept</td></tr>
<tr class="memdesc:af427d87b6e491f44d6b57551815c89d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a memory read/write barrier.  <a href="#af427d87b6e491f44d6b57551815c89d5">More...</a><br/></td></tr>
<tr class="separator:af427d87b6e491f44d6b57551815c89d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="a1e72933a773e5f84bac851aec9ec7b03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AtomicBase&lt;Type&gt;::<a class="el" href="group__juce__core-memory.html#a1e72933a773e5f84bac851aec9ec7b03">DiffType</a> <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::<a class="el" href="group__juce__core-memory.html#a1e72933a773e5f84bac851aec9ec7b03">DiffType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resulting type when subtracting the underlying Type. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a903ef283284109ee6bdaa43d9b477224"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::<a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new value, initialised to zero. </p>

</div>
</div>
<a class="anchor" id="aa5bd78cad5b124a086688f112f2d24aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::<a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a> </td>
          <td>(</td>
          <td class="paramtype">const Type&#160;</td>
          <td class="paramname"><em>initialValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new value, with a given initial value. </p>

</div>
</div>
<a class="anchor" id="a482fb9fec9e47b18884a5d1f1ac4c815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::<a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies another value (atomically). </p>

</div>
</div>
<a class="anchor" id="a25b0fe07fad7cfd1cf68bd02d7da2a3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::~<a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="ad39856229e8d4e3da9088d31bad55b9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically reads and returns the current value. </p>

<p>Referenced by <a class="el" href="group__juce__core-threads.html#a0350ab3d9b5d1877dec3244d5b4e71e9">ThreadLocalValue&lt; Type &gt;::get()</a>, <a class="el" href="group__juce__core-threads.html#a78af45671b2b057f0f584a75f79ff5b5">ThreadLocalValue&lt; Type &gt;::releaseCurrentThreadStorage()</a>, and <a class="el" href="group__juce__core-threads.html#a5f84ce8c97c0c3d76be387b0d9cd5feb">ThreadLocalValue&lt; Type &gt;::~ThreadLocalValue()</a>.</p>

</div>
</div>
<a class="anchor" id="aee8b91de965363416796ee90ff84d0e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&amp; <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies another value into this one (atomically). </p>

</div>
</div>
<a class="anchor" id="ac488f361f635427647ed56151d1a9591"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&amp; <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Type&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies another value into this one (atomically). </p>

</div>
</div>
<a class="anchor" id="a52abf7d407845b5ff44b46b1c96f00d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::set </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>newValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically sets the current value. </p>

</div>
</div>
<a class="anchor" id="ac224791c1725400f6cb6a37aa7b4dd7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::exchange </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically sets the current value, returning the value that was replaced. </p>

<p>Referenced by <a class="el" href="group__juce__core-memory.html#a52abf7d407845b5ff44b46b1c96f00d1">Atomic&lt; Thread::ThreadID &gt;::set()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a7ba896941874fb59a3f128913a3aaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#a1e72933a773e5f84bac851aec9ec7b03">DiffType</a>&#160;</td>
          <td class="paramname"><em>amountToAdd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically adds a number to this value, returning the new value. </p>

</div>
</div>
<a class="anchor" id="a07571339cdc9cb7b5f3e92f6e7542b14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#a1e72933a773e5f84bac851aec9ec7b03">DiffType</a>&#160;</td>
          <td class="paramname"><em>amountToSubtract</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically subtracts a number from this value, returning the new value. </p>

</div>
</div>
<a class="anchor" id="a9cc5a6c2e1f07cc097317fe1685819dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically increments this value, returning the new value. </p>

</div>
</div>
<a class="anchor" id="adf3a3f87cb87e822d678dfb67f458895"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically decrements this value, returning the new value. </p>

</div>
</div>
<a class="anchor" id="a9c0966a21db3a9d4649f8c869bb38fa0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::compareAndSetBool </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>valueToCompare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compares this value with a target value, and if it is equal, sets this to be equal to a new value. </p>
<p>This operation is the atomic equivalent of doing this: </p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="group__juce__core-memory.html#a9c0966a21db3a9d4649f8c869bb38fa0">compareAndSetBool</a> (<a class="code" href="group__juce__blocks__basics-littlefoot.html#ga4fb4051df81acdbcaa446ab5a02dd8e7">Type</a> newValue, <a class="code" href="group__juce__blocks__basics-littlefoot.html#ga4fb4051df81acdbcaa446ab5a02dd8e7">Type</a> valueToCompare)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">get</span>() == valueToCompare)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="group__juce__core-memory.html#a52abf7d407845b5ff44b46b1c96f00d1">set</a> (newValue);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>true if the comparison was true and the value was replaced; false if the comparison failed and the value was left unchanged. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#a9d80abdbdf76b8afd9cbf9baf8851910" title="Atomically compares this value with a target value, and if it is equal, sets this to be equal to a ne...">compareAndSetValue</a> </dd></dl>

<p>Referenced by <a class="el" href="group__juce__core-threads.html#a0350ab3d9b5d1877dec3244d5b4e71e9">ThreadLocalValue&lt; Type &gt;::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d80abdbdf76b8afd9cbf9baf8851910"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::compareAndSetValue </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>newValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>valueToCompare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically compares this value with a target value, and if it is equal, sets this to be equal to a new value. </p>
<p>This operation is the atomic equivalent of doing this: </p>
<div class="fragment"><div class="line"><a class="code" href="group__juce__blocks__basics-littlefoot.html#ga4fb4051df81acdbcaa446ab5a02dd8e7">Type</a> <a class="code" href="group__juce__core-memory.html#a9d80abdbdf76b8afd9cbf9baf8851910">compareAndSetValue</a> (<a class="code" href="group__juce__blocks__basics-littlefoot.html#ga4fb4051df81acdbcaa446ab5a02dd8e7">Type</a> newValue, <a class="code" href="group__juce__blocks__basics-littlefoot.html#ga4fb4051df81acdbcaa446ab5a02dd8e7">Type</a> valueToCompare)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__juce__blocks__basics-littlefoot.html#ga4fb4051df81acdbcaa446ab5a02dd8e7">Type</a> oldValue = <span class="keyword">get</span>();</div>
<div class="line">    <span class="keywordflow">if</span> (oldValue == valueToCompare)</div>
<div class="line">        <a class="code" href="group__juce__core-memory.html#a52abf7d407845b5ff44b46b1c96f00d1">set</a> (newValue);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> oldValue;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>the old value before it was changed. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#a9c0966a21db3a9d4649f8c869bb38fa0" title="Atomically compares this value with a target value, and if it is equal, sets this to be equal to a ne...">compareAndSetBool</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af427d87b6e491f44d6b57551815c89d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-memory.html#classAtomic">Atomic</a>&lt; Type &gt;::memoryBarrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a memory read/write barrier. </p>

</div>
</div>

</div>
</div>
<a name="classByteOrder" id="classByteOrder"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ByteOrder</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Contains static methods for converting the byte order between different endiannesses. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:gac2b033fd8e98d9c4dfbb57a88466d62f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gac2b033fd8e98d9c4dfbb57a88466d62f">swap</a> (<a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gac2b033fd8e98d9c4dfbb57a88466d62f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the upper and lower bytes of a 16-bit integer.  <a href="group__juce__core-memory.html#gac2b033fd8e98d9c4dfbb57a88466d62f">More...</a><br/></td></tr>
<tr class="separator:gac2b033fd8e98d9c4dfbb57a88466d62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039a6658618d891f825cdec00929356a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga039a6658618d891f825cdec00929356a">swap</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga039a6658618d891f825cdec00929356a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the 4 bytes in a 32-bit integer.  <a href="group__juce__core-memory.html#ga039a6658618d891f825cdec00929356a">More...</a><br/></td></tr>
<tr class="separator:ga039a6658618d891f825cdec00929356a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa754df407abe7487660dd3f223c87324"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaa754df407abe7487660dd3f223c87324">swap</a> (<a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gaa754df407abe7487660dd3f223c87324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the order of the 8 bytes in a 64-bit integer.  <a href="group__juce__core-memory.html#gaa754df407abe7487660dd3f223c87324">More...</a><br/></td></tr>
<tr class="separator:gaa754df407abe7487660dd3f223c87324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8461d39c7370a6adb9556d3235cbdbe1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga8461d39c7370a6adb9556d3235cbdbe1">swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga8461d39c7370a6adb9556d3235cbdbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 16-bit unsigned int if the CPU is big-endian.  <a href="group__juce__core-memory.html#ga8461d39c7370a6adb9556d3235cbdbe1">More...</a><br/></td></tr>
<tr class="separator:ga8461d39c7370a6adb9556d3235cbdbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433cad5a04c392b9c97658eb6de79aef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga433cad5a04c392b9c97658eb6de79aef">swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga433cad5a04c392b9c97658eb6de79aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit unsigned int if the CPU is big-endian.  <a href="group__juce__core-memory.html#ga433cad5a04c392b9c97658eb6de79aef">More...</a><br/></td></tr>
<tr class="separator:ga433cad5a04c392b9c97658eb6de79aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3568cb8775a1fa8f67bec0a889582ade"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga3568cb8775a1fa8f67bec0a889582ade">swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga3568cb8775a1fa8f67bec0a889582ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit unsigned int if the CPU is big-endian.  <a href="group__juce__core-memory.html#ga3568cb8775a1fa8f67bec0a889582ade">More...</a><br/></td></tr>
<tr class="separator:ga3568cb8775a1fa8f67bec0a889582ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga878689f08a7a6ea436cd550c6538ee4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga878689f08a7a6ea436cd550c6538ee4a">swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga878689f08a7a6ea436cd550c6538ee4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 16-bit signed int if the CPU is big-endian.  <a href="group__juce__core-memory.html#ga878689f08a7a6ea436cd550c6538ee4a">More...</a><br/></td></tr>
<tr class="separator:ga878689f08a7a6ea436cd550c6538ee4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee1facdbe64e044d394093aad0042ce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga2ee1facdbe64e044d394093aad0042ce">swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga2ee1facdbe64e044d394093aad0042ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit signed int if the CPU is big-endian.  <a href="group__juce__core-memory.html#ga2ee1facdbe64e044d394093aad0042ce">More...</a><br/></td></tr>
<tr class="separator:ga2ee1facdbe64e044d394093aad0042ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9869ab64491231b02a6cca33d6ff9f60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga9869ab64491231b02a6cca33d6ff9f60">swapIfBigEndian</a> (<a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga9869ab64491231b02a6cca33d6ff9f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit signed int if the CPU is big-endian.  <a href="group__juce__core-memory.html#ga9869ab64491231b02a6cca33d6ff9f60">More...</a><br/></td></tr>
<tr class="separator:ga9869ab64491231b02a6cca33d6ff9f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b284220a53da3852b131d98dd85fdbb"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga9b284220a53da3852b131d98dd85fdbb">swapIfBigEndian</a> (float <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga9b284220a53da3852b131d98dd85fdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit float if the CPU is big-endian.  <a href="group__juce__core-memory.html#ga9b284220a53da3852b131d98dd85fdbb">More...</a><br/></td></tr>
<tr class="separator:ga9b284220a53da3852b131d98dd85fdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92060f5baff564c7e346309473326b69"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga92060f5baff564c7e346309473326b69">swapIfBigEndian</a> (double <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga92060f5baff564c7e346309473326b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit float if the CPU is big-endian.  <a href="group__juce__core-memory.html#ga92060f5baff564c7e346309473326b69">More...</a><br/></td></tr>
<tr class="separator:ga92060f5baff564c7e346309473326b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374444379b6a0f2010e36fa985175b9d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga374444379b6a0f2010e36fa985175b9d">swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga374444379b6a0f2010e36fa985175b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 16-bit unsigned int if the CPU is little-endian.  <a href="group__juce__core-memory.html#ga374444379b6a0f2010e36fa985175b9d">More...</a><br/></td></tr>
<tr class="separator:ga374444379b6a0f2010e36fa985175b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6108916f94343a894fd7a146d48000"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga4a6108916f94343a894fd7a146d48000">swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga4a6108916f94343a894fd7a146d48000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit unsigned int if the CPU is little-endian.  <a href="group__juce__core-memory.html#ga4a6108916f94343a894fd7a146d48000">More...</a><br/></td></tr>
<tr class="separator:ga4a6108916f94343a894fd7a146d48000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ca5e947cb823fc208ede0635387695"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga08ca5e947cb823fc208ede0635387695">swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga08ca5e947cb823fc208ede0635387695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit unsigned int if the CPU is little-endian.  <a href="group__juce__core-memory.html#ga08ca5e947cb823fc208ede0635387695">More...</a><br/></td></tr>
<tr class="separator:ga08ca5e947cb823fc208ede0635387695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744b0ba49fa5cd0323fbd0cb663a64a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga744b0ba49fa5cd0323fbd0cb663a64a1">swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga744b0ba49fa5cd0323fbd0cb663a64a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 16-bit signed int if the CPU is little-endian.  <a href="group__juce__core-memory.html#ga744b0ba49fa5cd0323fbd0cb663a64a1">More...</a><br/></td></tr>
<tr class="separator:ga744b0ba49fa5cd0323fbd0cb663a64a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00631878bb112db9e31cb7987cd0114"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gae00631878bb112db9e31cb7987cd0114">swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gae00631878bb112db9e31cb7987cd0114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit signed int if the CPU is little-endian.  <a href="group__juce__core-memory.html#gae00631878bb112db9e31cb7987cd0114">More...</a><br/></td></tr>
<tr class="separator:gae00631878bb112db9e31cb7987cd0114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531090b4ee8e06c95c8c6d0536aadd64"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga531090b4ee8e06c95c8c6d0536aadd64">swapIfLittleEndian</a> (<a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga531090b4ee8e06c95c8c6d0536aadd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit signed int if the CPU is little-endian.  <a href="group__juce__core-memory.html#ga531090b4ee8e06c95c8c6d0536aadd64">More...</a><br/></td></tr>
<tr class="separator:ga531090b4ee8e06c95c8c6d0536aadd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabde05ef314c29aeb9f49c1dbe13f6fb2"><td class="memItemLeft" align="right" valign="top">static float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gabde05ef314c29aeb9f49c1dbe13f6fb2">swapIfLittleEndian</a> (float <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:gabde05ef314c29aeb9f49c1dbe13f6fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 32-bit float if the CPU is little-endian.  <a href="group__juce__core-memory.html#gabde05ef314c29aeb9f49c1dbe13f6fb2">More...</a><br/></td></tr>
<tr class="separator:gabde05ef314c29aeb9f49c1dbe13f6fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51aa557077c032ab3fec337e0b47b5f0"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga51aa557077c032ab3fec337e0b47b5f0">swapIfLittleEndian</a> (double <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>) noexcept</td></tr>
<tr class="memdesc:ga51aa557077c032ab3fec337e0b47b5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the byte order of a 64-bit float if the CPU is little-endian.  <a href="group__juce__core-memory.html#ga51aa557077c032ab3fec337e0b47b5f0">More...</a><br/></td></tr>
<tr class="separator:ga51aa557077c032ab3fec337e0b47b5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ee16f591feb0902fddb472eb4057293"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga5ee16f591feb0902fddb472eb4057293">littleEndianInt</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:ga5ee16f591feb0902fddb472eb4057293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 4 bytes into a little-endian integer.  <a href="group__juce__core-memory.html#ga5ee16f591feb0902fddb472eb4057293">More...</a><br/></td></tr>
<tr class="separator:ga5ee16f591feb0902fddb472eb4057293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa68dab24810f92bd18f08471ca2b2bba"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaa68dab24810f92bd18f08471ca2b2bba">littleEndianInt64</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:gaa68dab24810f92bd18f08471ca2b2bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 8 bytes into a little-endian integer.  <a href="group__juce__core-memory.html#gaa68dab24810f92bd18f08471ca2b2bba">More...</a><br/></td></tr>
<tr class="separator:gaa68dab24810f92bd18f08471ca2b2bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa2888cce7d46ea40f54fceb49b544c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gabfa2888cce7d46ea40f54fceb49b544c">littleEndianShort</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:gabfa2888cce7d46ea40f54fceb49b544c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 2 bytes into a little-endian integer.  <a href="group__juce__core-memory.html#gabfa2888cce7d46ea40f54fceb49b544c">More...</a><br/></td></tr>
<tr class="separator:gabfa2888cce7d46ea40f54fceb49b544c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1a20a5825bcbef1f7b6920e3eee99f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaca1a20a5825bcbef1f7b6920e3eee99f">bigEndianInt</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:gaca1a20a5825bcbef1f7b6920e3eee99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 4 bytes into a big-endian integer.  <a href="group__juce__core-memory.html#gaca1a20a5825bcbef1f7b6920e3eee99f">More...</a><br/></td></tr>
<tr class="separator:gaca1a20a5825bcbef1f7b6920e3eee99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c126f0a1015a0c9f5b91aac2991620"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaf7c126f0a1015a0c9f5b91aac2991620">bigEndianInt64</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:gaf7c126f0a1015a0c9f5b91aac2991620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 8 bytes into a big-endian integer.  <a href="group__juce__core-memory.html#gaf7c126f0a1015a0c9f5b91aac2991620">More...</a><br/></td></tr>
<tr class="separator:gaf7c126f0a1015a0c9f5b91aac2991620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7716b1b156320f4668d93142c69d7a3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga7716b1b156320f4668d93142c69d7a3b">bigEndianShort</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:ga7716b1b156320f4668d93142c69d7a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns 2 bytes into a big-endian integer.  <a href="group__juce__core-memory.html#ga7716b1b156320f4668d93142c69d7a3b">More...</a><br/></td></tr>
<tr class="separator:ga7716b1b156320f4668d93142c69d7a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35200b99bb4420fe1401bb9f3bae52a2"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga35200b99bb4420fe1401bb9f3bae52a2">littleEndian24Bit</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:ga35200b99bb4420fe1401bb9f3bae52a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 3 little-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits).  <a href="group__juce__core-memory.html#ga35200b99bb4420fe1401bb9f3bae52a2">More...</a><br/></td></tr>
<tr class="separator:ga35200b99bb4420fe1401bb9f3bae52a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dffd4f0e34fdd69453104e89996507d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga0dffd4f0e34fdd69453104e89996507d">bigEndian24Bit</a> (const void *bytes) noexcept</td></tr>
<tr class="memdesc:ga0dffd4f0e34fdd69453104e89996507d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts 3 big-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits).  <a href="group__juce__core-memory.html#ga0dffd4f0e34fdd69453104e89996507d">More...</a><br/></td></tr>
<tr class="separator:ga0dffd4f0e34fdd69453104e89996507d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga287ad85e68c599c8dcfdb329aecefda7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga287ad85e68c599c8dcfdb329aecefda7">littleEndian24BitToChars</a> (int <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>, void *destBytes) noexcept</td></tr>
<tr class="memdesc:ga287ad85e68c599c8dcfdb329aecefda7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 24-bit number to 3 little-endian bytes.  <a href="group__juce__core-memory.html#ga287ad85e68c599c8dcfdb329aecefda7">More...</a><br/></td></tr>
<tr class="separator:ga287ad85e68c599c8dcfdb329aecefda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf30f589309d051d2e3476c4c62a698b0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#gaf30f589309d051d2e3476c4c62a698b0">bigEndian24BitToChars</a> (int <a class="el" href="group__juce__audio__processors-format__types.html#gabfa595d43bf960020c2afada3d371389">value</a>, void *destBytes) noexcept</td></tr>
<tr class="memdesc:gaf30f589309d051d2e3476c4c62a698b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a 24-bit number to 3 big-endian bytes.  <a href="group__juce__core-memory.html#gaf30f589309d051d2e3476c4c62a698b0">More...</a><br/></td></tr>
<tr class="separator:gaf30f589309d051d2e3476c4c62a698b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579da6322ef30e565507fdbf0b9faefb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ga579da6322ef30e565507fdbf0b9faefb">isBigEndian</a> () noexcept</td></tr>
<tr class="memdesc:ga579da6322ef30e565507fdbf0b9faefb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current CPU is big-endian.  <a href="group__juce__core-memory.html#ga579da6322ef30e565507fdbf0b9faefb">More...</a><br/></td></tr>
<tr class="separator:ga579da6322ef30e565507fdbf0b9faefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<a name="structContainerDeletePolicy" id="structContainerDeletePolicy"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ContainerDeletePolicy</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ObjectType&gt;<br/>
struct ContainerDeletePolicy&lt; ObjectType &gt;</h3>

<p>Used by container classes as an indirect way to delete an object of a particular type. </p>
<p>The generic implementation of this class simply calls 'delete', but you can create a specialised version of it for a particular class if you need to delete that type of object in a more appropriate way.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, <a class="el" href="group__juce__core-containers.html#classOwnedArray" title="An array designed for holding objects. ">OwnedArray</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:adff767e9533d0e7bdd8bc914d21eb01a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#adff767e9533d0e7bdd8bc914d21eb01a">destroy</a> (ObjectType *object)</td></tr>
<tr class="separator:adff767e9533d0e7bdd8bc914d21eb01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="adff767e9533d0e7bdd8bc914d21eb01a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="group__juce__core-memory.html#structContainerDeletePolicy">ContainerDeletePolicy</a>&lt; ObjectType &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="group__juce__core-maths.html#ga07a40f89c351c7e7a7f98a62beaa1e4a">ignoreUnused()</a>.</p>

<p>Referenced by <a class="el" href="group__juce__core-memory.html#afefc7940828d72c056e03804cd6bea9f">ScopedPointer&lt; ListViewport &gt;::operator=()</a>, <a class="el" href="group__juce__core-containers.html#a6ca377ada4d52033b6bc9efd3614b5c2">OwnedArray&lt; MidiBuffer &gt;::removeRange()</a>, and <a class="el" href="group__juce__core-memory.html#a3c540f0121065aafa5f9607362fc1450">ScopedPointer&lt; ListViewport &gt;::~ScopedPointer()</a>.</p>

</div>
</div>

</div>
</div>
<a name="classHeapBlock" id="classHeapBlock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class HeapBlock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ElementType, bool throwOnFailure = false&gt;<br/>
class HeapBlock&lt; ElementType, throwOnFailure &gt;</h3>

<p>Very simple container class to hold a pointer to some data on the heap. </p>
<p>When you need to allocate some heap storage for something, always try to use this class instead of allocating the memory directly using malloc/free.</p>
<p>A <a class="el" href="group__juce__core-memory.html">HeapBlock&lt;char&gt;</a> object can be treated in pretty much exactly the same way as an char*, but as long as you allocate it on the stack or as a class member, it's almost impossible for it to leak memory.</p>
<p>It also makes your code much more concise and readable than doing the same thing using direct allocations,</p>
<p>E.g. instead of this: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>* temp = (<span class="keywordtype">int</span>*) <a class="code" href="group__juce__core-memory.html#a1a196c4ebdb6a5ff9517e262b91894cf">malloc</a> (1024 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line">memcpy (temp, xyz, 1024 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line"><a class="code" href="group__juce__core-memory.html#a8ec3fb69997d6f530d60cb5e0969f97f">free</a> (temp);</div>
<div class="line">temp = (<span class="keywordtype">int</span>*) <a class="code" href="group__juce__core-memory.html#a59dc4dfb0d05906164f4362b2086cd50">calloc</a> (2048 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line">temp[0] = 1234;</div>
<div class="line">memcpy (foobar, temp, 2048 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line"><a class="code" href="group__juce__core-memory.html#a8ec3fb69997d6f530d60cb5e0969f97f">free</a> (temp);</div>
</div><!-- fragment --><p>..you could just write this: </p>
<div class="fragment"><div class="line"><a class="code" href="group__juce__core-memory.html">HeapBlock&lt;int&gt;</a> temp (1024);</div>
<div class="line">memcpy (temp, xyz, 1024 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
<div class="line">temp.calloc (2048);</div>
<div class="line">temp[0] = 1234;</div>
<div class="line">memcpy (foobar, temp, 2048 * <span class="keyword">sizeof</span> (<span class="keywordtype">int</span>));</div>
</div><!-- fragment --><p>The class is extremely lightweight, containing only a pointer to the data, and exposes malloc/realloc/calloc/free methods that do the same jobs as their less object-oriented counterparts. Despite adding safety, you probably won't sacrifice any performance by using this in place of normal pointers.</p>
<p>The throwOnFailure template parameter can be set to true if you'd like the class to throw a std::bad_alloc exception when an allocation fails. If this is false, then a failed allocation will just leave the heapblock with a null pointer (assuming that the system's <a class="el" href="group__juce__core-memory.html#a1a196c4ebdb6a5ff9517e262b91894cf" title="Allocates a specified amount of memory. ">malloc()</a> function doesn't throw).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-containers.html#classArray" title="Holds a resizable array of primitive or copy-by-value objects. ">Array</a>, <a class="el" href="group__juce__core-containers.html#classOwnedArray" title="An array designed for holding objects. ">OwnedArray</a>, <a class="el" href="group__juce__core-memory.html#classMemoryBlock" title="A class to hold a resizable block of raw data. ">MemoryBlock</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a5757b5bd325d4addb907186b08e6849e"><td class="memItemLeft" align="right" valign="top">typedef ElementType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a5757b5bd325d4addb907186b08e6849e">Type</a></td></tr>
<tr class="memdesc:a5757b5bd325d4addb907186b08e6849e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef can be used to get the type of the heapblock's elements.  <a href="#a5757b5bd325d4addb907186b08e6849e">More...</a><br/></td></tr>
<tr class="separator:a5757b5bd325d4addb907186b08e6849e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ab7643beefa078bb4692dbfff40f6f3bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ab7643beefa078bb4692dbfff40f6f3bb">HeapBlock</a> () noexcept</td></tr>
<tr class="memdesc:ab7643beefa078bb4692dbfff40f6f3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a> which is initially just a null pointer.  <a href="#ab7643beefa078bb4692dbfff40f6f3bb">More...</a><br/></td></tr>
<tr class="separator:ab7643beefa078bb4692dbfff40f6f3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31427ded49cc996e6f894f124c4aa5ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a31427ded49cc996e6f894f124c4aa5ba">HeapBlock</a> (const size_t numElements)</td></tr>
<tr class="memdesc:a31427ded49cc996e6f894f124c4aa5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a> containing a number of elements.  <a href="#a31427ded49cc996e6f894f124c4aa5ba">More...</a><br/></td></tr>
<tr class="separator:a31427ded49cc996e6f894f124c4aa5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd966a89c09b50e2fa4efc1a7b20ca6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#adcd966a89c09b50e2fa4efc1a7b20ca6">HeapBlock</a> (const size_t numElements, const bool initialiseToZero)</td></tr>
<tr class="memdesc:adcd966a89c09b50e2fa4efc1a7b20ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a> containing a number of elements.  <a href="#adcd966a89c09b50e2fa4efc1a7b20ca6">More...</a><br/></td></tr>
<tr class="separator:adcd966a89c09b50e2fa4efc1a7b20ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf392fafab8530d45132eaeb81ff372d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#abf392fafab8530d45132eaeb81ff372d">~HeapBlock</a> ()</td></tr>
<tr class="memdesc:abf392fafab8530d45132eaeb81ff372d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#abf392fafab8530d45132eaeb81ff372d">More...</a><br/></td></tr>
<tr class="separator:abf392fafab8530d45132eaeb81ff372d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e44081c3cbef5f634dd5a2a58cd1bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a43e44081c3cbef5f634dd5a2a58cd1bd">HeapBlock</a> (<a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a43e44081c3cbef5f634dd5a2a58cd1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a43e44081c3cbef5f634dd5a2a58cd1bd">More...</a><br/></td></tr>
<tr class="separator:a43e44081c3cbef5f634dd5a2a58cd1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877202b3a190fecfc309e43cd706822a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a877202b3a190fecfc309e43cd706822a">operator=</a> (<a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a877202b3a190fecfc309e43cd706822a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a877202b3a190fecfc309e43cd706822a">More...</a><br/></td></tr>
<tr class="separator:a877202b3a190fecfc309e43cd706822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d00012477feaaab90bcf100d05d08a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af6d00012477feaaab90bcf100d05d08a">operator ElementType *</a> () const noexcept</td></tr>
<tr class="memdesc:af6d00012477feaaab90bcf100d05d08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the allocated data.  <a href="#af6d00012477feaaab90bcf100d05d08a">More...</a><br/></td></tr>
<tr class="separator:af6d00012477feaaab90bcf100d05d08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a00ad8520b7b4b5f58c063a7247a7f"><td class="memItemLeft" align="right" valign="top">ElementType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a30a00ad8520b7b4b5f58c063a7247a7f">getData</a> () const noexcept</td></tr>
<tr class="memdesc:a30a00ad8520b7b4b5f58c063a7247a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the allocated data.  <a href="#a30a00ad8520b7b4b5f58c063a7247a7f">More...</a><br/></td></tr>
<tr class="separator:a30a00ad8520b7b4b5f58c063a7247a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912268a681322c1234753bd580bf1f89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a912268a681322c1234753bd580bf1f89">operator void *</a> () const noexcept</td></tr>
<tr class="memdesc:a912268a681322c1234753bd580bf1f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a void pointer to the allocated data.  <a href="#a912268a681322c1234753bd580bf1f89">More...</a><br/></td></tr>
<tr class="separator:a912268a681322c1234753bd580bf1f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51c07aad68df37e185d1f452a5ace97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af51c07aad68df37e185d1f452a5ace97">operator const void *</a> () const noexcept</td></tr>
<tr class="memdesc:af51c07aad68df37e185d1f452a5ace97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a void pointer to the allocated data.  <a href="#af51c07aad68df37e185d1f452a5ace97">More...</a><br/></td></tr>
<tr class="separator:af51c07aad68df37e185d1f452a5ace97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d495cdad2d794c5fc544e54d43caa2"><td class="memItemLeft" align="right" valign="top">ElementType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ad7d495cdad2d794c5fc544e54d43caa2">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:ad7d495cdad2d794c5fc544e54d43caa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you use indirect calls to the first element in the array.  <a href="#ad7d495cdad2d794c5fc544e54d43caa2">More...</a><br/></td></tr>
<tr class="separator:ad7d495cdad2d794c5fc544e54d43caa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fde2d780504edd9e7a33efe0c24ab9c"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:a4fde2d780504edd9e7a33efe0c24ab9c"><td class="memTemplItemLeft" align="right" valign="top">ElementType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a4fde2d780504edd9e7a33efe0c24ab9c">operator[]</a> (IndexType <a class="el" href="group__juce__audio__processors-format__types.html#gab57c9d4e7c6d9726b6ea1da3521e4792">index</a>) const noexcept</td></tr>
<tr class="memdesc:a4fde2d780504edd9e7a33efe0c24ab9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to one of the data elements.  <a href="#a4fde2d780504edd9e7a33efe0c24ab9c">More...</a><br/></td></tr>
<tr class="separator:a4fde2d780504edd9e7a33efe0c24ab9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5769755baa56702235ecf2edc68f808"><td class="memTemplParams" colspan="2">template&lt;typename IndexType &gt; </td></tr>
<tr class="memitem:ae5769755baa56702235ecf2edc68f808"><td class="memTemplItemLeft" align="right" valign="top">ElementType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae5769755baa56702235ecf2edc68f808">operator+</a> (IndexType <a class="el" href="group__juce__audio__processors-format__types.html#gab57c9d4e7c6d9726b6ea1da3521e4792">index</a>) const noexcept</td></tr>
<tr class="memdesc:ae5769755baa56702235ecf2edc68f808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a data element at an offset from the start of the array.  <a href="#ae5769755baa56702235ecf2edc68f808">More...</a><br/></td></tr>
<tr class="separator:ae5769755baa56702235ecf2edc68f808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e298218cf588337359db82edd07e497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a4e298218cf588337359db82edd07e497">operator==</a> (const ElementType *const otherPointer) const noexcept</td></tr>
<tr class="memdesc:a4e298218cf588337359db82edd07e497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the pointer with another pointer.  <a href="#a4e298218cf588337359db82edd07e497">More...</a><br/></td></tr>
<tr class="separator:a4e298218cf588337359db82edd07e497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ba60581374bc14ffc29d208937d0ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a02ba60581374bc14ffc29d208937d0ae">operator!=</a> (const ElementType *const otherPointer) const noexcept</td></tr>
<tr class="memdesc:a02ba60581374bc14ffc29d208937d0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the pointer with another pointer.  <a href="#a02ba60581374bc14ffc29d208937d0ae">More...</a><br/></td></tr>
<tr class="separator:a02ba60581374bc14ffc29d208937d0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a196c4ebdb6a5ff9517e262b91894cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a1a196c4ebdb6a5ff9517e262b91894cf">malloc</a> (const size_t newNumElements, const size_t elementSize=sizeof(ElementType))</td></tr>
<tr class="memdesc:a1a196c4ebdb6a5ff9517e262b91894cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a specified amount of memory.  <a href="#a1a196c4ebdb6a5ff9517e262b91894cf">More...</a><br/></td></tr>
<tr class="separator:a1a196c4ebdb6a5ff9517e262b91894cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dc4dfb0d05906164f4362b2086cd50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a59dc4dfb0d05906164f4362b2086cd50">calloc</a> (const size_t newNumElements, const size_t elementSize=sizeof(ElementType))</td></tr>
<tr class="memdesc:a59dc4dfb0d05906164f4362b2086cd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a specified amount of memory and clears it.  <a href="#a59dc4dfb0d05906164f4362b2086cd50">More...</a><br/></td></tr>
<tr class="separator:a59dc4dfb0d05906164f4362b2086cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e999ff1f7ed59dd4546596447059cc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a4e999ff1f7ed59dd4546596447059cc7">allocate</a> (const size_t newNumElements, bool initialiseToZero)</td></tr>
<tr class="memdesc:a4e999ff1f7ed59dd4546596447059cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a specified amount of memory and optionally clears it.  <a href="#a4e999ff1f7ed59dd4546596447059cc7">More...</a><br/></td></tr>
<tr class="separator:a4e999ff1f7ed59dd4546596447059cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f22feaa5bb7278e6a6234ec5d19778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a75f22feaa5bb7278e6a6234ec5d19778">realloc</a> (const size_t newNumElements, const size_t elementSize=sizeof(ElementType))</td></tr>
<tr class="memdesc:a75f22feaa5bb7278e6a6234ec5d19778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-allocates a specified amount of memory.  <a href="#a75f22feaa5bb7278e6a6234ec5d19778">More...</a><br/></td></tr>
<tr class="separator:a75f22feaa5bb7278e6a6234ec5d19778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec3fb69997d6f530d60cb5e0969f97f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a8ec3fb69997d6f530d60cb5e0969f97f">free</a> () noexcept</td></tr>
<tr class="memdesc:a8ec3fb69997d6f530d60cb5e0969f97f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees any currently-allocated data.  <a href="#a8ec3fb69997d6f530d60cb5e0969f97f">More...</a><br/></td></tr>
<tr class="separator:a8ec3fb69997d6f530d60cb5e0969f97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebc384a5d3f8ccfb56229688a0a273c"><td class="memTemplParams" colspan="2">template&lt;bool otherBlockThrows&gt; </td></tr>
<tr class="memitem:a7ebc384a5d3f8ccfb56229688a0a273c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a7ebc384a5d3f8ccfb56229688a0a273c">swapWith</a> (<a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, otherBlockThrows &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a7ebc384a5d3f8ccfb56229688a0a273c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this object's data with the data of another <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a>.  <a href="#a7ebc384a5d3f8ccfb56229688a0a273c">More...</a><br/></td></tr>
<tr class="separator:a7ebc384a5d3f8ccfb56229688a0a273c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658838e2b07f498b169c87c73040b509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a658838e2b07f498b169c87c73040b509">clear</a> (size_t numElements) noexcept</td></tr>
<tr class="memdesc:a658838e2b07f498b169c87c73040b509"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fills the block with zeros, up to the number of elements specified.  <a href="#a658838e2b07f498b169c87c73040b509">More...</a><br/></td></tr>
<tr class="separator:a658838e2b07f498b169c87c73040b509"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="a5757b5bd325d4addb907186b08e6849e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ElementType <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::<a class="el" href="group__juce__core-memory.html#a5757b5bd325d4addb907186b08e6849e">Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This typedef can be used to get the type of the heapblock's elements. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ab7643beefa078bb4692dbfff40f6f3bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::<a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a> which is initially just a null pointer. </p>
<p>After creation, you can resize the array using the <a class="el" href="group__juce__core-memory.html#a1a196c4ebdb6a5ff9517e262b91894cf" title="Allocates a specified amount of memory. ">malloc()</a>, <a class="el" href="group__juce__core-memory.html#a59dc4dfb0d05906164f4362b2086cd50" title="Allocates a specified amount of memory and clears it. ">calloc()</a>, or <a class="el" href="group__juce__core-memory.html#a75f22feaa5bb7278e6a6234ec5d19778" title="Re-allocates a specified amount of memory. ">realloc()</a> methods. </p>

</div>
</div>
<a class="anchor" id="a31427ded49cc996e6f894f124c4aa5ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::<a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a> containing a number of elements. </p>
<p>The contents of the block are undefined, as it will have been created by a malloc call.</p>
<p>If you want an array of zero values, you can use the <a class="el" href="group__juce__core-memory.html#a59dc4dfb0d05906164f4362b2086cd50" title="Allocates a specified amount of memory and clears it. ">calloc()</a> method or the other constructor that takes an InitialisationState parameter. </p>

</div>
</div>
<a class="anchor" id="adcd966a89c09b50e2fa4efc1a7b20ca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::<a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>initialiseToZero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a> containing a number of elements. </p>
<p>The initialiseToZero parameter determines whether the new memory should be cleared, or left uninitialised. </p>

</div>
</div>
<a class="anchor" id="abf392fafab8530d45132eaeb81ff372d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::~<a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This will free the data, if any has been allocated. </p>

</div>
</div>
<a class="anchor" id="a43e44081c3cbef5f634dd5a2a58cd1bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::<a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a877202b3a190fecfc309e43cd706822a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&amp; <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a class="anchor" id="af6d00012477feaaab90bcf100d05d08a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator ElementType * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the allocated data. </p>
<p>This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="group__juce__core-memory.html#a8ec3fb69997d6f530d60cb5e0969f97f" title="Frees any currently-allocated data. ">free()</a> method. </p>

</div>
</div>
<a class="anchor" id="a30a00ad8520b7b4b5f58c063a7247a7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType* <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a raw pointer to the allocated data. </p>
<p>This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="group__juce__core-memory.html#a8ec3fb69997d6f530d60cb5e0969f97f" title="Frees any currently-allocated data. ">free()</a> method. </p>

<p>Referenced by <a class="el" href="group__juce__core-containers.html#ae4d087d8723db7a39fb876d419d9f960">ReferenceCountedArray&lt; AudioProcessorGraph::Node &gt;::addOrReplaceSorted()</a>, <a class="el" href="group__juce__core-containers.html#afb1a9958a818b6c410d79fc65b23432e">ReferenceCountedArray&lt; AudioProcessorGraph::Node &gt;::addSorted()</a>, <a class="el" href="group__juce__core-containers.html#ac87e81838149b9d541f6afe605a81b43">OwnedArray&lt; MidiBuffer &gt;::addSorted()</a>, <a class="el" href="group__juce__core-containers.html#a4ae4a483c09550d8432b98db14f2d132">OwnedArray&lt; MidiBuffer &gt;::contains()</a>, <a class="el" href="group__juce__core-containers.html#a5660a4dab2e9765784f1c5af73d7c303">ReferenceCountedArray&lt; AudioProcessorGraph::Node &gt;::contains()</a>, <a class="el" href="classSpeakerMappings_1_1VstSpeakerConfigurationHolder.html#afff27f2f2a4ee8b79c56c89480b4a777">SpeakerMappings::VstSpeakerConfigurationHolder::get()</a>, <a class="el" href="group__juce__core-containers.html#a6660424693e4edbc687fc8352a71ca92">OwnedArray&lt; MidiBuffer &gt;::indexOf()</a>, <a class="el" href="group__juce__core-containers.html#a034cad62a8ebb5854db4db2ff4afbf71">ReferenceCountedArray&lt; AudioProcessorGraph::Node &gt;::indexOf()</a>, <a class="el" href="group__juce__core-containers.html#a2b783fa66f082b890fc20d8d9c948494">OwnedArray&lt; MidiBuffer &gt;::removeObject()</a>, <a class="el" href="group__juce__dsp-processors.html#ae46879e5b0b30f52ebfc77416a17942b">FIR::Filter&lt; SampleType &gt;::reset()</a>, <a class="el" href="classAudioUnitHelpers_1_1CoreAudioBufferList.html#aa06cbf692838e38fa57a45b2b3daca00">AudioUnitHelpers::CoreAudioBufferList::reset()</a>, <a class="el" href="group__juce__audio__basics-buffers.html#a4434de94aa03d7db6d7ef06977ddf0ac">AudioBuffer&lt; float &gt;::setSize()</a>, <a class="el" href="group__juce__core-containers.html#a51248166d0e546e8f6ba9f831a835a7a">ReferenceCountedArray&lt; AudioProcessorGraph::Node &gt;::sort()</a>, and <a class="el" href="group__juce__core-containers.html#a04a21a831320e2ce76bee8ad881e1d90">OwnedArray&lt; MidiBuffer &gt;::sort()</a>.</p>

</div>
</div>
<a class="anchor" id="a912268a681322c1234753bd580bf1f89"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator void * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a void pointer to the allocated data. </p>
<p>This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="group__juce__core-memory.html#a8ec3fb69997d6f530d60cb5e0969f97f" title="Frees any currently-allocated data. ">free()</a> method. </p>

</div>
</div>
<a class="anchor" id="af51c07aad68df37e185d1f452a5ace97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator const void * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a void pointer to the allocated data. </p>
<p>This may be a null pointer if the data hasn't yet been allocated, or if it has been freed by calling the <a class="el" href="group__juce__core-memory.html#a8ec3fb69997d6f530d60cb5e0969f97f" title="Frees any currently-allocated data. ">free()</a> method. </p>

</div>
</div>
<a class="anchor" id="ad7d495cdad2d794c5fc544e54d43caa2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType* <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lets you use indirect calls to the first element in the array. </p>
<p>Obviously this will cause problems if the array hasn't been initialised, because it'll be referencing a null pointer. </p>

</div>
</div>
<a class="anchor" id="a4fde2d780504edd9e7a33efe0c24ab9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType&amp; <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to one of the data elements. </p>
<p>Obviously there's no bounds-checking here, as this object is just a dumb pointer and has no idea of the size it currently has allocated. </p>

</div>
</div>
<a class="anchor" id="ae5769755baa56702235ecf2edc68f808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;typename IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ElementType* <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to a data element at an offset from the start of the array. </p>
<p>This is the same as doing pointer arithmetic on the raw pointer itself. </p>

</div>
</div>
<a class="anchor" id="a4e298218cf588337359db82edd07e497"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const ElementType *const&#160;</td>
          <td class="paramname"><em>otherPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the pointer with another pointer. </p>
<p>This can be handy for checking whether this is a null pointer. </p>

</div>
</div>
<a class="anchor" id="a02ba60581374bc14ffc29d208937d0ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const ElementType *const&#160;</td>
          <td class="paramname"><em>otherPointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the pointer with another pointer. </p>
<p>This can be handy for checking whether this is a null pointer. </p>

</div>
</div>
<a class="anchor" id="a1a196c4ebdb6a5ff9517e262b91894cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::malloc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>newNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>elementSize</em> = <code>sizeof&#160;(ElementType)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a specified amount of memory. </p>
<p>This uses the normal malloc to allocate an amount of memory for this object. Any previously allocated memory will be freed by this method.</p>
<p>The number of bytes allocated will be (newNumElements * elementSize). Normally you wouldn't need to specify the second parameter, but it can be handy if you need to allocate a size in bytes rather than in terms of the number of elements.</p>
<p>The data that is allocated will be freed when this object is deleted, or when you call <a class="el" href="group__juce__core-memory.html#a8ec3fb69997d6f530d60cb5e0969f97f" title="Frees any currently-allocated data. ">free()</a> or any of the allocation methods. </p>

<p>Referenced by <a class="el" href="group__juce__dsp-processors.html#ae46879e5b0b30f52ebfc77416a17942b">FIR::Filter&lt; SampleType &gt;::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="a59dc4dfb0d05906164f4362b2086cd50"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::calloc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>newNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>elementSize</em> = <code>sizeof&#160;(ElementType)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a specified amount of memory and clears it. </p>
<p>This does the same job as the <a class="el" href="group__juce__core-memory.html#a1a196c4ebdb6a5ff9517e262b91894cf" title="Allocates a specified amount of memory. ">malloc()</a> method, but clears the memory that it allocates. </p>

<p>Referenced by <a class="el" href="classAudioUnitHelpers_1_1CoreAudioBufferList.html#a7e4cd6becddb903c974fb6e643afe8b4">AudioUnitHelpers::CoreAudioBufferList::prepare()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e999ff1f7ed59dd4546596447059cc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>newNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initialiseToZero</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a specified amount of memory and optionally clears it. </p>
<p>This does the same job as either <a class="el" href="group__juce__core-memory.html#a1a196c4ebdb6a5ff9517e262b91894cf" title="Allocates a specified amount of memory. ">malloc()</a> or <a class="el" href="group__juce__core-memory.html#a59dc4dfb0d05906164f4362b2086cd50" title="Allocates a specified amount of memory and clears it. ">calloc()</a>, depending on the initialiseToZero parameter. </p>

<p>Referenced by <a class="el" href="group__juce__audio__basics-buffers.html#a4434de94aa03d7db6d7ef06977ddf0ac">AudioBuffer&lt; float &gt;::setSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a75f22feaa5bb7278e6a6234ec5d19778"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::realloc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>newNumElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>elementSize</em> = <code>sizeof&#160;(ElementType)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-allocates a specified amount of memory. </p>
<p>The semantics of this method are the same as <a class="el" href="group__juce__core-memory.html#a1a196c4ebdb6a5ff9517e262b91894cf" title="Allocates a specified amount of memory. ">malloc()</a> and <a class="el" href="group__juce__core-memory.html#a59dc4dfb0d05906164f4362b2086cd50" title="Allocates a specified amount of memory and clears it. ">calloc()</a>, but it uses <a class="el" href="group__juce__core-memory.html#a75f22feaa5bb7278e6a6234ec5d19778" title="Re-allocates a specified amount of memory. ">realloc()</a> to keep as much of the existing data as possible. </p>

<p>Referenced by <a class="el" href="group__juce__core-containers.html#a56354968cbfcf19977aae75b00768df6">ArrayAllocationBase&lt; ProgressBar *, DummyCriticalSection &gt;::setAllocatedSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ec3fb69997d6f530d60cb5e0969f97f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees any currently-allocated data. </p>
<p>This will free the data and reset this object to be a null pointer. </p>

<p>Referenced by <a class="el" href="classAudioUnitHelpers_1_1ChannelRemapper.html#a149a4f20954320f89e4e2ffd65166d3d">AudioUnitHelpers::ChannelRemapper::release()</a>, <a class="el" href="classAudioUnitHelpers_1_1CoreAudioBufferList.html#ac802ae2d716fab534a42a53313648e7d">AudioUnitHelpers::CoreAudioBufferList::release()</a>, <a class="el" href="group__juce__core-containers.html#a56354968cbfcf19977aae75b00768df6">ArrayAllocationBase&lt; ProgressBar *, DummyCriticalSection &gt;::setAllocatedSize()</a>, and <a class="el" href="group__juce__audio__basics-buffers.html#a241b1340efd9e55a752a002579021950">AudioBuffer&lt; float &gt;::setDataToReferTo()</a>.</p>

</div>
</div>
<a class="anchor" id="a7ebc384a5d3f8ccfb56229688a0a273c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<div class="memtemplate">
template&lt;bool otherBlockThrows&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::swapWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, otherBlockThrows &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this object's data with the data of another <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a>. </p>
<p>The two objects simply exchange their data pointers. </p>

<p>Referenced by <a class="el" href="group__juce__audio__basics-buffers.html#a4434de94aa03d7db6d7ef06977ddf0ac">AudioBuffer&lt; float &gt;::setSize()</a>, and <a class="el" href="group__juce__core-containers.html#a48910e0a2c0c3243c8fee9226d2d158a">ArrayAllocationBase&lt; ProgressBar *, DummyCriticalSection &gt;::swapWith()</a>.</p>

</div>
</div>
<a class="anchor" id="a658838e2b07f498b169c87c73040b509"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType, bool throwOnFailure = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classHeapBlock">HeapBlock</a>&lt; ElementType, throwOnFailure &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This fills the block with zeros, up to the number of elements specified. </p>
<p>Since the block has no way of knowing its own size, you must make sure that the number of elements you specify doesn't exceed the allocated size. </p>

<p>Referenced by <a class="el" href="classSpeakerMappings_1_1VstSpeakerConfigurationHolder.html#a2af3407c50bf7f603deaf8097068b2c0">SpeakerMappings::VstSpeakerConfigurationHolder::operator=()</a>, and <a class="el" href="group__juce__audio__basics-buffers.html#a4434de94aa03d7db6d7ef06977ddf0ac">AudioBuffer&lt; float &gt;::setSize()</a>.</p>

</div>
</div>

</div>
</div>
<a name="classLeakedObjectDetector" id="classLeakedObjectDetector"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class LeakedObjectDetector</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class OwnerClass&gt;<br/>
class LeakedObjectDetector&lt; OwnerClass &gt;</h3>

<p>Embedding an instance of this class inside another class can be used as a low-overhead way of detecting leaked instances. </p>
<p>This class keeps an internal static count of the number of instances that are active, so that when the app is shutdown and the static destructors are called, it can check whether there are any left-over instances that may have been leaked.</p>
<p>To use it, use the JUCE_LEAK_DETECTOR macro as a simple way to put one in your class declaration. Have a look through the juce codebase for examples, it's used in most of the classes. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a33b0ca6504a300f0c321e89f28512aab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a33b0ca6504a300f0c321e89f28512aab">LeakedObjectDetector</a> () noexcept</td></tr>
<tr class="separator:a33b0ca6504a300f0c321e89f28512aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab474ac40a76a5d47b39d8a68b983767f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ab474ac40a76a5d47b39d8a68b983767f">LeakedObjectDetector</a> (const <a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector</a> &amp;) noexcept</td></tr>
<tr class="separator:ab474ac40a76a5d47b39d8a68b983767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea749cb2c38ee245dabf0dd4876a023"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a8ea749cb2c38ee245dabf0dd4876a023">~LeakedObjectDetector</a> ()</td></tr>
<tr class="separator:a8ea749cb2c38ee245dabf0dd4876a023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a33b0ca6504a300f0c321e89f28512aab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OwnerClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector</a>&lt; OwnerClass &gt;::<a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab474ac40a76a5d47b39d8a68b983767f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OwnerClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector</a>&lt; OwnerClass &gt;::<a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector</a>&lt; OwnerClass &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ea749cb2c38ee245dabf0dd4876a023"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OwnerClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector</a>&lt; OwnerClass &gt;::~<a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector">LeakedObjectDetector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>References <a class="el" href="group__juce__core-system.html#ga679635952a5d2eb25f3b31398f0fcc25">DBG</a>, and <a class="el" href="group__juce__core-system.html#gadc044ce5efecbecf2f5a44cd00db67b3">jassertfalse</a>.</p>

</div>
</div>

</div>
</div>
<a name="classScopedAutoReleasePool" id="classScopedAutoReleasePool"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ScopedAutoReleasePool</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A handy C++ wrapper that creates and deletes an NSAutoreleasePool object using RAII. </p>
<p>You should use the JUCE_AUTORELEASEPOOL macro to create a local auto-release pool on the stack. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ae1be6d4b7e677b4ec8f614ec4e962ae2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae1be6d4b7e677b4ec8f614ec4e962ae2">ScopedAutoReleasePool</a> ()</td></tr>
<tr class="separator:ae1be6d4b7e677b4ec8f614ec4e962ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc870c53867716591a676ff039436d07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#adc870c53867716591a676ff039436d07">~ScopedAutoReleasePool</a> ()</td></tr>
<tr class="separator:adc870c53867716591a676ff039436d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ae1be6d4b7e677b4ec8f614ec4e962ae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScopedAutoReleasePool::ScopedAutoReleasePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adc870c53867716591a676ff039436d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ScopedAutoReleasePool::~ScopedAutoReleasePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="classMemoryBlock" id="classMemoryBlock"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class MemoryBlock</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A class to hold a resizable block of raw data. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ac01749da15e7970e88e877a4dfac07bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ac01749da15e7970e88e877a4dfac07bc">MemoryBlock</a> () noexcept</td></tr>
<tr class="memdesc:ac01749da15e7970e88e877a4dfac07bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an uninitialised block with 0 size.  <a href="#ac01749da15e7970e88e877a4dfac07bc">More...</a><br/></td></tr>
<tr class="separator:ac01749da15e7970e88e877a4dfac07bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922d11a5bf4d47cf31e224f98a9a3c79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a922d11a5bf4d47cf31e224f98a9a3c79">MemoryBlock</a> (const size_t initialSize, bool initialiseToZero=false)</td></tr>
<tr class="memdesc:a922d11a5bf4d47cf31e224f98a9a3c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memory block with a given initial size.  <a href="#a922d11a5bf4d47cf31e224f98a9a3c79">More...</a><br/></td></tr>
<tr class="separator:a922d11a5bf4d47cf31e224f98a9a3c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098894f12a8754e0f464056689c7fefe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a098894f12a8754e0f464056689c7fefe">MemoryBlock</a> (const <a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;)</td></tr>
<tr class="memdesc:a098894f12a8754e0f464056689c7fefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of another memory block.  <a href="#a098894f12a8754e0f464056689c7fefe">More...</a><br/></td></tr>
<tr class="separator:a098894f12a8754e0f464056689c7fefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa338e73761a208455554559cf3336fab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aa338e73761a208455554559cf3336fab">MemoryBlock</a> (const void *dataToInitialiseFrom, size_t sizeInBytes)</td></tr>
<tr class="memdesc:aa338e73761a208455554559cf3336fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memory block using a copy of a block of data.  <a href="#aa338e73761a208455554559cf3336fab">More...</a><br/></td></tr>
<tr class="separator:aa338e73761a208455554559cf3336fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d4a35c7a288f4333201f82ca52658b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aa6d4a35c7a288f4333201f82ca52658b">~MemoryBlock</a> () noexcept</td></tr>
<tr class="memdesc:aa6d4a35c7a288f4333201f82ca52658b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aa6d4a35c7a288f4333201f82ca52658b">More...</a><br/></td></tr>
<tr class="separator:aa6d4a35c7a288f4333201f82ca52658b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8684688e136ac2bb8491a46735577a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a0c8684688e136ac2bb8491a46735577a">operator=</a> (const <a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;)</td></tr>
<tr class="memdesc:a0c8684688e136ac2bb8491a46735577a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another memory block onto this one.  <a href="#a0c8684688e136ac2bb8491a46735577a">More...</a><br/></td></tr>
<tr class="separator:a0c8684688e136ac2bb8491a46735577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae323b3939e21add971c66c2aa45b21be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae323b3939e21add971c66c2aa45b21be">MemoryBlock</a> (<a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:ae323b3939e21add971c66c2aa45b21be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ae323b3939e21add971c66c2aa45b21be">More...</a><br/></td></tr>
<tr class="separator:ae323b3939e21add971c66c2aa45b21be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdf73f0919bc3938006ba8fe4e397be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#afcdf73f0919bc3938006ba8fe4e397be">operator=</a> (<a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&amp;) noexcept</td></tr>
<tr class="memdesc:afcdf73f0919bc3938006ba8fe4e397be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#afcdf73f0919bc3938006ba8fe4e397be">More...</a><br/></td></tr>
<tr class="separator:afcdf73f0919bc3938006ba8fe4e397be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308c24cd090e0a90752387fba08df7c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a308c24cd090e0a90752387fba08df7c3">operator==</a> (const <a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a308c24cd090e0a90752387fba08df7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two memory blocks.  <a href="#a308c24cd090e0a90752387fba08df7c3">More...</a><br/></td></tr>
<tr class="separator:a308c24cd090e0a90752387fba08df7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e5067680bd24d97e988537d93c9530"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a95e5067680bd24d97e988537d93c9530">operator!=</a> (const <a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;other) const noexcept</td></tr>
<tr class="memdesc:a95e5067680bd24d97e988537d93c9530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two memory blocks.  <a href="#a95e5067680bd24d97e988537d93c9530">More...</a><br/></td></tr>
<tr class="separator:a95e5067680bd24d97e988537d93c9530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fca2456a2660c460077d73bbc7fb226"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a5fca2456a2660c460077d73bbc7fb226">matches</a> (const void *data, size_t dataSize) const noexcept</td></tr>
<tr class="memdesc:a5fca2456a2660c460077d73bbc7fb226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the data in this <a class="el" href="group__juce__core-memory.html#classMemoryBlock" title="A class to hold a resizable block of raw data. ">MemoryBlock</a> matches the raw bytes passed-in.  <a href="#a5fca2456a2660c460077d73bbc7fb226">More...</a><br/></td></tr>
<tr class="separator:a5fca2456a2660c460077d73bbc7fb226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3473f5770e3a31357c6eeb04f9cc7e8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae3473f5770e3a31357c6eeb04f9cc7e8">getData</a> () const noexcept</td></tr>
<tr class="memdesc:ae3473f5770e3a31357c6eeb04f9cc7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a void pointer to the data.  <a href="#ae3473f5770e3a31357c6eeb04f9cc7e8">More...</a><br/></td></tr>
<tr class="separator:ae3473f5770e3a31357c6eeb04f9cc7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75cf1dc7703f2e00589d2bee9ba9de4"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ae75cf1dc7703f2e00589d2bee9ba9de4"><td class="memTemplItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae75cf1dc7703f2e00589d2bee9ba9de4">operator[]</a> (const Type offset) const noexcept</td></tr>
<tr class="memdesc:ae75cf1dc7703f2e00589d2bee9ba9de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte from the memory block.  <a href="#ae75cf1dc7703f2e00589d2bee9ba9de4">More...</a><br/></td></tr>
<tr class="separator:ae75cf1dc7703f2e00589d2bee9ba9de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a123890120ed86978830b6374739fd166"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a123890120ed86978830b6374739fd166">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a123890120ed86978830b6374739fd166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for the data.  <a href="#a123890120ed86978830b6374739fd166">More...</a><br/></td></tr>
<tr class="separator:a123890120ed86978830b6374739fd166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564a48ee18de96ff8571e1ddfff9e898"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a564a48ee18de96ff8571e1ddfff9e898">end</a> () const noexcept</td></tr>
<tr class="memdesc:a564a48ee18de96ff8571e1ddfff9e898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an end-iterator for the data.  <a href="#a564a48ee18de96ff8571e1ddfff9e898">More...</a><br/></td></tr>
<tr class="separator:a564a48ee18de96ff8571e1ddfff9e898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7192f6e8a3f06c4476ddca1fe2ed7bfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a7192f6e8a3f06c4476ddca1fe2ed7bfb">getSize</a> () const noexcept</td></tr>
<tr class="memdesc:a7192f6e8a3f06c4476ddca1fe2ed7bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the block's current allocated size, in bytes.  <a href="#a7192f6e8a3f06c4476ddca1fe2ed7bfb">More...</a><br/></td></tr>
<tr class="separator:a7192f6e8a3f06c4476ddca1fe2ed7bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447eb5fbd59a587951fe0ef8b73f2a2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a447eb5fbd59a587951fe0ef8b73f2a2f">setSize</a> (const size_t newSize, bool initialiseNewSpaceToZero=false)</td></tr>
<tr class="memdesc:a447eb5fbd59a587951fe0ef8b73f2a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the memory block.  <a href="#a447eb5fbd59a587951fe0ef8b73f2a2f">More...</a><br/></td></tr>
<tr class="separator:a447eb5fbd59a587951fe0ef8b73f2a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62cb5792aa70e8eb83d96fce1fa7a51d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a62cb5792aa70e8eb83d96fce1fa7a51d">ensureSize</a> (const size_t minimumSize, bool initialiseNewSpaceToZero=false)</td></tr>
<tr class="memdesc:a62cb5792aa70e8eb83d96fce1fa7a51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the block's size only if it's smaller than a given size.  <a href="#a62cb5792aa70e8eb83d96fce1fa7a51d">More...</a><br/></td></tr>
<tr class="separator:a62cb5792aa70e8eb83d96fce1fa7a51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c08083ae75b47186d20c7b591c56073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a6c08083ae75b47186d20c7b591c56073">reset</a> ()</td></tr>
<tr class="memdesc:a6c08083ae75b47186d20c7b591c56073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all the blocks data, setting its size to 0.  <a href="#a6c08083ae75b47186d20c7b591c56073">More...</a><br/></td></tr>
<tr class="separator:a6c08083ae75b47186d20c7b591c56073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a5b9c93434edf34464d4fd5b046df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af1a5b9c93434edf34464d4fd5b046df5">fillWith</a> (<a class="el" href="group__juce__core-maths.html#gadde6aaee8457bee49c2a92621fe22b79">uint8</a> valueToUse) noexcept</td></tr>
<tr class="memdesc:af1a5b9c93434edf34464d4fd5b046df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the entire memory block with a repeated byte value.  <a href="#af1a5b9c93434edf34464d4fd5b046df5">More...</a><br/></td></tr>
<tr class="separator:af1a5b9c93434edf34464d4fd5b046df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54e9ebd64519e0b5e67ebc483a26200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af54e9ebd64519e0b5e67ebc483a26200">append</a> (const void *data, size_t numBytes)</td></tr>
<tr class="memdesc:af54e9ebd64519e0b5e67ebc483a26200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another block of data to the end of this one.  <a href="#af54e9ebd64519e0b5e67ebc483a26200">More...</a><br/></td></tr>
<tr class="separator:af54e9ebd64519e0b5e67ebc483a26200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad396877d63f2a45095535895a9b5071f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ad396877d63f2a45095535895a9b5071f">replaceWith</a> (const void *data, size_t numBytes)</td></tr>
<tr class="memdesc:ad396877d63f2a45095535895a9b5071f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this block to the given size and fills its contents from the supplied buffer.  <a href="#ad396877d63f2a45095535895a9b5071f">More...</a><br/></td></tr>
<tr class="separator:ad396877d63f2a45095535895a9b5071f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c3c4addd27e9c7a9adfbc0466080e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af5c3c4addd27e9c7a9adfbc0466080e2">insert</a> (const void *dataToInsert, size_t numBytesToInsert, size_t insertPosition)</td></tr>
<tr class="memdesc:af5c3c4addd27e9c7a9adfbc0466080e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts some data into the block.  <a href="#af5c3c4addd27e9c7a9adfbc0466080e2">More...</a><br/></td></tr>
<tr class="separator:af5c3c4addd27e9c7a9adfbc0466080e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb654675288d40483f9150ffd38e16a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a7fb654675288d40483f9150ffd38e16a">removeSection</a> (size_t startByte, size_t numBytesToRemove)</td></tr>
<tr class="memdesc:a7fb654675288d40483f9150ffd38e16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chops out a section of the block.  <a href="#a7fb654675288d40483f9150ffd38e16a">More...</a><br/></td></tr>
<tr class="separator:a7fb654675288d40483f9150ffd38e16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d3f1d7a0269229c5f0c36ab0b9dc40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a31d3f1d7a0269229c5f0c36ab0b9dc40">copyFrom</a> (const void *srcData, int destinationOffset, size_t numBytes) noexcept</td></tr>
<tr class="memdesc:a31d3f1d7a0269229c5f0c36ab0b9dc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data into this <a class="el" href="group__juce__core-memory.html#classMemoryBlock" title="A class to hold a resizable block of raw data. ">MemoryBlock</a> from a memory address.  <a href="#a31d3f1d7a0269229c5f0c36ab0b9dc40">More...</a><br/></td></tr>
<tr class="separator:a31d3f1d7a0269229c5f0c36ab0b9dc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacda2afa6101956c2c66ebca93c42c36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aacda2afa6101956c2c66ebca93c42c36">copyTo</a> (void *destData, int sourceOffset, size_t numBytes) const noexcept</td></tr>
<tr class="memdesc:aacda2afa6101956c2c66ebca93c42c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from this <a class="el" href="group__juce__core-memory.html#classMemoryBlock" title="A class to hold a resizable block of raw data. ">MemoryBlock</a> to a memory address.  <a href="#aacda2afa6101956c2c66ebca93c42c36">More...</a><br/></td></tr>
<tr class="separator:aacda2afa6101956c2c66ebca93c42c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfd6e1987101fb2903bd6988933f8ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a9cfd6e1987101fb2903bd6988933f8ce">swapWith</a> (<a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a9cfd6e1987101fb2903bd6988933f8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of this and another memory block.  <a href="#a9cfd6e1987101fb2903bd6988933f8ce">More...</a><br/></td></tr>
<tr class="separator:a9cfd6e1987101fb2903bd6988933f8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1624f3d46df7c3568c81d08b9c62346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-text.html#classString">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ab1624f3d46df7c3568c81d08b9c62346">toString</a> () const </td></tr>
<tr class="memdesc:ab1624f3d46df7c3568c81d08b9c62346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to parse the contents of the block as a zero-terminated UTF8 string.  <a href="#ab1624f3d46df7c3568c81d08b9c62346">More...</a><br/></td></tr>
<tr class="separator:ab1624f3d46df7c3568c81d08b9c62346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8440655ca6913fe607b44c6169af2273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a8440655ca6913fe607b44c6169af2273">loadFromHexString</a> (<a class="el" href="group__juce__core-text.html#classStringRef">StringRef</a> sourceHexString)</td></tr>
<tr class="memdesc:a8440655ca6913fe607b44c6169af2273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string of hexadecimal numbers and writes this data into the memory block.  <a href="#a8440655ca6913fe607b44c6169af2273">More...</a><br/></td></tr>
<tr class="separator:a8440655ca6913fe607b44c6169af2273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c473a086ecae12702ef5094c4c06fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af3c473a086ecae12702ef5094c4c06fa">setBitRange</a> (size_t bitRangeStart, size_t numBits, int binaryNumberToApply) noexcept</td></tr>
<tr class="memdesc:af3c473a086ecae12702ef5094c4c06fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a number of bits in the memory block, treating it as a long binary sequence.  <a href="#af3c473a086ecae12702ef5094c4c06fa">More...</a><br/></td></tr>
<tr class="separator:af3c473a086ecae12702ef5094c4c06fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd81e1ac31bef25bbb2f4dc5a6865a15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#afd81e1ac31bef25bbb2f4dc5a6865a15">getBitRange</a> (size_t bitRangeStart, size_t numBitsToRead) const noexcept</td></tr>
<tr class="memdesc:afd81e1ac31bef25bbb2f4dc5a6865a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number of bits from the memory block, treating it as one long binary sequence.  <a href="#afd81e1ac31bef25bbb2f4dc5a6865a15">More...</a><br/></td></tr>
<tr class="separator:afd81e1ac31bef25bbb2f4dc5a6865a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69724db38afce62092e39171edc77fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-text.html#classString">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a69724db38afce62092e39171edc77fea">toBase64Encoding</a> () const </td></tr>
<tr class="memdesc:a69724db38afce62092e39171edc77fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string of characters in a JUCE-specific text encoding that represents the binary contents of this block.  <a href="#a69724db38afce62092e39171edc77fea">More...</a><br/></td></tr>
<tr class="separator:a69724db38afce62092e39171edc77fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b274b678bd4bdbfb64fec6c1c35e58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae9b274b678bd4bdbfb64fec6c1c35e58">fromBase64Encoding</a> (<a class="el" href="group__juce__core-text.html#classStringRef">StringRef</a> encodedString)</td></tr>
<tr class="memdesc:ae9b274b678bd4bdbfb64fec6c1c35e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a string created by <a class="el" href="group__juce__core-memory.html#a69724db38afce62092e39171edc77fea" title="Returns a string of characters in a JUCE-specific text encoding that represents the binary contents o...">MemoryBlock::toBase64Encoding()</a> and extracts the original data.  <a href="#ae9b274b678bd4bdbfb64fec6c1c35e58">More...</a><br/></td></tr>
<tr class="separator:ae9b274b678bd4bdbfb64fec6c1c35e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ac01749da15e7970e88e877a4dfac07bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemoryBlock::MemoryBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an uninitialised block with 0 size. </p>

</div>
</div>
<a class="anchor" id="a922d11a5bf4d47cf31e224f98a9a3c79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemoryBlock::MemoryBlock </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initialiseToZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memory block with a given initial size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialSize</td><td>the size of block to create </td></tr>
    <tr><td class="paramname">initialiseToZero</td><td>whether to clear the memory or just leave it uninitialised </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a098894f12a8754e0f464056689c7fefe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemoryBlock::MemoryBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of another memory block. </p>

</div>
</div>
<a class="anchor" id="aa338e73761a208455554559cf3336fab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemoryBlock::MemoryBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataToInitialiseFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeInBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memory block using a copy of a block of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToInitialiseFrom</td><td>some data to copy into this block </td></tr>
    <tr><td class="paramname">sizeInBytes</td><td>how much space to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6d4a35c7a288f4333201f82ca52658b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemoryBlock::~MemoryBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="ae323b3939e21add971c66c2aa45b21be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemoryBlock::MemoryBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a0c8684688e136ac2bb8491a46735577a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a>&amp; MemoryBlock::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies another memory block onto this one. </p>
<p>This block will be resized and copied to exactly match the other one. </p>

</div>
</div>
<a class="anchor" id="afcdf73f0919bc3938006ba8fe4e397be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a>&amp; MemoryBlock::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a class="anchor" id="a308c24cd090e0a90752387fba08df7c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MemoryBlock::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two memory blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>true only if the two blocks are the same size and have identical contents. </dd></dl>

</div>
</div>
<a class="anchor" id="a95e5067680bd24d97e988537d93c9530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MemoryBlock::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two memory blocks. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the two blocks are different sizes or have different contents. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fca2456a2660c460077d73bbc7fb226"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MemoryBlock::matches </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the data in this <a class="el" href="group__juce__core-memory.html#classMemoryBlock" title="A class to hold a resizable block of raw data. ">MemoryBlock</a> matches the raw bytes passed-in. </p>

</div>
</div>
<a class="anchor" id="ae3473f5770e3a31357c6eeb04f9cc7e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* MemoryBlock::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a void pointer to the data. </p>
<p>Note that the pointer returned will probably become invalid when the block is resized. </p>

<p>Referenced by <a class="el" href="group__juce__audio__plugin__client-Standalone.html#ab55d4cd652306a2a344be38464a48358">StandalonePluginHolder::askUserToLoadState()</a>, <a class="el" href="group__juce__audio__plugin__client-Standalone.html#ac28981bbac45dbae6c1fdf617a824c17">StandalonePluginHolder::askUserToSaveState()</a>, and <a class="el" href="group__juce__audio__plugin__client-Standalone.html#adfdf093b9b5ab101d2f76d5fa957c6eb">StandalonePluginHolder::reloadPluginState()</a>.</p>

</div>
</div>
<a class="anchor" id="ae75cf1dc7703f2e00589d2bee9ba9de4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; MemoryBlock::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Type&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a byte from the memory block. </p>
<p>This returns a reference, so you can also use it to set a byte. </p>

</div>
</div>
<a class="anchor" id="a123890120ed86978830b6374739fd166"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* MemoryBlock::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator for the data. </p>

</div>
</div>
<a class="anchor" id="a564a48ee18de96ff8571e1ddfff9e898"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* MemoryBlock::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an end-iterator for the data. </p>

</div>
</div>
<a class="anchor" id="a7192f6e8a3f06c4476ddca1fe2ed7bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MemoryBlock::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the block's current allocated size, in bytes. </p>

<p>Referenced by <a class="el" href="group__juce__audio__plugin__client-Standalone.html#ab55d4cd652306a2a344be38464a48358">StandalonePluginHolder::askUserToLoadState()</a>, <a class="el" href="group__juce__audio__plugin__client-Standalone.html#ac28981bbac45dbae6c1fdf617a824c17">StandalonePluginHolder::askUserToSaveState()</a>, and <a class="el" href="group__juce__audio__plugin__client-Standalone.html#adfdf093b9b5ab101d2f76d5fa957c6eb">StandalonePluginHolder::reloadPluginState()</a>.</p>

</div>
</div>
<a class="anchor" id="a447eb5fbd59a587951fe0ef8b73f2a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::setSize </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initialiseNewSpaceToZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the memory block. </p>
<p>Any data that is present in both the old and new sizes will be retained. When enlarging the block, the new space that is allocated at the end can either be cleared, or left uninitialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>the new desired size for the block </td></tr>
    <tr><td class="paramname">initialiseNewSpaceToZero</td><td>if the block gets enlarged, this determines whether to clear the new section or just leave it uninitialised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#a62cb5792aa70e8eb83d96fce1fa7a51d" title="Increases the block&#39;s size only if it&#39;s smaller than a given size. ">ensureSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a62cb5792aa70e8eb83d96fce1fa7a51d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::ensureSize </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>minimumSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initialiseNewSpaceToZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increases the block's size only if it's smaller than a given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minimumSize</td><td>if the block is already bigger than this size, no action will be taken; otherwise it will be increased to this size </td></tr>
    <tr><td class="paramname">initialiseNewSpaceToZero</td><td>if the block gets enlarged, this determines whether to clear the new section or just leave it uninitialised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#a447eb5fbd59a587951fe0ef8b73f2a2f" title="Resizes the memory block. ">setSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6c08083ae75b47186d20c7b591c56073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees all the blocks data, setting its size to 0. </p>

</div>
</div>
<a class="anchor" id="af1a5b9c93434edf34464d4fd5b046df5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::fillWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#gadde6aaee8457bee49c2a92621fe22b79">uint8</a>&#160;</td>
          <td class="paramname"><em>valueToUse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the entire memory block with a repeated byte value. </p>
<p>This is handy for clearing a block of memory to zero. </p>

</div>
</div>
<a class="anchor" id="af54e9ebd64519e0b5e67ebc483a26200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::append </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds another block of data to the end of this one. </p>
<p>The data pointer must not be null. This block's size will be increased accordingly. </p>

</div>
</div>
<a class="anchor" id="ad396877d63f2a45095535895a9b5071f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::replaceWith </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes this block to the given size and fills its contents from the supplied buffer. </p>
<p>The data pointer must not be null. </p>

</div>
</div>
<a class="anchor" id="af5c3c4addd27e9c7a9adfbc0466080e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::insert </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>dataToInsert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytesToInsert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>insertPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts some data into the block. </p>
<p>The dataToInsert pointer must not be null. This block's size will be increased accordingly. If the insert position lies outside the valid range of the block, it will be clipped to within the range before being used. </p>

</div>
</div>
<a class="anchor" id="a7fb654675288d40483f9150ffd38e16a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::removeSection </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startByte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytesToRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chops out a section of the block. </p>
<p>This will remove a section of the memory block and close the gap around it, shifting any subsequent data downwards and reducing the size of the block.</p>
<p>If the range specified goes beyond the size of the block, it will be clipped. </p>

</div>
</div>
<a class="anchor" id="a31d3f1d7a0269229c5f0c36ab0b9dc40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::copyFrom </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>srcData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destinationOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data into this <a class="el" href="group__juce__core-memory.html#classMemoryBlock" title="A class to hold a resizable block of raw data. ">MemoryBlock</a> from a memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcData</td><td>the memory location of the data to copy into this block </td></tr>
    <tr><td class="paramname">destinationOffset</td><td>the offset in this block at which the data being copied should begin </td></tr>
    <tr><td class="paramname">numBytes</td><td>how much to copy in (if this goes beyond the size of the memory block, it will be clipped so not to do anything nasty) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacda2afa6101956c2c66ebca93c42c36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::copyTo </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sourceOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from this <a class="el" href="group__juce__core-memory.html#classMemoryBlock" title="A class to hold a resizable block of raw data. ">MemoryBlock</a> to a memory address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destData</td><td>the memory location to write to </td></tr>
    <tr><td class="paramname">sourceOffset</td><td>the offset within this block from which the copied data will be read </td></tr>
    <tr><td class="paramname">numBytes</td><td>how much to copy (if this extends beyond the limits of the memory block, zeros will be used for that portion of the data) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cfd6e1987101fb2903bd6988933f8ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::swapWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classMemoryBlock">MemoryBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of this and another memory block. </p>
<p>No actual copying is required for this, so it's very fast. </p>

</div>
</div>
<a class="anchor" id="ab1624f3d46df7c3568c81d08b9c62346"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-text.html#classString">String</a> MemoryBlock::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to parse the contents of the block as a zero-terminated UTF8 string. </p>

</div>
</div>
<a class="anchor" id="a8440655ca6913fe607b44c6169af2273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::loadFromHexString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-text.html#classStringRef">StringRef</a>&#160;</td>
          <td class="paramname"><em>sourceHexString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a string of hexadecimal numbers and writes this data into the memory block. </p>
<p>The block will be resized to the number of valid bytes read from the string. Non-hex characters in the string will be ignored.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-text.html#aab501daf0fa0bbba1479218447d1f936" title="Returns a string representing this numeric value in hexadecimal. ">String::toHexString()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af3c473a086ecae12702ef5094c4c06fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryBlock::setBitRange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitRangeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>binaryNumberToApply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a number of bits in the memory block, treating it as a long binary sequence. </p>

</div>
</div>
<a class="anchor" id="afd81e1ac31bef25bbb2f4dc5a6865a15"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MemoryBlock::getBitRange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bitRangeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBitsToRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a number of bits from the memory block, treating it as one long binary sequence. </p>

</div>
</div>
<a class="anchor" id="a69724db38afce62092e39171edc77fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-text.html#classString">String</a> MemoryBlock::toBase64Encoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string of characters in a JUCE-specific text encoding that represents the binary contents of this block. </p>
<p>This uses a JUCE-specific (i.e. not standard!) 64-bit encoding system to convert binary data into a string of ASCII characters for purposes like storage in XML. Note that this proprietary format is mainly kept here for backwards-compatibility, and you may prefer to use the <a class="el" href="group__juce__core-text.html#a810999461ee28244f7b7c1cd709132c4" title="Converts a block of binary data to a base-64 string. ">Base64::toBase64()</a> method if you want to use the standard base-64 encoding.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#ae9b274b678bd4bdbfb64fec6c1c35e58" title="Takes a string created by MemoryBlock::toBase64Encoding() and extracts the original data...">fromBase64Encoding</a>, <a class="el" href="group__juce__core-text.html#a810999461ee28244f7b7c1cd709132c4" title="Converts a block of binary data to a base-64 string. ">Base64::toBase64</a>, <a class="el" href="group__juce__core-text.html#a69ae397d3f61cd0299811b984b871ae2" title="Converts a binary block of data into a base-64 string. ">Base64::convertToBase64</a> </dd></dl>

<p>Referenced by <a class="el" href="group__juce__audio__plugin__client-Standalone.html#a9319c6c7e9368f0d2fb1d31b0f2b2816">StandalonePluginHolder::savePluginState()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9b274b678bd4bdbfb64fec6c1c35e58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemoryBlock::fromBase64Encoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-text.html#classStringRef">StringRef</a>&#160;</td>
          <td class="paramname"><em>encodedString</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a string created by <a class="el" href="group__juce__core-memory.html#a69724db38afce62092e39171edc77fea" title="Returns a string of characters in a JUCE-specific text encoding that represents the binary contents o...">MemoryBlock::toBase64Encoding()</a> and extracts the original data. </p>
<p>The string passed in must have been created by to64BitEncoding(), and this block will be resized to recreate the original data block.</p>
<p>Note that these methods use a JUCE-specific (i.e. not standard!) 64-bit encoding system. You may prefer to use the <a class="el" href="group__juce__core-text.html#a1d31c080284840a2c23ee41175e882ea" title="Converts a base-64 string back to its binary representation. ">Base64::convertFromBase64()</a> method if you want to use the standard base-64 encoding.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#a69724db38afce62092e39171edc77fea" title="Returns a string of characters in a JUCE-specific text encoding that represents the binary contents o...">toBase64Encoding</a>, <a class="el" href="group__juce__core-text.html#a1d31c080284840a2c23ee41175e882ea" title="Converts a base-64 string back to its binary representation. ">Base64::convertFromBase64</a> </dd></dl>

<p>Referenced by <a class="el" href="group__juce__audio__plugin__client-Standalone.html#adfdf093b9b5ab101d2f76d5fa957c6eb">StandalonePluginHolder::reloadPluginState()</a>.</p>

</div>
</div>

</div>
</div>
<a name="classOptionalScopedPointer" id="classOptionalScopedPointer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class OptionalScopedPointer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ObjectType&gt;<br/>
class OptionalScopedPointer&lt; ObjectType &gt;</h3>

<p>Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope. </p>
<p>This acts in many ways like a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, but allows you to specify whether or not the object is deleted.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a8b96c6f59b68c8fe8880bc986fe90458"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a8b96c6f59b68c8fe8880bc986fe90458">OptionalScopedPointer</a> ()</td></tr>
<tr class="memdesc:a8b96c6f59b68c8fe8880bc986fe90458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a>.  <a href="#a8b96c6f59b68c8fe8880bc986fe90458">More...</a><br/></td></tr>
<tr class="separator:a8b96c6f59b68c8fe8880bc986fe90458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea2cd6ce97953c223ac0ab3789f9127"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a3ea2cd6ce97953c223ac0ab3789f9127">OptionalScopedPointer</a> (ObjectType *objectToHold, bool takeOwnership)</td></tr>
<tr class="memdesc:a3ea2cd6ce97953c223ac0ab3789f9127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> to point to a given object, and specifying whether the <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> will delete it.  <a href="#a3ea2cd6ce97953c223ac0ab3789f9127">More...</a><br/></td></tr>
<tr class="separator:a3ea2cd6ce97953c223ac0ab3789f9127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0f0be46c674d4b4082ed6c56ad41d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a3c0f0be46c674d4b4082ed6c56ad41d8">OptionalScopedPointer</a> (<a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a> &amp;objectToTransferFrom)</td></tr>
<tr class="memdesc:a3c0f0be46c674d4b4082ed6c56ad41d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of the object that another <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> holds.  <a href="#a3c0f0be46c674d4b4082ed6c56ad41d8">More...</a><br/></td></tr>
<tr class="separator:a3c0f0be46c674d4b4082ed6c56ad41d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f773129ee4e44990551b34faf5d0dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a8f773129ee4e44990551b34faf5d0dd5">operator=</a> (<a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a> &amp;objectToTransferFrom)</td></tr>
<tr class="memdesc:a8f773129ee4e44990551b34faf5d0dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of the object that another <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> holds.  <a href="#a8f773129ee4e44990551b34faf5d0dd5">More...</a><br/></td></tr>
<tr class="separator:a8f773129ee4e44990551b34faf5d0dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0508d3dc7dd9603e001cb72191ad56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a0e0508d3dc7dd9603e001cb72191ad56">~OptionalScopedPointer</a> ()</td></tr>
<tr class="memdesc:a0e0508d3dc7dd9603e001cb72191ad56"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor may or may not delete the object that is being held, depending on the takeOwnership flag that was specified when the object was first passed into an <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> constructor.  <a href="#a0e0508d3dc7dd9603e001cb72191ad56">More...</a><br/></td></tr>
<tr class="separator:a0e0508d3dc7dd9603e001cb72191ad56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f1f538ffab217fabca41e5271593cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a45f1f538ffab217fabca41e5271593cc">operator ObjectType *</a> () const noexcept</td></tr>
<tr class="memdesc:a45f1f538ffab217fabca41e5271593cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer is managing.  <a href="#a45f1f538ffab217fabca41e5271593cc">More...</a><br/></td></tr>
<tr class="separator:a45f1f538ffab217fabca41e5271593cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0424e95b5edea332aadada60cb1296ed"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a0424e95b5edea332aadada60cb1296ed">get</a> () const noexcept</td></tr>
<tr class="memdesc:a0424e95b5edea332aadada60cb1296ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer is managing.  <a href="#a0424e95b5edea332aadada60cb1296ed">More...</a><br/></td></tr>
<tr class="separator:a0424e95b5edea332aadada60cb1296ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d540a292b283a1c72cba4e59d11a19"><td class="memItemLeft" align="right" valign="top">ObjectType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af1d540a292b283a1c72cba4e59d11a19">operator*</a> () const noexcept</td></tr>
<tr class="memdesc:af1d540a292b283a1c72cba4e59d11a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer is managing.  <a href="#af1d540a292b283a1c72cba4e59d11a19">More...</a><br/></td></tr>
<tr class="separator:af1d540a292b283a1c72cba4e59d11a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f713a23c5a7c8ee6d668109441d0d09"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a0f713a23c5a7c8ee6d668109441d0d09">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a0f713a23c5a7c8ee6d668109441d0d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you access methods and properties of the object that this pointer is holding.  <a href="#a0f713a23c5a7c8ee6d668109441d0d09">More...</a><br/></td></tr>
<tr class="separator:a0f713a23c5a7c8ee6d668109441d0d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf99bfb609b72988d875d1091af6cb42"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#acf99bfb609b72988d875d1091af6cb42">release</a> () noexcept</td></tr>
<tr class="memdesc:acf99bfb609b72988d875d1091af6cb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the current object from this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> without deleting it.  <a href="#acf99bfb609b72988d875d1091af6cb42">More...</a><br/></td></tr>
<tr class="separator:acf99bfb609b72988d875d1091af6cb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30fe3a7e3ff51f427056ab155dbafd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae30fe3a7e3ff51f427056ab155dbafd0">clear</a> ()</td></tr>
<tr class="memdesc:ae30fe3a7e3ff51f427056ab155dbafd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets this pointer to null, possibly deleting the object that it holds, if it has ownership of it.  <a href="#ae30fe3a7e3ff51f427056ab155dbafd0">More...</a><br/></td></tr>
<tr class="separator:ae30fe3a7e3ff51f427056ab155dbafd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae526986fb0292d7b3623687e52b96fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae526986fb0292d7b3623687e52b96fb7">set</a> (ObjectType *newObject, bool takeOwnership)</td></tr>
<tr class="memdesc:ae526986fb0292d7b3623687e52b96fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> point at a new object, specifying whether the <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> will take ownership of the object.  <a href="#ae526986fb0292d7b3623687e52b96fb7">More...</a><br/></td></tr>
<tr class="separator:ae526986fb0292d7b3623687e52b96fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d17e536c3584231f3ded73499cf09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a44d17e536c3584231f3ded73499cf09b">setOwned</a> (ObjectType *newObject)</td></tr>
<tr class="memdesc:a44d17e536c3584231f3ded73499cf09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> point at a new object, and take ownership of that object.  <a href="#a44d17e536c3584231f3ded73499cf09b">More...</a><br/></td></tr>
<tr class="separator:a44d17e536c3584231f3ded73499cf09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad002438efbea088d4114470c78cf77da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ad002438efbea088d4114470c78cf77da">setNonOwned</a> (ObjectType *newObject)</td></tr>
<tr class="memdesc:ad002438efbea088d4114470c78cf77da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> point at a new object, but will not take ownership of that object.  <a href="#ad002438efbea088d4114470c78cf77da">More...</a><br/></td></tr>
<tr class="separator:ad002438efbea088d4114470c78cf77da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb696aae75b039bc1309dc7125bda7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a0eb696aae75b039bc1309dc7125bda7a">willDeleteObject</a> () const noexcept</td></tr>
<tr class="memdesc:a0eb696aae75b039bc1309dc7125bda7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the target object will be deleted when this pointer object is deleted.  <a href="#a0eb696aae75b039bc1309dc7125bda7a">More...</a><br/></td></tr>
<tr class="separator:a0eb696aae75b039bc1309dc7125bda7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378381bc4cb56b452de6eb198a796fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a378381bc4cb56b452de6eb198a796fbb">swapWith</a> (<a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a378381bc4cb56b452de6eb198a796fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this object with another <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a>.  <a href="#a378381bc4cb56b452de6eb198a796fbb">More...</a><br/></td></tr>
<tr class="separator:a378381bc4cb56b452de6eb198a796fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a8b96c6f59b68c8fe8880bc986fe90458"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an empty <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a>. </p>

</div>
</div>
<a class="anchor" id="a3ea2cd6ce97953c223ac0ab3789f9127"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a> </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&#160;</td>
          <td class="paramname"><em>objectToHold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>takeOwnership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> to point to a given object, and specifying whether the <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> will delete it. </p>
<p>If takeOwnership is true, then the <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> will act like a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, deleting the object when it is itself deleted. If this parameter is false, then the <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> just holds a normal pointer to the object, and won't delete it. </p>

</div>
</div>
<a class="anchor" id="a3c0f0be46c674d4b4082ed6c56ad41d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt; &amp;&#160;</td>
          <td class="paramname"><em>objectToTransferFrom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes ownership of the object that another <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> holds. </p>
<p>Like a normal <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, the objectToTransferFrom object will become null, as ownership of the managed object is transferred to this object.</p>
<p>The flag to indicate whether or not to delete the managed object is also copied from the source object. </p>

</div>
</div>
<a class="anchor" id="a0e0508d3dc7dd9603e001cb72191ad56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::~<a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The destructor may or may not delete the object that is being held, depending on the takeOwnership flag that was specified when the object was first passed into an <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> constructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a8f773129ee4e44990551b34faf5d0dd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&amp; <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt; &amp;&#160;</td>
          <td class="paramname"><em>objectToTransferFrom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes ownership of the object that another <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> holds. </p>
<p>Like a normal <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, the objectToTransferFrom object will become null, as ownership of the managed object is transferred to this object.</p>
<p>The ownership flag that says whether or not to delete the managed object is also copied from the source object. </p>

</div>
</div>
<a class="anchor" id="a45f1f538ffab217fabca41e5271593cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::operator ObjectType * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer is managing. </p>

</div>
</div>
<a class="anchor" id="a0424e95b5edea332aadada60cb1296ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer is managing. </p>

<p>Referenced by <a class="el" href="group__juce__audio__plugin__client-Standalone.html#a7fcc3628b8e48d4f0a72fa268a86046f">StandaloneFilterWindow::resetToDefaultState()</a>, <a class="el" href="group__juce__audio__plugin__client-Standalone.html#a6031a5b2f6b2f041f7ca8de3343eec7a">StandaloneFilterWindow::StandaloneFilterWindow()</a>, and <a class="el" href="group__juce__audio__plugin__client-Standalone.html#aae64328faa7f0aa4ccc0099ebf4e84d8">StandaloneFilterWindow::~StandaloneFilterWindow()</a>.</p>

</div>
</div>
<a class="anchor" id="af1d540a292b283a1c72cba4e59d11a19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType&amp; <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer is managing. </p>

</div>
</div>
<a class="anchor" id="a0f713a23c5a7c8ee6d668109441d0d09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lets you access methods and properties of the object that this pointer is holding. </p>

</div>
</div>
<a class="anchor" id="acf99bfb609b72988d875d1091af6cb42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the current object from this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> without deleting it. </p>
<p>This will return the current object, and set this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> to a null pointer. </p>

</div>
</div>
<a class="anchor" id="ae30fe3a7e3ff51f427056ab155dbafd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets this pointer to null, possibly deleting the object that it holds, if it has ownership of it. </p>

<p>Referenced by <a class="el" href="group__juce__core-memory.html#a8f773129ee4e44990551b34faf5d0dd5">OptionalScopedPointer&lt; OutputStream &gt;::operator=()</a>, <a class="el" href="group__juce__core-memory.html#ae526986fb0292d7b3623687e52b96fb7">OptionalScopedPointer&lt; OutputStream &gt;::set()</a>, and <a class="el" href="group__juce__core-memory.html#a0e0508d3dc7dd9603e001cb72191ad56">OptionalScopedPointer&lt; OutputStream &gt;::~OptionalScopedPointer()</a>.</p>

</div>
</div>
<a class="anchor" id="ae526986fb0292d7b3623687e52b96fb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::set </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&#160;</td>
          <td class="paramname"><em>newObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>takeOwnership</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> point at a new object, specifying whether the <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> will take ownership of the object. </p>
<p>If takeOwnership is true, then the <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> will act like a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, deleting the object when it is itself deleted. If this parameter is false, then the <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> just holds a normal pointer to the object, and won't delete it. </p>

<p>Referenced by <a class="el" href="group__juce__core-memory.html#ad002438efbea088d4114470c78cf77da">OptionalScopedPointer&lt; OutputStream &gt;::setNonOwned()</a>, and <a class="el" href="group__juce__core-memory.html#a44d17e536c3584231f3ded73499cf09b">OptionalScopedPointer&lt; OutputStream &gt;::setOwned()</a>.</p>

</div>
</div>
<a class="anchor" id="a44d17e536c3584231f3ded73499cf09b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::setOwned </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&#160;</td>
          <td class="paramname"><em>newObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> point at a new object, and take ownership of that object. </p>

<p>Referenced by <a class="el" href="group__juce__audio__plugin__client-Standalone.html#a5e24139925518f20b67a3d6f74bfb00c">StandalonePluginHolder::showAudioSettingsDialog()</a>.</p>

</div>
</div>
<a class="anchor" id="ad002438efbea088d4114470c78cf77da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::setNonOwned </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&#160;</td>
          <td class="paramname"><em>newObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes this <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a> point at a new object, but will not take ownership of that object. </p>

</div>
</div>
<a class="anchor" id="a0eb696aae75b039bc1309dc7125bda7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::willDeleteObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the target object will be deleted when this pointer object is deleted. </p>

</div>
</div>
<a class="anchor" id="a378381bc4cb56b452de6eb198a796fbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt;::swapWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer">OptionalScopedPointer</a>&lt; ObjectType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this object with another <a class="el" href="group__juce__core-memory.html#classOptionalScopedPointer" title="Holds a pointer to an object which can optionally be deleted when this pointer goes out of scope...">OptionalScopedPointer</a>. </p>
<p>The two objects simply exchange their states. </p>

</div>
</div>

</div>
</div>
<a name="classReferenceCountedObject" id="classReferenceCountedObject"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ReferenceCountedObject</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>A base class which provides methods for reference-counting. </p>
<p>To add reference-counting to a class, derive it from this class, and use the <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr" title="A smart-pointer class which points to a reference-counted object. ">ReferenceCountedObjectPtr</a> class to point to it.</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass : <span class="keyword">public</span> <a class="code" href="group__juce__core-memory.html#classReferenceCountedObject">ReferenceCountedObject</a></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> foo();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This is a neat way of declaring a typedef for a pointer class,</span></div>
<div class="line">    <span class="comment">// rather than typing out the full templated name each time..</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr&lt;MyClass&gt;</a> Ptr;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">MyClass::Ptr p = <span class="keyword">new</span> MyClass();</div>
<div class="line">MyClass::Ptr p2 = p;</div>
<div class="line">p = <span class="keyword">nullptr</span>;</div>
<div class="line">p2-&gt;foo();</div>
</div><!-- fragment --><p>Once a new <a class="el" href="group__juce__core-memory.html#classReferenceCountedObject" title="A base class which provides methods for reference-counting. ">ReferenceCountedObject</a> has been assigned to a pointer, be careful not to delete the object manually.</p>
<p>This class uses an <a class="el" href="group__juce__core-memory.html">Atomic&lt;int&gt;</a> value to hold the reference count, so that it the pointers can be passed between threads safely. For a faster but non-thread-safe version, use <a class="el" href="group__juce__core-memory.html#classSingleThreadedReferenceCountedObject" title="Adds reference-counting to an object. ">SingleThreadedReferenceCountedObject</a> instead.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr" title="A smart-pointer class which points to a reference-counted object. ">ReferenceCountedObjectPtr</a>, <a class="el" href="group__juce__core-containers.html#classReferenceCountedArray" title="Holds a list of objects derived from ReferenceCountedObject, or which implement basic reference-count...">ReferenceCountedArray</a>, <a class="el" href="group__juce__core-memory.html#classSingleThreadedReferenceCountedObject" title="Adds reference-counting to an object. ">SingleThreadedReferenceCountedObject</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for ReferenceCountedObject:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classReferenceCountedObject__inherit__graph.svg" width="694" height="430"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a878ca594f89f757d29af5a42ee51161f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a878ca594f89f757d29af5a42ee51161f">incReferenceCount</a> () noexcept</td></tr>
<tr class="memdesc:a878ca594f89f757d29af5a42ee51161f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the object's reference count.  <a href="#a878ca594f89f757d29af5a42ee51161f">More...</a><br/></td></tr>
<tr class="separator:a878ca594f89f757d29af5a42ee51161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523f06d996130f24b36996b28b83d802"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a523f06d996130f24b36996b28b83d802">decReferenceCount</a> () noexcept</td></tr>
<tr class="memdesc:a523f06d996130f24b36996b28b83d802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the object's reference count.  <a href="#a523f06d996130f24b36996b28b83d802">More...</a><br/></td></tr>
<tr class="separator:a523f06d996130f24b36996b28b83d802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2355316960a6bf2e9691fded43249254"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a2355316960a6bf2e9691fded43249254">decReferenceCountWithoutDeleting</a> () noexcept</td></tr>
<tr class="memdesc:a2355316960a6bf2e9691fded43249254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the object's reference count.  <a href="#a2355316960a6bf2e9691fded43249254">More...</a><br/></td></tr>
<tr class="separator:a2355316960a6bf2e9691fded43249254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0111caf12d101fc74abd832d44fbfa4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a0111caf12d101fc74abd832d44fbfa4f">getReferenceCount</a> () const noexcept</td></tr>
<tr class="memdesc:a0111caf12d101fc74abd832d44fbfa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object's current reference count.  <a href="#a0111caf12d101fc74abd832d44fbfa4f">More...</a><br/></td></tr>
<tr class="separator:a0111caf12d101fc74abd832d44fbfa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Member Functions</h3></td></tr>
<tr class="memitem:a86c1a0791cb6e98e63f7c1f7812c6eb5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a86c1a0791cb6e98e63f7c1f7812c6eb5">ReferenceCountedObject</a> ()</td></tr>
<tr class="memdesc:a86c1a0791cb6e98e63f7c1f7812c6eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the reference-counted object (with an initial ref count of zero).  <a href="#a86c1a0791cb6e98e63f7c1f7812c6eb5">More...</a><br/></td></tr>
<tr class="separator:a86c1a0791cb6e98e63f7c1f7812c6eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed87d7f91e5ae51c620947c61291375"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a7ed87d7f91e5ae51c620947c61291375">~ReferenceCountedObject</a> ()</td></tr>
<tr class="memdesc:a7ed87d7f91e5ae51c620947c61291375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a7ed87d7f91e5ae51c620947c61291375">More...</a><br/></td></tr>
<tr class="separator:a7ed87d7f91e5ae51c620947c61291375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbeeab431755e2be8ff09dfe9ea4c4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a9bbeeab431755e2be8ff09dfe9ea4c4d">resetReferenceCount</a> () noexcept</td></tr>
<tr class="memdesc:a9bbeeab431755e2be8ff09dfe9ea4c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the reference count to zero without deleting the object.  <a href="#a9bbeeab431755e2be8ff09dfe9ea4c4d">More...</a><br/></td></tr>
<tr class="separator:a9bbeeab431755e2be8ff09dfe9ea4c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a86c1a0791cb6e98e63f7c1f7812c6eb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReferenceCountedObject::ReferenceCountedObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the reference-counted object (with an initial ref count of zero). </p>

</div>
</div>
<a class="anchor" id="a7ed87d7f91e5ae51c620947c61291375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ReferenceCountedObject::~ReferenceCountedObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>References <a class="el" href="group__juce__core-system.html#ga1f96ab6751237979b907a54f52a7296a">jassert</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a878ca594f89f757d29af5a42ee51161f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReferenceCountedObject::incReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the object's reference count. </p>
<p>This is done automatically by the smart pointer, but is public just in case it's needed for nefarious purposes. </p>

</div>
</div>
<a class="anchor" id="a523f06d996130f24b36996b28b83d802"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReferenceCountedObject::decReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decreases the object's reference count. </p>
<p>If the count gets to zero, the object will be deleted. </p>

<p>References <a class="el" href="group__juce__core-system.html#ga1f96ab6751237979b907a54f52a7296a">jassert</a>.</p>

</div>
</div>
<a class="anchor" id="a2355316960a6bf2e9691fded43249254"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ReferenceCountedObject::decReferenceCountWithoutDeleting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decreases the object's reference count. </p>
<p>If the count gets to zero, the object will not be deleted, but this method will return true, allowing the caller to take care of deletion. </p>

<p>References <a class="el" href="group__juce__core-system.html#ga1f96ab6751237979b907a54f52a7296a">jassert</a>.</p>

</div>
</div>
<a class="anchor" id="a0111caf12d101fc74abd832d44fbfa4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ReferenceCountedObject::getReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object's current reference count. </p>

</div>
</div>
<a class="anchor" id="a9bbeeab431755e2be8ff09dfe9ea4c4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ReferenceCountedObject::resetReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the reference count to zero without deleting the object. </p>
<p>You should probably never need to use this! </p>

</div>
</div>

</div>
</div>
<a name="classSingleThreadedReferenceCountedObject" id="classSingleThreadedReferenceCountedObject"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class SingleThreadedReferenceCountedObject</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Adds reference-counting to an object. </p>
<p>This is effectively a version of the <a class="el" href="group__juce__core-memory.html#classReferenceCountedObject" title="A base class which provides methods for reference-counting. ">ReferenceCountedObject</a> class, but which uses a non-atomic counter, and so is not thread-safe (but which will be more efficient). For more details on how to use it, see the <a class="el" href="group__juce__core-memory.html#classReferenceCountedObject" title="A base class which provides methods for reference-counting. ">ReferenceCountedObject</a> class notes.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#classReferenceCountedObject" title="A base class which provides methods for reference-counting. ">ReferenceCountedObject</a>, <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr" title="A smart-pointer class which points to a reference-counted object. ">ReferenceCountedObjectPtr</a>, <a class="el" href="group__juce__core-containers.html#classReferenceCountedArray" title="Holds a list of objects derived from ReferenceCountedObject, or which implement basic reference-count...">ReferenceCountedArray</a> </dd></dl>
</div><div class="dynheader">
Inheritance diagram for SingleThreadedReferenceCountedObject:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSingleThreadedReferenceCountedObject__inherit__graph.svg" width="442" height="128"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ab372c9117f9352a7da5a3c9a7583091d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ab372c9117f9352a7da5a3c9a7583091d">incReferenceCount</a> () noexcept</td></tr>
<tr class="memdesc:ab372c9117f9352a7da5a3c9a7583091d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the object's reference count.  <a href="#ab372c9117f9352a7da5a3c9a7583091d">More...</a><br/></td></tr>
<tr class="separator:ab372c9117f9352a7da5a3c9a7583091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa690489ec6e529bf4588c46092d09156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aa690489ec6e529bf4588c46092d09156">decReferenceCount</a> () noexcept</td></tr>
<tr class="memdesc:aa690489ec6e529bf4588c46092d09156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the object's reference count.  <a href="#aa690489ec6e529bf4588c46092d09156">More...</a><br/></td></tr>
<tr class="separator:aa690489ec6e529bf4588c46092d09156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601ef52aa595fabee645c3c9c8ba2048"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a601ef52aa595fabee645c3c9c8ba2048">decReferenceCountWithoutDeleting</a> () noexcept</td></tr>
<tr class="memdesc:a601ef52aa595fabee645c3c9c8ba2048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decreases the object's reference count.  <a href="#a601ef52aa595fabee645c3c9c8ba2048">More...</a><br/></td></tr>
<tr class="separator:a601ef52aa595fabee645c3c9c8ba2048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84247db36d71ed860876941ed2045c85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a84247db36d71ed860876941ed2045c85">getReferenceCount</a> () const noexcept</td></tr>
<tr class="memdesc:a84247db36d71ed860876941ed2045c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object's current reference count.  <a href="#a84247db36d71ed860876941ed2045c85">More...</a><br/></td></tr>
<tr class="separator:a84247db36d71ed860876941ed2045c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Protected Member Functions</h3></td></tr>
<tr class="memitem:a33487e345c10684a13f90bfeb6756fe3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a33487e345c10684a13f90bfeb6756fe3">SingleThreadedReferenceCountedObject</a> ()</td></tr>
<tr class="memdesc:a33487e345c10684a13f90bfeb6756fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the reference-counted object (with an initial ref count of zero).  <a href="#a33487e345c10684a13f90bfeb6756fe3">More...</a><br/></td></tr>
<tr class="separator:a33487e345c10684a13f90bfeb6756fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf19dff5e45014675c24ab5c5235cb90"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#abf19dff5e45014675c24ab5c5235cb90">~SingleThreadedReferenceCountedObject</a> ()</td></tr>
<tr class="memdesc:abf19dff5e45014675c24ab5c5235cb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#abf19dff5e45014675c24ab5c5235cb90">More...</a><br/></td></tr>
<tr class="separator:abf19dff5e45014675c24ab5c5235cb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a33487e345c10684a13f90bfeb6756fe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SingleThreadedReferenceCountedObject::SingleThreadedReferenceCountedObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the reference-counted object (with an initial ref count of zero). </p>

</div>
</div>
<a class="anchor" id="abf19dff5e45014675c24ab5c5235cb90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SingleThreadedReferenceCountedObject::~SingleThreadedReferenceCountedObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

<p>References <a class="el" href="group__juce__core-system.html#ga1f96ab6751237979b907a54f52a7296a">jassert</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="ab372c9117f9352a7da5a3c9a7583091d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SingleThreadedReferenceCountedObject::incReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the object's reference count. </p>
<p>This is done automatically by the smart pointer, but is public just in case it's needed for nefarious purposes. </p>

</div>
</div>
<a class="anchor" id="aa690489ec6e529bf4588c46092d09156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SingleThreadedReferenceCountedObject::decReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decreases the object's reference count. </p>
<p>If the count gets to zero, the object will be deleted. </p>

<p>References <a class="el" href="group__juce__core-system.html#ga1f96ab6751237979b907a54f52a7296a">jassert</a>.</p>

</div>
</div>
<a class="anchor" id="a601ef52aa595fabee645c3c9c8ba2048"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SingleThreadedReferenceCountedObject::decReferenceCountWithoutDeleting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decreases the object's reference count. </p>
<p>If the count gets to zero, the object will not be deleted, but this method will return true, allowing the caller to take care of deletion. </p>

<p>References <a class="el" href="group__juce__core-system.html#ga1f96ab6751237979b907a54f52a7296a">jassert</a>.</p>

</div>
</div>
<a class="anchor" id="a84247db36d71ed860876941ed2045c85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SingleThreadedReferenceCountedObject::getReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object's current reference count. </p>

</div>
</div>

</div>
</div>
<a name="classReferenceCountedObjectPtr" id="classReferenceCountedObjectPtr"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ReferenceCountedObjectPtr</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ReferenceCountedObjectClass&gt;<br/>
class ReferenceCountedObjectPtr&lt; ReferenceCountedObjectClass &gt;</h3>

<p>A smart-pointer class which points to a reference-counted object. </p>
<p>The template parameter specifies the class of the object you want to point to - the easiest way to make a class reference-countable is to simply make it inherit from <a class="el" href="group__juce__core-memory.html#classReferenceCountedObject" title="A base class which provides methods for reference-counting. ">ReferenceCountedObject</a> or <a class="el" href="group__juce__core-memory.html#classSingleThreadedReferenceCountedObject" title="Adds reference-counting to an object. ">SingleThreadedReferenceCountedObject</a>, but if you need to, you can roll your own reference-countable class by implementing a set of methods called incReferenceCount(), decReferenceCount(), and decReferenceCountWithoutDeleting(). See <a class="el" href="group__juce__core-memory.html#classReferenceCountedObject" title="A base class which provides methods for reference-counting. ">ReferenceCountedObject</a> for examples of how these methods should behave.</p>
<p>When using this class, you'll probably want to create a typedef to abbreviate the full templated name - e.g. </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyClass  : <span class="keyword">public</span> <a class="code" href="group__juce__core-memory.html#classReferenceCountedObject">ReferenceCountedObject</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr&lt;MyClass&gt;</a> Ptr;</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#classReferenceCountedObject" title="A base class which provides methods for reference-counting. ">ReferenceCountedObject</a>, ReferenceCountedObjectArray </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:aeb4a0ddf04087aa15cf7b607f00c076a"><td class="memItemLeft" align="right" valign="top">typedef ReferenceCountedObjectClass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a></td></tr>
<tr class="memdesc:aeb4a0ddf04087aa15cf7b607f00c076a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class being referenced by this pointer.  <a href="#aeb4a0ddf04087aa15cf7b607f00c076a">More...</a><br/></td></tr>
<tr class="separator:aeb4a0ddf04087aa15cf7b607f00c076a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a95c5feac915f1b6731c69a9a44031bba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a95c5feac915f1b6731c69a9a44031bba">ReferenceCountedObjectPtr</a> () noexcept</td></tr>
<tr class="memdesc:a95c5feac915f1b6731c69a9a44031bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pointer to a null object.  <a href="#a95c5feac915f1b6731c69a9a44031bba">More...</a><br/></td></tr>
<tr class="separator:a95c5feac915f1b6731c69a9a44031bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f71a58ca790b16bbdcba846b44e9dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ad0f71a58ca790b16bbdcba846b44e9dd">ReferenceCountedObjectPtr</a> (<a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a> *refCountedObject) noexcept</td></tr>
<tr class="memdesc:ad0f71a58ca790b16bbdcba846b44e9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pointer to an object.  <a href="#ad0f71a58ca790b16bbdcba846b44e9dd">More...</a><br/></td></tr>
<tr class="separator:ad0f71a58ca790b16bbdcba846b44e9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f97bfd331d1c5b291d59b161c385210"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a3f97bfd331d1c5b291d59b161c385210">ReferenceCountedObjectPtr</a> (decltype(nullptr)) noexcept</td></tr>
<tr class="memdesc:a3f97bfd331d1c5b291d59b161c385210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pointer to a null object.  <a href="#a3f97bfd331d1c5b291d59b161c385210">More...</a><br/></td></tr>
<tr class="separator:a3f97bfd331d1c5b291d59b161c385210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48de50419a9cff7dafd67ab1571d5eb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a48de50419a9cff7dafd67ab1571d5eb8">ReferenceCountedObjectPtr</a> (const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a48de50419a9cff7dafd67ab1571d5eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another pointer.  <a href="#a48de50419a9cff7dafd67ab1571d5eb8">More...</a><br/></td></tr>
<tr class="separator:a48de50419a9cff7dafd67ab1571d5eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8246744495da90e679c22d592dec96df"><td class="memTemplParams" colspan="2">template&lt;typename Convertible &gt; </td></tr>
<tr class="memitem:a8246744495da90e679c22d592dec96df"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a8246744495da90e679c22d592dec96df">ReferenceCountedObjectPtr</a> (const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; Convertible &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a8246744495da90e679c22d592dec96df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another pointer.  <a href="#a8246744495da90e679c22d592dec96df">More...</a><br/></td></tr>
<tr class="separator:a8246744495da90e679c22d592dec96df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2ebf3f70f318e4392afdb803f9e3e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aab2ebf3f70f318e4392afdb803f9e3e9">operator=</a> (const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> &amp;other)</td></tr>
<tr class="memdesc:aab2ebf3f70f318e4392afdb803f9e3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this pointer to point at a different object.  <a href="#aab2ebf3f70f318e4392afdb803f9e3e9">More...</a><br/></td></tr>
<tr class="separator:aab2ebf3f70f318e4392afdb803f9e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad744900705e306991526a617d5e21690"><td class="memTemplParams" colspan="2">template&lt;typename Convertible &gt; </td></tr>
<tr class="memitem:ad744900705e306991526a617d5e21690"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ad744900705e306991526a617d5e21690">operator=</a> (const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; Convertible &gt; &amp;other)</td></tr>
<tr class="memdesc:ad744900705e306991526a617d5e21690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this pointer to point at a different object.  <a href="#ad744900705e306991526a617d5e21690">More...</a><br/></td></tr>
<tr class="separator:ad744900705e306991526a617d5e21690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9336efe926b6cbdc0eb8e0d3cbf33c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a9336efe926b6cbdc0eb8e0d3cbf33c87">operator=</a> (<a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a> *const newObject)</td></tr>
<tr class="memdesc:a9336efe926b6cbdc0eb8e0d3cbf33c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this pointer to point at a different object.  <a href="#a9336efe926b6cbdc0eb8e0d3cbf33c87">More...</a><br/></td></tr>
<tr class="separator:a9336efe926b6cbdc0eb8e0d3cbf33c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a3fabd321bf4984e3b2cd72a7e3f3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae5a3fabd321bf4984e3b2cd72a7e3f3f">ReferenceCountedObjectPtr</a> (<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ae5a3fabd321bf4984e3b2cd72a7e3f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes-over the object from another pointer.  <a href="#ae5a3fabd321bf4984e3b2cd72a7e3f3f">More...</a><br/></td></tr>
<tr class="separator:ae5a3fabd321bf4984e3b2cd72a7e3f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfe92f66e1ab8b3df57a9fde835bc54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aecfe92f66e1ab8b3df57a9fde835bc54">operator=</a> (<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:aecfe92f66e1ab8b3df57a9fde835bc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes-over the object from another pointer.  <a href="#aecfe92f66e1ab8b3df57a9fde835bc54">More...</a><br/></td></tr>
<tr class="separator:aecfe92f66e1ab8b3df57a9fde835bc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c9a9a2cf6e4767e2008b81ef9c8bca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a90c9a9a2cf6e4767e2008b81ef9c8bca">~ReferenceCountedObjectPtr</a> ()</td></tr>
<tr class="memdesc:a90c9a9a2cf6e4767e2008b81ef9c8bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a90c9a9a2cf6e4767e2008b81ef9c8bca">More...</a><br/></td></tr>
<tr class="separator:a90c9a9a2cf6e4767e2008b81ef9c8bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17565bd787961eaee3b0b1d2e3d88c7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a17565bd787961eaee3b0b1d2e3d88c7c">operator ReferencedType *</a> () const noexcept</td></tr>
<tr class="memdesc:a17565bd787961eaee3b0b1d2e3d88c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer references.  <a href="#a17565bd787961eaee3b0b1d2e3d88c7c">More...</a><br/></td></tr>
<tr class="separator:a17565bd787961eaee3b0b1d2e3d88c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e0886886746e1134970ee2323b80dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ab6e0886886746e1134970ee2323b80dd">get</a> () const noexcept</td></tr>
<tr class="memdesc:ab6e0886886746e1134970ee2323b80dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer references.  <a href="#ab6e0886886746e1134970ee2323b80dd">More...</a><br/></td></tr>
<tr class="separator:ab6e0886886746e1134970ee2323b80dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae7395b4bbdf44024703467f8a3191e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a5ae7395b4bbdf44024703467f8a3191e">getObject</a> () const noexcept</td></tr>
<tr class="memdesc:a5ae7395b4bbdf44024703467f8a3191e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer references.  <a href="#a5ae7395b4bbdf44024703467f8a3191e">More...</a><br/></td></tr>
<tr class="separator:a5ae7395b4bbdf44024703467f8a3191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57cc7cb51b53264016cc7d32159dc4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ab57cc7cb51b53264016cc7d32159dc4a">operator-&gt;</a> () const noexcept</td></tr>
<tr class="separator:ab57cc7cb51b53264016cc7d32159dc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="aeb4a0ddf04087aa15cf7b607f00c076a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ReferenceCountedObjectClass <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::<a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The class being referenced by this pointer. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a95c5feac915f1b6731c69a9a44031bba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a pointer to a null object. </p>

</div>
</div>
<a class="anchor" id="ad0f71a58ca790b16bbdcba846b44e9dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a> *&#160;</td>
          <td class="paramname"><em>refCountedObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a pointer to an object. </p>
<p>This will increment the object's reference-count. </p>

</div>
</div>
<a class="anchor" id="a3f97bfd331d1c5b291d59b161c385210"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> </td>
          <td>(</td>
          <td class="paramtype">decltype(nullptr)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a pointer to a null object. </p>

</div>
</div>
<a class="anchor" id="a48de50419a9cff7dafd67ab1571d5eb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies another pointer. </p>
<p>This will increment the object's reference-count. </p>

</div>
</div>
<a class="anchor" id="a8246744495da90e679c22d592dec96df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<div class="memtemplate">
template&lt;typename Convertible &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; Convertible &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies another pointer. </p>
<p>This will increment the object's reference-count (if it is non-null). </p>

</div>
</div>
<a class="anchor" id="ae5a3fabd321bf4984e3b2cd72a7e3f3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes-over the object from another pointer. </p>

</div>
</div>
<a class="anchor" id="a90c9a9a2cf6e4767e2008b81ef9c8bca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::~<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This will decrement the object's reference-count, which will cause the object to be deleted when the ref-count hits zero. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="aab2ebf3f70f318e4392afdb803f9e3e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&amp; <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes this pointer to point at a different object. </p>
<p>The reference count of the old object is decremented, and it might be deleted if it hits zero. The new object's count is incremented. </p>

<p>Referenced by <a class="el" href="group__juce__core-memory.html#aab2ebf3f70f318e4392afdb803f9e3e9">ReferenceCountedObjectPtr&lt; ImagePixelData &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="ad744900705e306991526a617d5e21690"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<div class="memtemplate">
template&lt;typename Convertible &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&amp; <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; Convertible &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes this pointer to point at a different object. </p>
<p>The reference count of the old object is decremented, and it might be deleted if it hits zero. The new object's count is incremented. </p>

</div>
</div>
<a class="anchor" id="a9336efe926b6cbdc0eb8e0d3cbf33c87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&amp; <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a> *const&#160;</td>
          <td class="paramname"><em>newObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes this pointer to point at a different object. </p>
<p>The reference count of the old object is decremented, and it might be deleted if it hits zero. The new object's count is incremented. </p>

</div>
</div>
<a class="anchor" id="aecfe92f66e1ab8b3df57a9fde835bc54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&amp; <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes-over the object from another pointer. </p>

</div>
</div>
<a class="anchor" id="a17565bd787961eaee3b0b1d2e3d88c7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::operator <a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a> * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer references. </p>
<p>The pointer returned may be null, of course. </p>

</div>
</div>
<a class="anchor" id="ab6e0886886746e1134970ee2323b80dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a>* <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer references. </p>
<p>The pointer returned may be null, of course. </p>

<p>Referenced by <a class="el" href="group__juce__core-memory.html#a0c6e75034092864f959ed7a1389b0e98">WeakReference&lt; InterprocessConnection &gt;::get()</a>, <a class="el" href="classWeakReference_1_1Master.html#a90365081e5448c6a7db4b5d21d877fed">WeakReference&lt; ObjectType, ReferenceCountingType &gt;::Master::getSharedPointer()</a>, <a class="el" href="group__juce__core-memory.html#ad744900705e306991526a617d5e21690">ReferenceCountedObjectPtr&lt; ImagePixelData &gt;::operator=()</a>, <a class="el" href="group__juce__core-memory.html#a523f66357f106bdf39cd5b49973b3177">WeakReference&lt; InterprocessConnection &gt;::wasObjectDeleted()</a>, and <a class="el" href="classWeakReference_1_1Master.html#a9fc11ef197bae4a674b18e4793bed161">WeakReference&lt; ObjectType, ReferenceCountingType &gt;::Master::~Master()</a>.</p>

</div>
</div>
<a class="anchor" id="a5ae7395b4bbdf44024703467f8a3191e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a>* <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::getObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer references. </p>
<p>The pointer returned may be null, of course. </p>

</div>
</div>
<a class="anchor" id="ab57cc7cb51b53264016cc7d32159dc4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ReferenceCountedObjectClass&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#aeb4a0ddf04087aa15cf7b607f00c076a">ReferencedType</a>* <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<a name="classScopedPointer" id="classScopedPointer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ScopedPointer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ObjectType&gt;<br/>
class ScopedPointer&lt; ObjectType &gt;</h3>

<p>This class holds a pointer which is automatically deleted when this object goes out of scope. </p>
<p>Once a pointer has been passed to a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, it will make sure that the pointer gets deleted when the <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> is deleted. Using the <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> on the stack or as member variables is a good way to use RAII to avoid accidentally leaking dynamically created objects.</p>
<p>A <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> can be used in pretty much the same way that you'd use a normal pointer to an object. If you use the assignment operator to assign a different object to a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, the old one will be automatically deleted.</p>
<p>Important note: The class is designed to hold a pointer to an object, NOT to an array! It calls delete on its payload, not delete[], so do not give it an array to hold! For that kind of purpose, you should be using <a class="el" href="group__juce__core-memory.html#classHeapBlock" title="Very simple container class to hold a pointer to some data on the heap. ">HeapBlock</a> or <a class="el" href="group__juce__core-containers.html#classArray" title="Holds a resizable array of primitive or copy-by-value objects. ">Array</a> instead.</p>
<p>A const <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> is guaranteed not to lose ownership of its object or change the object to which it points during its lifetime. This means that making a copy of a const <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> is impossible, as that would involve the new copy taking ownership from the old one.</p>
<p>If you need to get a pointer out of a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> without it being deleted, you can use the <a class="el" href="group__juce__core-memory.html#a10c8f696fec0cca763b067ec3e469199" title="Removes the current object from this ScopedPointer without deleting it. ">release()</a> method.</p>
<p>Something to note is the main difference between this class and the std::auto_ptr class, which is that <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> provides a cast-to-object operator, whereas std::auto_ptr requires that you always call <a class="el" href="group__juce__core-memory.html#ac65fb45b9eb2d53773489fcfbc6fd740" title="Returns the object that this ScopedPointer refers to. ">get()</a> to retrieve the pointer. The advantages of providing the cast is that you don't need to call <a class="el" href="group__juce__core-memory.html#ac65fb45b9eb2d53773489fcfbc6fd740" title="Returns the object that this ScopedPointer refers to. ">get()</a>, so can use the <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> in pretty much exactly the same way as a raw pointer. The disadvantage is that the compiler is free to use the cast in unexpected and sometimes dangerous ways - in particular, it becomes difficult to return a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> as the result of a function. To avoid this causing errors, <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> contains an overloaded constructor that should cause a syntax error in these circumstances, but it does mean that instead of returning a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> from a function, you'd need to return a raw pointer (or use a std::auto_ptr instead). </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ac187958296e33aa057dd37478ea70400"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ac187958296e33aa057dd37478ea70400">ScopedPointer</a> () noexcept</td></tr>
<tr class="memdesc:ac187958296e33aa057dd37478ea70400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> containing a null pointer.  <a href="#ac187958296e33aa057dd37478ea70400">More...</a><br/></td></tr>
<tr class="separator:ac187958296e33aa057dd37478ea70400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e3396a5a530aba0c6109d709c549b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a32e3396a5a530aba0c6109d709c549b0">ScopedPointer</a> (decltype(nullptr)) noexcept</td></tr>
<tr class="memdesc:a32e3396a5a530aba0c6109d709c549b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> containing a null pointer.  <a href="#a32e3396a5a530aba0c6109d709c549b0">More...</a><br/></td></tr>
<tr class="separator:a32e3396a5a530aba0c6109d709c549b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a7843e49c3ff719f06607b6e908f7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a44a7843e49c3ff719f06607b6e908f7d">ScopedPointer</a> (ObjectType *const objectToTakePossessionOf) noexcept</td></tr>
<tr class="memdesc:a44a7843e49c3ff719f06607b6e908f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> that owns the specified object.  <a href="#a44a7843e49c3ff719f06607b6e908f7d">More...</a><br/></td></tr>
<tr class="separator:a44a7843e49c3ff719f06607b6e908f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04688b1561dd9d861ca80c6deb63a233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a04688b1561dd9d861ca80c6deb63a233">ScopedPointer</a> (<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> &amp;objectToTransferFrom) noexcept</td></tr>
<tr class="memdesc:a04688b1561dd9d861ca80c6deb63a233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> that takes its pointer from another <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>.  <a href="#a04688b1561dd9d861ca80c6deb63a233">More...</a><br/></td></tr>
<tr class="separator:a04688b1561dd9d861ca80c6deb63a233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c540f0121065aafa5f9607362fc1450"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a3c540f0121065aafa5f9607362fc1450">~ScopedPointer</a> ()</td></tr>
<tr class="memdesc:a3c540f0121065aafa5f9607362fc1450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a3c540f0121065aafa5f9607362fc1450">More...</a><br/></td></tr>
<tr class="separator:a3c540f0121065aafa5f9607362fc1450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefc7940828d72c056e03804cd6bea9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#afefc7940828d72c056e03804cd6bea9f">operator=</a> (<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> &amp;objectToTransferFrom)</td></tr>
<tr class="memdesc:afefc7940828d72c056e03804cd6bea9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> to point to a new object.  <a href="#afefc7940828d72c056e03804cd6bea9f">More...</a><br/></td></tr>
<tr class="separator:afefc7940828d72c056e03804cd6bea9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ee7f038e57471539d3181141c0390e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a88ee7f038e57471539d3181141c0390e">operator=</a> (ObjectType *const newObjectToTakePossessionOf)</td></tr>
<tr class="memdesc:a88ee7f038e57471539d3181141c0390e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> to point to a new object.  <a href="#a88ee7f038e57471539d3181141c0390e">More...</a><br/></td></tr>
<tr class="separator:a88ee7f038e57471539d3181141c0390e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331080bd9920f0e479094f3250552b14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a331080bd9920f0e479094f3250552b14">ScopedPointer</a> (<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a331080bd9920f0e479094f3250552b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of another <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>.  <a href="#a331080bd9920f0e479094f3250552b14">More...</a><br/></td></tr>
<tr class="separator:a331080bd9920f0e479094f3250552b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8113d3daa273388cc0e6b0bad4f581c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a8113d3daa273388cc0e6b0bad4f581c2">operator=</a> (<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a8113d3daa273388cc0e6b0bad4f581c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take ownership of another <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>.  <a href="#a8113d3daa273388cc0e6b0bad4f581c2">More...</a><br/></td></tr>
<tr class="separator:a8113d3daa273388cc0e6b0bad4f581c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c241c736d79754fd6f8d305cce8bc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#af7c241c736d79754fd6f8d305cce8bc3">operator ObjectType *</a> () const noexcept</td></tr>
<tr class="memdesc:af7c241c736d79754fd6f8d305cce8bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> refers to.  <a href="#af7c241c736d79754fd6f8d305cce8bc3">More...</a><br/></td></tr>
<tr class="separator:af7c241c736d79754fd6f8d305cce8bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65fb45b9eb2d53773489fcfbc6fd740"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ac65fb45b9eb2d53773489fcfbc6fd740">get</a> () const noexcept</td></tr>
<tr class="memdesc:ac65fb45b9eb2d53773489fcfbc6fd740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> refers to.  <a href="#ac65fb45b9eb2d53773489fcfbc6fd740">More...</a><br/></td></tr>
<tr class="separator:ac65fb45b9eb2d53773489fcfbc6fd740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f48458a1656a6ef1bd35cb8452eed35"><td class="memItemLeft" align="right" valign="top">ObjectType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a2f48458a1656a6ef1bd35cb8452eed35">operator*</a> () const noexcept</td></tr>
<tr class="memdesc:a2f48458a1656a6ef1bd35cb8452eed35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> refers to.  <a href="#a2f48458a1656a6ef1bd35cb8452eed35">More...</a><br/></td></tr>
<tr class="separator:a2f48458a1656a6ef1bd35cb8452eed35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eedc84349cbe629cc1abb79ffa74e87"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a6eedc84349cbe629cc1abb79ffa74e87">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a6eedc84349cbe629cc1abb79ffa74e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lets you access methods and properties of the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> refers to.  <a href="#a6eedc84349cbe629cc1abb79ffa74e87">More...</a><br/></td></tr>
<tr class="separator:a6eedc84349cbe629cc1abb79ffa74e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c8f696fec0cca763b067ec3e469199"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a10c8f696fec0cca763b067ec3e469199">release</a> () noexcept</td></tr>
<tr class="memdesc:a10c8f696fec0cca763b067ec3e469199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the current object from this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> without deleting it.  <a href="#a10c8f696fec0cca763b067ec3e469199">More...</a><br/></td></tr>
<tr class="separator:a10c8f696fec0cca763b067ec3e469199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362cd8d5a212df0ee08691b75a4ba3de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a362cd8d5a212df0ee08691b75a4ba3de">swapWith</a> (<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a362cd8d5a212df0ee08691b75a4ba3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this object with that of another <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>.  <a href="#a362cd8d5a212df0ee08691b75a4ba3de">More...</a><br/></td></tr>
<tr class="separator:a362cd8d5a212df0ee08691b75a4ba3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258f418869b47381fc7ba61becbb209c"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a258f418869b47381fc7ba61becbb209c">createCopy</a> () const </td></tr>
<tr class="memdesc:a258f418869b47381fc7ba61becbb209c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the pointer is non-null, this will attempt to return a new copy of the object that is pointed to.  <a href="#a258f418869b47381fc7ba61becbb209c">More...</a><br/></td></tr>
<tr class="separator:a258f418869b47381fc7ba61becbb209c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ac187958296e33aa057dd37478ea70400"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> containing a null pointer. </p>

</div>
</div>
<a class="anchor" id="a32e3396a5a530aba0c6109d709c549b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> </td>
          <td>(</td>
          <td class="paramtype">decltype(nullptr)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> containing a null pointer. </p>

</div>
</div>
<a class="anchor" id="a44a7843e49c3ff719f06607b6e908f7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> </td>
          <td>(</td>
          <td class="paramtype">ObjectType *const&#160;</td>
          <td class="paramname"><em>objectToTakePossessionOf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> that owns the specified object. </p>

</div>
</div>
<a class="anchor" id="a04688b1561dd9d861ca80c6deb63a233"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;&#160;</td>
          <td class="paramname"><em>objectToTransferFrom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> that takes its pointer from another <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>. </p>
<p>Because a pointer can only belong to one <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, this transfers the pointer from the other object to this one, and the other object is reset to be a null pointer. </p>

</div>
</div>
<a class="anchor" id="a3c540f0121065aafa5f9607362fc1450"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::~<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>This will delete the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> currently refers to. </p>

</div>
</div>
<a class="anchor" id="a331080bd9920f0e479094f3250552b14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take ownership of another <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="afefc7940828d72c056e03804cd6bea9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&amp; <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;&#160;</td>
          <td class="paramname"><em>objectToTransferFrom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> to point to a new object. </p>
<p>Because a pointer can only belong to one <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>, this transfers the pointer from the other object to this one, and the other object is reset to be a null pointer.</p>
<p>If this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> already points to an object, that object will first be deleted. </p>

</div>
</div>
<a class="anchor" id="a88ee7f038e57471539d3181141c0390e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&amp; <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">ObjectType *const&#160;</td>
          <td class="paramname"><em>newObjectToTakePossessionOf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> to point to a new object. </p>
<p>If this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> already points to an object, that object will first be deleted.</p>
<p>The pointer that you pass in may be a nullptr. </p>

</div>
</div>
<a class="anchor" id="a8113d3daa273388cc0e6b0bad4f581c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&amp; <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take ownership of another <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>. </p>

</div>
</div>
<a class="anchor" id="af7c241c736d79754fd6f8d305cce8bc3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::operator ObjectType * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> refers to. </p>

</div>
</div>
<a class="anchor" id="ac65fb45b9eb2d53773489fcfbc6fd740"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> refers to. </p>

</div>
</div>
<a class="anchor" id="a2f48458a1656a6ef1bd35cb8452eed35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType&amp; <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> refers to. </p>

</div>
</div>
<a class="anchor" id="a6eedc84349cbe629cc1abb79ffa74e87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lets you access methods and properties of the object that this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> refers to. </p>

</div>
</div>
<a class="anchor" id="a10c8f696fec0cca763b067ec3e469199"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the current object from this <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> without deleting it. </p>
<p>This will return the current object, and set the <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> to a null pointer. </p>

<p>Referenced by <a class="el" href="group__juce__core-containers.html#a383de41801934f65b720a7019ed6ac8a">OwnedArray&lt; MidiBuffer &gt;::set()</a>.</p>

</div>
</div>
<a class="anchor" id="a362cd8d5a212df0ee08691b75a4ba3de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::swapWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this object with that of another <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a>. </p>
<p>The two objects simply exchange their pointers. </p>

</div>
</div>
<a class="anchor" id="a258f418869b47381fc7ba61becbb209c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt;::createCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the pointer is non-null, this will attempt to return a new copy of the object that is pointed to. </p>
<p>If the pointer is null, this will safely return a nullptr. </p>

</div>
</div>

</div>
</div>
<a name="classSharedResourcePointer" id="classSharedResourcePointer"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class SharedResourcePointer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename SharedObjectType&gt;<br/>
class SharedResourcePointer&lt; SharedObjectType &gt;</h3>

<p>A smart-pointer that automatically creates and manages the lifetime of a shared static instance of a class. </p>
<p>The SharedObjectType template type indicates the class to use for the shared object - the only requirements on this class are that it must have a public default constructor and destructor.</p>
<p>The <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer" title="A smart-pointer that automatically creates and manages the lifetime of a shared static instance of a ...">SharedResourcePointer</a> offers a pattern that differs from using a singleton or static instance of an object, because it uses reference-counting to make sure that the underlying shared object is automatically created/destroyed according to the number of <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer" title="A smart-pointer that automatically creates and manages the lifetime of a shared static instance of a ...">SharedResourcePointer</a> objects that exist. When the last one is deleted, the underlying object is also immediately destroyed. This allows you to use scoping to manage the lifetime of a shared resource.</p>
<p>Note: the construction/deletion of the shared object must not involve any code that makes recursive calls to a <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer" title="A smart-pointer that automatically creates and manages the lifetime of a shared static instance of a ...">SharedResourcePointer</a>, or you'll cause a deadlock.</p>
<p>Example: </p>
<div class="fragment"><div class="line"><span class="comment">// An example of a class that contains the shared data you want to use.</span></div>
<div class="line"><span class="keyword">struct </span>MySharedData</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// There&#39;s no need to ever create an instance of this class directly yourself,</span></div>
<div class="line">    <span class="comment">// but it does need a public constructor that does the initialisation.</span></div>
<div class="line">    MySharedData()</div>
<div class="line">    {</div>
<div class="line">        sharedStuff = generateHeavyweightStuff();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__juce__core-containers.html#classArray">Array&lt;SomeKindOfData&gt;</a> sharedStuff;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>DataUserClass</div>
<div class="line">{</div>
<div class="line">    DataUserClass()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Multiple instances of the DataUserClass will all have the same</span></div>
<div class="line">        <span class="comment">// shared common instance of MySharedData referenced by their sharedData</span></div>
<div class="line">        <span class="comment">// member variables.</span></div>
<div class="line">        useSharedStuff (sharedData-&gt;sharedStuff);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// By keeping this pointer as a member variable, the shared resource</span></div>
<div class="line">    <span class="comment">// is guaranteed to be available for as long as the DataUserClass object.</span></div>
<div class="line">    <a class="code" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer&lt;MySharedData&gt;</a> sharedData;</div>
<div class="line">};</div>
</div><!-- fragment --> </div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a37f5da91a94a3f34a8d467a11b1db2ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a37f5da91a94a3f34a8d467a11b1db2ae">SharedResourcePointer</a> ()</td></tr>
<tr class="memdesc:a37f5da91a94a3f34a8d467a11b1db2ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the shared object.  <a href="#a37f5da91a94a3f34a8d467a11b1db2ae">More...</a><br/></td></tr>
<tr class="separator:a37f5da91a94a3f34a8d467a11b1db2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e471d40bbf73438dec6480935341bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae0e471d40bbf73438dec6480935341bf">SharedResourcePointer</a> (const <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a> &amp;)</td></tr>
<tr class="separator:ae0e471d40bbf73438dec6480935341bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c04d52fa4de0490c3d3873dbc2ecf2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a47c04d52fa4de0490c3d3873dbc2ecf2">~SharedResourcePointer</a> ()</td></tr>
<tr class="memdesc:a47c04d52fa4de0490c3d3873dbc2ecf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a47c04d52fa4de0490c3d3873dbc2ecf2">More...</a><br/></td></tr>
<tr class="separator:a47c04d52fa4de0490c3d3873dbc2ecf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c266850a363bc4fb9ee2079d8c96397"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a5c266850a363bc4fb9ee2079d8c96397">operator SharedObjectType *</a> () const noexcept</td></tr>
<tr class="memdesc:a5c266850a363bc4fb9ee2079d8c96397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shared object.  <a href="#a5c266850a363bc4fb9ee2079d8c96397">More...</a><br/></td></tr>
<tr class="separator:a5c266850a363bc4fb9ee2079d8c96397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfb2015a9da695e57ea6460188c6146"><td class="memItemLeft" align="right" valign="top">SharedObjectType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aacfb2015a9da695e57ea6460188c6146">get</a> () const noexcept</td></tr>
<tr class="memdesc:aacfb2015a9da695e57ea6460188c6146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shared object.  <a href="#aacfb2015a9da695e57ea6460188c6146">More...</a><br/></td></tr>
<tr class="separator:aacfb2015a9da695e57ea6460188c6146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dc4311e7808984ef5bd796c57645c8"><td class="memItemLeft" align="right" valign="top">SharedObjectType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a34dc4311e7808984ef5bd796c57645c8">getObject</a> () const noexcept</td></tr>
<tr class="memdesc:a34dc4311e7808984ef5bd796c57645c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer references.  <a href="#a34dc4311e7808984ef5bd796c57645c8">More...</a><br/></td></tr>
<tr class="separator:a34dc4311e7808984ef5bd796c57645c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66baf5a23724ae4da705d4f31008d63"><td class="memItemLeft" align="right" valign="top">SharedObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ac66baf5a23724ae4da705d4f31008d63">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:ac66baf5a23724ae4da705d4f31008d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the shared object.  <a href="#ac66baf5a23724ae4da705d4f31008d63">More...</a><br/></td></tr>
<tr class="separator:ac66baf5a23724ae4da705d4f31008d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff7933c3ea884dda535acdfba665c48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#abff7933c3ea884dda535acdfba665c48">getReferenceCount</a> () const noexcept</td></tr>
<tr class="memdesc:abff7933c3ea884dda535acdfba665c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of SharedResourcePointers that are currently holding the shared object.  <a href="#abff7933c3ea884dda535acdfba665c48">More...</a><br/></td></tr>
<tr class="separator:abff7933c3ea884dda535acdfba665c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="a37f5da91a94a3f34a8d467a11b1db2ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SharedObjectType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the shared object. </p>
<p>If other <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer" title="A smart-pointer that automatically creates and manages the lifetime of a shared static instance of a ...">SharedResourcePointer</a> objects for this type already exist, then this one will simply point to the same shared object that they are already using. Otherwise, if this is the first <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer" title="A smart-pointer that automatically creates and manages the lifetime of a shared static instance of a ...">SharedResourcePointer</a> to be created, then a shared object will be created automatically. </p>

</div>
</div>
<a class="anchor" id="ae0e471d40bbf73438dec6480935341bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SharedObjectType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt;::<a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a47c04d52fa4de0490c3d3873dbc2ecf2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SharedObjectType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt;::~<a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>If no other <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer" title="A smart-pointer that automatically creates and manages the lifetime of a shared static instance of a ...">SharedResourcePointer</a> objects exist, this will also delete the shared object to which it refers. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="a5c266850a363bc4fb9ee2079d8c96397"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SharedObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt;::operator SharedObjectType * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the shared object. </p>

</div>
</div>
<a class="anchor" id="aacfb2015a9da695e57ea6460188c6146"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SharedObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SharedObjectType&amp; <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the shared object. </p>

</div>
</div>
<a class="anchor" id="a34dc4311e7808984ef5bd796c57645c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SharedObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SharedObjectType&amp; <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt;::getObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer references. </p>
<p>The pointer returned may be a nullptr, of course. </p>

</div>
</div>
<a class="anchor" id="ac66baf5a23724ae4da705d4f31008d63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SharedObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SharedObjectType* <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the shared object. </p>

</div>
</div>
<a class="anchor" id="abff7933c3ea884dda535acdfba665c48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SharedObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__juce__core-memory.html#classSharedResourcePointer">SharedResourcePointer</a>&lt; SharedObjectType &gt;::getReferenceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of SharedResourcePointers that are currently holding the shared object. </p>

</div>
</div>

</div>
</div>
<a name="classWeakReference" id="classWeakReference"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class WeakReference</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt;<br/>
class WeakReference&lt; ObjectType, ReferenceCountingType &gt;</h3>

<p>This class acts as a pointer which will automatically become null if the object to which it points is deleted. </p>
<p>To accomplish this, the source object needs to cooperate by performing a couple of simple tasks. It must embed a <a class="el" href="classWeakReference_1_1Master.html" title="This class is embedded inside an object to which you want to attach WeakReference pointers...">WeakReference::Master</a> object, which stores a shared pointer object, and must clear this master pointer in its destructor.</p>
<p>E.g. </p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyObject</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyObject()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// If you&#39;re planning on using your WeakReferences in a multi-threaded situation, you may choose</span></div>
<div class="line">        <span class="comment">// to create a WeakReference to the object here in the constructor, which will pre-initialise the</span></div>
<div class="line">        <span class="comment">// embedded object, avoiding an (extremely unlikely) race condition that could occur if multiple</span></div>
<div class="line">        <span class="comment">// threads overlap while creating the first WeakReference to it.</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~MyObject()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// This will zero all the references - you need to call this in your destructor.</span></div>
<div class="line">        masterReference.clear();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// You need to embed a variable of this type, with the name &quot;masterReference&quot; inside your object. If the</span></div>
<div class="line">    <span class="comment">// variable is not public, you should make your class a friend of WeakReference&lt;MyObject&gt; so that the</span></div>
<div class="line">    <span class="comment">// WeakReference class can access it.</span></div>
<div class="line">    <a class="code" href="classWeakReference_1_1Master.html">WeakReference&lt;MyObject&gt;::Master</a> masterReference;</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt;MyObject&gt;;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Here&#39;s an example of using a pointer..</span></div>
<div class="line"></div>
<div class="line">MyObject* n = <span class="keyword">new</span> MyObject();</div>
<div class="line"><a class="code" href="group__juce__core-memory.html#classWeakReference">WeakReference&lt;MyObject&gt;</a> myObjectRef = n;</div>
<div class="line"></div>
<div class="line">MyObject* pointer1 = myObjectRef;  <span class="comment">// returns a valid pointer to &#39;n&#39;</span></div>
<div class="line"><span class="keyword">delete</span> n;</div>
<div class="line">MyObject* pointer2 = myObjectRef;  <span class="comment">// returns a null pointer</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="classWeakReference_1_1Master.html" title="This class is embedded inside an object to which you want to attach WeakReference pointers...">WeakReference::Master</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a3fd7e314186f261fc5be42b68dd0d16e"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classWeakReference_1_1SharedPointer.html">SharedPointer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a3fd7e314186f261fc5be42b68dd0d16e">SharedRef</a></td></tr>
<tr class="separator:a3fd7e314186f261fc5be42b68dd0d16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:ae3208aa11ac7edae1816bc281113f4fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ae3208aa11ac7edae1816bc281113f4fa">WeakReference</a> () noexcept</td></tr>
<tr class="memdesc:ae3208aa11ac7edae1816bc281113f4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a null SafePointer.  <a href="#ae3208aa11ac7edae1816bc281113f4fa">More...</a><br/></td></tr>
<tr class="separator:ae3208aa11ac7edae1816bc281113f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29f6ae9e71a8a61d9208f420405b7af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#aa29f6ae9e71a8a61d9208f420405b7af">WeakReference</a> (ObjectType *const object)</td></tr>
<tr class="memdesc:aa29f6ae9e71a8a61d9208f420405b7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="group__juce__core-memory.html#classWeakReference" title="This class acts as a pointer which will automatically become null if the object to which it points is...">WeakReference</a> that points at the given object.  <a href="#aa29f6ae9e71a8a61d9208f420405b7af">More...</a><br/></td></tr>
<tr class="separator:aa29f6ae9e71a8a61d9208f420405b7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd877a29a839b13a046411f5c68f235"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a1dd877a29a839b13a046411f5c68f235">WeakReference</a> (const <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a1dd877a29a839b13a046411f5c68f235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of another <a class="el" href="group__juce__core-memory.html#classWeakReference" title="This class acts as a pointer which will automatically become null if the object to which it points is...">WeakReference</a>.  <a href="#a1dd877a29a839b13a046411f5c68f235">More...</a><br/></td></tr>
<tr class="separator:a1dd877a29a839b13a046411f5c68f235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7942f7ee23b8109f9fa591d25db7a810"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a7942f7ee23b8109f9fa591d25db7a810">WeakReference</a> (<a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a7942f7ee23b8109f9fa591d25db7a810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a7942f7ee23b8109f9fa591d25db7a810">More...</a><br/></td></tr>
<tr class="separator:a7942f7ee23b8109f9fa591d25db7a810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3634e0befe8b0f3d018c40a16ad8886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#ab3634e0befe8b0f3d018c40a16ad8886">operator=</a> (const <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> &amp;other)</td></tr>
<tr class="memdesc:ab3634e0befe8b0f3d018c40a16ad8886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another pointer to this one.  <a href="#ab3634e0befe8b0f3d018c40a16ad8886">More...</a><br/></td></tr>
<tr class="separator:ab3634e0befe8b0f3d018c40a16ad8886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2136a1c31a335eac280a8201733e226e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a2136a1c31a335eac280a8201733e226e">operator=</a> (ObjectType *const newObject)</td></tr>
<tr class="memdesc:a2136a1c31a335eac280a8201733e226e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies another pointer to this one.  <a href="#a2136a1c31a335eac280a8201733e226e">More...</a><br/></td></tr>
<tr class="separator:a2136a1c31a335eac280a8201733e226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add70a516b5a5d1bb669d4122dd9fab07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#add70a516b5a5d1bb669d4122dd9fab07">operator=</a> (<a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:add70a516b5a5d1bb669d4122dd9fab07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#add70a516b5a5d1bb669d4122dd9fab07">More...</a><br/></td></tr>
<tr class="separator:add70a516b5a5d1bb669d4122dd9fab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6e75034092864f959ed7a1389b0e98"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a0c6e75034092864f959ed7a1389b0e98">get</a> () const noexcept</td></tr>
<tr class="memdesc:a0c6e75034092864f959ed7a1389b0e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer refers to, or null if the object no longer exists.  <a href="#a0c6e75034092864f959ed7a1389b0e98">More...</a><br/></td></tr>
<tr class="separator:a0c6e75034092864f959ed7a1389b0e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91892403a30e5fa2d85b5dfae9a8d93e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a91892403a30e5fa2d85b5dfae9a8d93e">operator ObjectType *</a> () const noexcept</td></tr>
<tr class="memdesc:a91892403a30e5fa2d85b5dfae9a8d93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer refers to, or null if the object no longer exists.  <a href="#a91892403a30e5fa2d85b5dfae9a8d93e">More...</a><br/></td></tr>
<tr class="separator:a91892403a30e5fa2d85b5dfae9a8d93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047a1aebb9ada210bd5d0144df14df5c"><td class="memItemLeft" align="right" valign="top">ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a047a1aebb9ada210bd5d0144df14df5c">operator-&gt;</a> () noexcept</td></tr>
<tr class="memdesc:a047a1aebb9ada210bd5d0144df14df5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer refers to, or null if the object no longer exists.  <a href="#a047a1aebb9ada210bd5d0144df14df5c">More...</a><br/></td></tr>
<tr class="separator:a047a1aebb9ada210bd5d0144df14df5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b50a2cf7ff9d5f91ffb4d5b027c7b0e"><td class="memItemLeft" align="right" valign="top">const ObjectType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a5b50a2cf7ff9d5f91ffb4d5b027c7b0e">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a5b50a2cf7ff9d5f91ffb4d5b027c7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object that this pointer refers to, or null if the object no longer exists.  <a href="#a5b50a2cf7ff9d5f91ffb4d5b027c7b0e">More...</a><br/></td></tr>
<tr class="separator:a5b50a2cf7ff9d5f91ffb4d5b027c7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523f66357f106bdf39cd5b49973b3177"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a523f66357f106bdf39cd5b49973b3177">wasObjectDeleted</a> () const noexcept</td></tr>
<tr class="memdesc:a523f66357f106bdf39cd5b49973b3177"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns true if this reference has been pointing at an object, but that object has since been deleted.  <a href="#a523f66357f106bdf39cd5b49973b3177">More...</a><br/></td></tr>
<tr class="separator:a523f66357f106bdf39cd5b49973b3177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe33610764d2e40f4495f084d90f21c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#afbe33610764d2e40f4495f084d90f21c">operator==</a> (ObjectType *const object) const noexcept</td></tr>
<tr class="separator:afbe33610764d2e40f4495f084d90f21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a81cdfcb3a5aacdf4ae05e3c226fa29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__juce__core-memory.html#a0a81cdfcb3a5aacdf4ae05e3c226fa29">operator!=</a> (ObjectType *const object) const noexcept</td></tr>
<tr class="separator:a0a81cdfcb3a5aacdf4ae05e3c226fa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a class="anchor" id="a3fd7e314186f261fc5be42b68dd0d16e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt;<a class="el" href="classWeakReference_1_1SharedPointer.html">SharedPointer</a>&gt; <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::<a class="el" href="group__juce__core-memory.html#a3fd7e314186f261fc5be42b68dd0d16e">SharedRef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a class="anchor" id="ae3208aa11ac7edae1816bc281113f4fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::<a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a null SafePointer. </p>

</div>
</div>
<a class="anchor" id="aa29f6ae9e71a8a61d9208f420405b7af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::<a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> </td>
          <td>(</td>
          <td class="paramtype">ObjectType *const&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="group__juce__core-memory.html#classWeakReference" title="This class acts as a pointer which will automatically become null if the object to which it points is...">WeakReference</a> that points at the given object. </p>

</div>
</div>
<a class="anchor" id="a1dd877a29a839b13a046411f5c68f235"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::<a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of another <a class="el" href="group__juce__core-memory.html#classWeakReference" title="This class acts as a pointer which will automatically become null if the object to which it points is...">WeakReference</a>. </p>

</div>
</div>
<a class="anchor" id="a7942f7ee23b8109f9fa591d25db7a810"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::<a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a class="anchor" id="ab3634e0befe8b0f3d018c40a16ad8886"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&amp; <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies another pointer to this one. </p>

</div>
</div>
<a class="anchor" id="a2136a1c31a335eac280a8201733e226e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&amp; <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">ObjectType *const&#160;</td>
          <td class="paramname"><em>newObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies another pointer to this one. </p>

</div>
</div>
<a class="anchor" id="add70a516b5a5d1bb669d4122dd9fab07"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&amp; <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a class="anchor" id="a0c6e75034092864f959ed7a1389b0e98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer refers to, or null if the object no longer exists. </p>

</div>
</div>
<a class="anchor" id="a91892403a30e5fa2d85b5dfae9a8d93e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::operator ObjectType * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer refers to, or null if the object no longer exists. </p>

</div>
</div>
<a class="anchor" id="a047a1aebb9ada210bd5d0144df14df5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ObjectType* <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer refers to, or null if the object no longer exists. </p>

</div>
</div>
<a class="anchor" id="a5b50a2cf7ff9d5f91ffb4d5b027c7b0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ObjectType* <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object that this pointer refers to, or null if the object no longer exists. </p>

</div>
</div>
<a class="anchor" id="a523f66357f106bdf39cd5b49973b3177"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::wasObjectDeleted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns true if this reference has been pointing at an object, but that object has since been deleted. </p>
<p>If this reference was only ever pointing at a null pointer, this will return false. Using <a class="el" href="group__juce__core-memory.html#ab3634e0befe8b0f3d018c40a16ad8886" title="Copies another pointer to this one. ">operator=()</a> to make this refer to a different object will reset this flag to match the status of the reference from which you're copying. </p>

</div>
</div>
<a class="anchor" id="afbe33610764d2e40f4495f084d90f21c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">ObjectType *const&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a81cdfcb3a5aacdf4ae05e3c226fa29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType, class ReferenceCountingType = ReferenceCountedObject&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__juce__core-memory.html#classWeakReference">WeakReference</a>&lt; ObjectType, ReferenceCountingType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">ObjectType *const&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gab3639a79598b35f2116f4572af0d93f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define JUCE_LEAK_DETECTOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OwnerClass</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">friend</span> <span class="keyword">class </span>juce::LeakedObjectDetector&lt;OwnerClass&gt;; \</div>
<div class="line">        static <span class="keyword">const</span> <span class="keywordtype">char</span>* getLeakedObjectClassName() noexcept { <span class="keywordflow">return</span> #OwnerClass; } \</div>
<div class="line">        juce::LeakedObjectDetector&lt;OwnerClass&gt; <a class="code" href="group__juce__core-system.html#ga4dac24572cf8155c09d75f34c8297a47">JUCE_JOIN_MACRO</a> (leakDetector, __LINE__);</div>
<div class="ttc" id="group__juce__core-system_html_ga4dac24572cf8155c09d75f34c8297a47"><div class="ttname"><a href="group__juce__core-system.html#ga4dac24572cf8155c09d75f34c8297a47">JUCE_JOIN_MACRO</a></div><div class="ttdeci">#define JUCE_JOIN_MACRO(item1, item2)</div><div class="ttdoc">A good old-fashioned C macro concatenation helper. </div><div class="ttdef"><b>Definition:</b> juce_PlatformDefs.h:166</div></div>
</div><!-- fragment -->
<p>This macro lets you embed a leak-detecting object inside a class. </p>
<p>To use it, simply declare a <a class="el" href="group__juce__core-memory.html#gab3639a79598b35f2116f4572af0d93f1" title="This macro lets you embed a leak-detecting object inside a class. ">JUCE_LEAK_DETECTOR(YourClassName)</a> inside a private section of the class declaration. E.g.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyClass();</div>
<div class="line">    <span class="keywordtype">void</span> blahBlah();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="group__juce__core-memory.html#gab3639a79598b35f2116f4572af0d93f1">JUCE_LEAK_DETECTOR</a> (MyClass)</div>
<div class="line">};</div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-system.html#ga851b02724a8158a7f746c66b5758b3dd" title="This is a shorthand way of writing both a JUCE_DECLARE_NON_COPYABLE and JUCE_LEAK_DETECTOR macro for ...">JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR</a>, <a class="el" href="group__juce__core-memory.html#classLeakedObjectDetector" title="Embedding an instance of this class inside another class can be used as a low-overhead way of detecti...">LeakedObjectDetector</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad73fadcd76040b11a626d5bdf833ad49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define JUCE_AUTORELEASEPOOL&#160;&#160;&#160;@autoreleasepool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A macro that can be used to easily declare a local <a class="el" href="group__juce__core-memory.html#classScopedAutoReleasePool" title="A handy C++ wrapper that creates and deletes an NSAutoreleasePool object using RAII. ">ScopedAutoReleasePool</a> object for RAII-based obj-C autoreleasing. </p>
<p>Because this may use the @autoreleasepool syntax, you must follow the macro with a set of braces to mark the scope of the pool. </p>

</div>
</div>
<a class="anchor" id="ga881926ad904a631336e5d4b15f05c548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define juce_UseDebuggingNewOperator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated) This was a Windows-specific way of checking for object leaks - now please use the JUCE_LEAK_DETECTOR instead. </p>

</div>
</div>
<a class="anchor" id="gac46b66c5d38d6bd3a937af241d152a44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define juce_DeclareSingleton</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">classname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">doNotRecreateAfterDeletion&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to declare member variables and methods for a singleton class. </p>
<p>To use this, add the line juce_DeclareSingleton (MyClass, doNotRecreateAfterDeletion) to the class's definition.</p>
<p>Then put a macro juce_ImplementSingleton (MyClass) along with the class's implementation code.</p>
<p>It's also a very good idea to also add the call clearSingletonInstance() in your class's destructor, in case it is deleted by other means than deleteInstance()</p>
<p>Clients can then call the static method MyClass::getInstance() to get a pointer to the singleton, or MyClass::getInstanceWithoutCreating() which will return nullptr if no instance currently exists.</p>
<p>e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MySingleton</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MySingleton()</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ~MySingleton()</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// this ensures that no dangling pointers are left when the</span></div>
<div class="line">        <span class="comment">// singleton is deleted.</span></div>
<div class="line">        clearSingletonInstance();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__juce__core-memory.html#gac46b66c5d38d6bd3a937af241d152a44">juce_DeclareSingleton</a> (MySingleton, <span class="keyword">false</span>)</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__juce__core-memory.html#ga514301c5c269b87e3a3e3da3a6640f8f">juce_ImplementSingleton</a> (MySingleton)</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// example of usage:</span></div>
<div class="line">MySingleton* m = MySingleton::getInstance(); <span class="comment">// creates the singleton if there isn&#39;t already one.</span></div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">MySingleton::deleteInstance(); <span class="comment">// safely deletes the singleton (if it&#39;s been created).</span></div>
</div><!-- fragment --><p>If doNotRecreateAfterDeletion = true, it won't allow the object to be created more than once during the process's lifetime - i.e. after you've created and deleted the object, getInstance() will refuse to create another one. This can be useful to stop objects being accidentally re-created during your app's shutdown code.</p>
<p>If you know that your object will only be created and deleted by a single thread, you can use the slightly more efficient <a class="el" href="group__juce__core-memory.html#ga253f51f3a9ac2b4795e2ce08b2a756d9" title="Macro to declare member variables and methods for a singleton class. ">juce_DeclareSingleton_SingleThreaded()</a> macro instead of this one.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#ga514301c5c269b87e3a3e3da3a6640f8f" title="This is a counterpart to the juce_DeclareSingleton macro. ">juce_ImplementSingleton</a>, <a class="el" href="group__juce__core-memory.html#ga253f51f3a9ac2b4795e2ce08b2a756d9" title="Macro to declare member variables and methods for a singleton class. ">juce_DeclareSingleton_SingleThreaded</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga514301c5c269b87e3a3e3da3a6640f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define juce_ImplementSingleton</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">classname</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">\</div>
<div class="line">    classname* classname::_singletonInstance = <span class="keyword">nullptr</span>; \</div>
<div class="line">    juce::CriticalSection classname::_singletonLock;</div>
</div><!-- fragment -->
<p>This is a counterpart to the juce_DeclareSingleton macro. </p>
<p>After adding the juce_DeclareSingleton to the class definition, this macro has to be used in the cpp file. </p>

</div>
</div>
<a class="anchor" id="ga253f51f3a9ac2b4795e2ce08b2a756d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define juce_DeclareSingleton_SingleThreaded</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">classname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">doNotRecreateAfterDeletion&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to declare member variables and methods for a singleton class. </p>
<p>This is exactly the same as juce_DeclareSingleton, but doesn't use a critical section to make access to it thread-safe. If you know that your object will only ever be created or deleted by a single thread, then this is a more efficient version to use.</p>
<p>If doNotRecreateAfterDeletion = true, it won't allow the object to be created more than once during the process's lifetime - i.e. after you've created and deleted the object, getInstance() will refuse to create another one. This can be useful to stop objects being accidentally re-created during your app's shutdown code.</p>
<p>See the documentation for juce_DeclareSingleton for more information about how to use it, the only difference being that you have to use juce_ImplementSingleton_SingleThreaded instead of juce_ImplementSingleton.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#ga4404ed444ce628bab43d7fb68f7f1884" title="This is a counterpart to the juce_DeclareSingleton_SingleThreaded macro. ">juce_ImplementSingleton_SingleThreaded</a>, <a class="el" href="group__juce__core-memory.html#gac46b66c5d38d6bd3a937af241d152a44" title="Macro to declare member variables and methods for a singleton class. ">juce_DeclareSingleton</a>, <a class="el" href="group__juce__core-memory.html#ga354e37d287b39d02097f4f74be14af51" title="Macro to declare member variables and methods for a singleton class. ">juce_DeclareSingleton_SingleThreaded_Minimal</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga354e37d287b39d02097f4f74be14af51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define juce_DeclareSingleton_SingleThreaded_Minimal</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">classname</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">\</div>
<div class="line">    static classname* _singletonInstance;  \</div>
<div class="line">\</div>
<div class="line">    static classname* getInstance() \</div>
<div class="line">    { \</div>
<div class="line">        if (_singletonInstance == <span class="keyword">nullptr</span>) \</div>
<div class="line">            _singletonInstance = <span class="keyword">new</span> classname(); \</div>
<div class="line">\</div>
<div class="line">        return _singletonInstance; \</div>
<div class="line">    } \</div>
<div class="line">\</div>
<div class="line">    static <span class="keyword">inline</span> classname* getInstanceWithoutCreating() noexcept\</div>
<div class="line">    { \</div>
<div class="line">        return _singletonInstance; \</div>
<div class="line">    } \</div>
<div class="line">\</div>
<div class="line">    static <span class="keywordtype">void</span> deleteInstance() \</div>
<div class="line">    { \</div>
<div class="line">        if (_singletonInstance != <span class="keyword">nullptr</span>) \</div>
<div class="line">        { \</div>
<div class="line">            classname* <span class="keyword">const</span> old = _singletonInstance; \</div>
<div class="line">            _singletonInstance = <span class="keyword">nullptr</span>; \</div>
<div class="line">            delete old; \</div>
<div class="line">        } \</div>
<div class="line">    } \</div>
<div class="line">\</div>
<div class="line">    void clearSingletonInstance() noexcept\</div>
<div class="line">    { \</div>
<div class="line">        if (_singletonInstance == <span class="keyword">this</span>) \</div>
<div class="line">            _singletonInstance = <span class="keyword">nullptr</span>; \</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Macro to declare member variables and methods for a singleton class. </p>
<p>This is like juce_DeclareSingleton_SingleThreaded, but doesn't do any checking for recursion or repeated instantiation. It's intended for use as a lightweight version of a singleton, where you're using it in very straightforward circumstances and don't need the extra checking.</p>
<p>Juce use the normal juce_ImplementSingleton_SingleThreaded as the counterpart to this declaration, as you would with juce_DeclareSingleton_SingleThreaded.</p>
<p>See the documentation for juce_DeclareSingleton for more information about how to use it, the only difference being that you have to use juce_ImplementSingleton_SingleThreaded instead of juce_ImplementSingleton.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__juce__core-memory.html#ga4404ed444ce628bab43d7fb68f7f1884" title="This is a counterpart to the juce_DeclareSingleton_SingleThreaded macro. ">juce_ImplementSingleton_SingleThreaded</a>, <a class="el" href="group__juce__core-memory.html#gac46b66c5d38d6bd3a937af241d152a44" title="Macro to declare member variables and methods for a singleton class. ">juce_DeclareSingleton</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4404ed444ce628bab43d7fb68f7f1884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define juce_ImplementSingleton_SingleThreaded</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">classname</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">\</div>
<div class="line">    classname* classname::_singletonInstance = <span class="keyword">nullptr</span>;</div>
</div><!-- fragment -->
<p>This is a counterpart to the juce_DeclareSingleton_SingleThreaded macro. </p>
<p>After adding juce_DeclareSingleton_SingleThreaded or juce_DeclareSingleton_SingleThreaded_Minimal to the class definition, this macro has to be used somewhere in the cpp file. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga48fb9b158a3767e6573d27a8160956ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zeromem </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a block of memory with zeros. </p>

<p>Referenced by <a class="el" href="group__juce__blocks__basics-littlefoot.html#a56ce74720ce0af67db2e4dfa4cfbdfd7">littlefoot::LittleFootRemoteHeap&lt; ImplementationClass &gt;::clear()</a>, <a class="el" href="group__juce__dsp-maths.html#a570ac6ecc61ae923d8541bba5077638e">Matrix&lt; ElementType &gt;::clear()</a>, <a class="el" href="group__juce__core-memory.html#a658838e2b07f498b169c87c73040b509">HeapBlock&lt; ObjectClass * &gt;::clear()</a>, <a class="el" href="group__juce__audio__processors-format__types.html#a502793d0d94d69f92ee0251a274eb48e">AudioUnitHelpers::clearAudioBuffer()</a>, <a class="el" href="group__juce__audio__formats-format.html#a263fd3b6a51850da53fe57688f9ccb46">AudioFormatReader::clearSamplesBeyondAvailableLength()</a>, <a class="el" href="classAudioUnitHelpers_1_1CoreAudioBufferList.html#aa06cbf692838e38fa57a45b2b3daca00">AudioUnitHelpers::CoreAudioBufferList::reset()</a>, and <a class="el" href="classSpeakerMappings_1_1VstSpeakerConfigurationHolder.html#acb8c4e917f6d2d0bb62c5a95dbba85d5">SpeakerMappings::VstSpeakerConfigurationHolder::VstSpeakerConfigurationHolder()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f3dbe374ad9280ed9ba72f510d8e5b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zerostruct </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>structure</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrites a structure or object with zeros. </p>

</div>
</div>
<a class="anchor" id="ga4163b928fab6bebea5691e97c72fc4fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void deleteAndZero </td>
          <td>(</td>
          <td class="paramtype">Type &amp;&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an object pointer, and sets the pointer to null. </p>
<p>Remember that it's not good c++ practice to use delete directly - always try to use a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> or other automatic lifetime-management system rather than resorting to deleting raw pointers! </p>

</div>
</div>
<a class="anchor" id="gaec283d962b8cbfef5e73f51129305913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename IntegerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* addBytesToPointer </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>basePointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A handy function which adds a number of bytes to any type of pointer and returns the result. </p>
<p>This can be useful to avoid casting pointers to a char* and back when you want to move them by a specific number of bytes, </p>

<p>Referenced by <a class="el" href="group__juce__core-text.html#a9b85316a9a8ab9a4c7b771cb07e06ecd">String::appendCharPointer()</a>, <a class="el" href="group__juce__dsp-containers.html#aeb336de5d0dcc24a7d5a10b1caddbfd2">AudioBlock&lt; float &gt;::AudioBlock()</a>, <a class="el" href="classAudioData_1_1ConverterInstance.html#a07faa7a55572f1f7ae837a9c8cbb0e1b">AudioData::ConverterInstance&lt; SourceSampleType, DestSampleType &gt;::convertSamples()</a>, <a class="el" href="structAudioFormatReader_1_1ReadHelper.html#ab1158f4802796adedd47088948930c7d">AudioFormatReader::ReadHelper&lt; DestSampleType, SourceSampleType, SourceEndianness &gt;::read()</a>, <a class="el" href="group__juce__audio__formats-format.html#a24f42faedcc80c376351a60de55593e9">MemoryMappedAudioFormatReader::sampleToPointer()</a>, <a class="el" href="group__juce__audio__formats-format.html#add131d9db2dfcdba098c4cc489797bb8">MemoryMappedAudioFormatReader::scanMinAndMaxInterleaved()</a>, and <a class="el" href="structAudioFormatWriter_1_1WriteHelper.html#af9c774c70ec8e459e633be63c049c915">AudioFormatWriter::WriteHelper&lt; DestSampleType, SourceSampleType, DestEndianness &gt;::write()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4503bc356769b69967532e23cb5595f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename IntegerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type* snapPointerToAlignment </td>
          <td>(</td>
          <td class="paramtype">Type *&#160;</td>
          <td class="paramname"><em>basePointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>alignmentBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A handy function to round up a pointer to the nearest multiple of a given number of bytes. </p>
<p>alignmentBytes must be a power of two. </p>

<p>Referenced by <a class="el" href="group__juce__dsp-containers.html#aeb336de5d0dcc24a7d5a10b1caddbfd2">AudioBlock&lt; float &gt;::AudioBlock()</a>, <a class="el" href="structSIMDRegister.html#a1c48b5e542e3317652a275394ed716c0">SIMDRegister&lt; Type &gt;::getNextSIMDAlignedPtr()</a>, and <a class="el" href="group__juce__dsp-processors.html#ae46879e5b0b30f52ebfc77416a17942b">FIR::Filter&lt; SampleType &gt;::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="ga667897ead2d6fd7f9f682bd8f75da26a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type1 , typename Type2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getAddressDifference </td>
          <td>(</td>
          <td class="paramtype">Type1 *&#160;</td>
          <td class="paramname"><em>pointer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type2 *&#160;</td>
          <td class="paramname"><em>pointer2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A handy function which returns the difference between any two pointers, in bytes. </p>
<p>The address of the second pointer is subtracted from the first, and the difference in bytes is returned. </p>

<p>Referenced by <a class="el" href="group__juce__core-text.html#af5732566217c2fbeb0830f605f90c989">CharacterFunctions::copyWithDestByteLimit()</a>.</p>

</div>
</div>
<a class="anchor" id="gab622db353f778dfccede23f101ec86bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Type* createCopyIfNotNull </td>
          <td>(</td>
          <td class="paramtype">const Type *&#160;</td>
          <td class="paramname"><em>objectToCopy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If a pointer is non-null, this returns a new copy of the object that it points to, or safely returns nullptr if the pointer is null. </p>

<p>Referenced by <a class="el" href="group__juce__core-containers.html#a5168676f4e3de540247025ceaec8ad32">OwnedArray&lt; MidiBuffer &gt;::addCopiesOf()</a>, and <a class="el" href="group__juce__core-memory.html#a258f418869b47381fc7ba61becbb209c">ScopedPointer&lt; ListViewport &gt;::createCopy()</a>.</p>

</div>
</div>
<a class="anchor" id="gad4e1363d40774f5bb55f6324c4ab1414"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type readUnaligned </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>srcPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A handy function to read un-aligned memory without a performance penalty or bus-error. </p>

</div>
</div>
<a class="anchor" id="gab39db7640be10d1fab314769f20d1ee5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeUnaligned </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A handy function to write un-aligned memory without a performance penalty or bus-error. </p>

</div>
</div>
<a class="anchor" id="ga9fe3092d0a699f09ea15287dd040181a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReferenceCountedObjectClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReferenceCountedObjectClass *const&#160;</td>
          <td class="paramname"><em>object2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two ReferenceCountedObjectPtrs. </p>

</div>
</div>
<a class="anchor" id="gaa1955b9309ddae26fc9abb53ecbdbec0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReferenceCountedObjectClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two ReferenceCountedObjectPtrs. </p>

</div>
</div>
<a class="anchor" id="ga5e78dbcfa8a842e773fb030c2f3d9781"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReferenceCountedObjectClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">ReferenceCountedObjectClass *&#160;</td>
          <td class="paramname"><em>object1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two ReferenceCountedObjectPtrs. </p>

</div>
</div>
<a class="anchor" id="ga98d9adee99bce84b370ccdbf0dda395b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReferenceCountedObjectClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReferenceCountedObjectClass *&#160;</td>
          <td class="paramname"><em>object2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two ReferenceCountedObjectPtrs. </p>

</div>
</div>
<a class="anchor" id="ga4ccf60dc1326abbf6445b7ca8ff9bb53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReferenceCountedObjectClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two ReferenceCountedObjectPtrs. </p>

</div>
</div>
<a class="anchor" id="ga3def35798a4ee95b9863d175deaeadfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReferenceCountedObjectClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">ReferenceCountedObjectClass *&#160;</td>
          <td class="paramname"><em>object1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classReferenceCountedObjectPtr">ReferenceCountedObjectPtr</a>&lt; ReferenceCountedObjectClass &gt; &amp;&#160;</td>
          <td class="paramname"><em>object2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two ReferenceCountedObjectPtrs. </p>

</div>
</div>
<a class="anchor" id="ga44c6f65eba15909069b2ae838cbd96d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectType *const&#160;</td>
          <td class="paramname"><em>pointer2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> with another pointer. </p>
<p>This can be handy for checking whether this is a null pointer. </p>

</div>
</div>
<a class="anchor" id="ga08ebf907fd87957ebdc43e49eb5cfccd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__juce__core-memory.html#classScopedPointer">ScopedPointer</a>&lt; ObjectType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointer1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ObjectType *const&#160;</td>
          <td class="paramname"><em>pointer2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares a <a class="el" href="group__juce__core-memory.html#classScopedPointer" title="This class holds a pointer which is automatically deleted when this object goes out of scope...">ScopedPointer</a> with another pointer. </p>
<p>This can be handy for checking whether this is a null pointer. </p>

</div>
</div>
<a class="anchor" id="gac2b033fd8e98d9c4dfbb57a88466d62f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> ByteOrder::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the upper and lower bytes of a 16-bit integer. </p>

<p>Referenced by <a class="el" href="group__juce__core-memory.html#ga9b284220a53da3852b131d98dd85fdbb">ByteOrder::swapIfBigEndian()</a>.</p>

</div>
</div>
<a class="anchor" id="ga039a6658618d891f825cdec00929356a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> ByteOrder::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the 4 bytes in a 32-bit integer. </p>

</div>
</div>
<a class="anchor" id="gaa754df407abe7487660dd3f223c87324"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> ByteOrder::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the order of the 8 bytes in a 64-bit integer. </p>

</div>
</div>
<a class="anchor" id="ga8461d39c7370a6adb9556d3235cbdbe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> ByteOrder::swapIfBigEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 16-bit unsigned int if the CPU is big-endian. </p>

</div>
</div>
<a class="anchor" id="ga433cad5a04c392b9c97658eb6de79aef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> ByteOrder::swapIfBigEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 32-bit unsigned int if the CPU is big-endian. </p>

</div>
</div>
<a class="anchor" id="ga3568cb8775a1fa8f67bec0a889582ade"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> ByteOrder::swapIfBigEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 64-bit unsigned int if the CPU is big-endian. </p>

</div>
</div>
<a class="anchor" id="ga878689f08a7a6ea436cd550c6538ee4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a> ByteOrder::swapIfBigEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 16-bit signed int if the CPU is big-endian. </p>

</div>
</div>
<a class="anchor" id="ga2ee1facdbe64e044d394093aad0042ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a> ByteOrder::swapIfBigEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 32-bit signed int if the CPU is big-endian. </p>

</div>
</div>
<a class="anchor" id="ga9869ab64491231b02a6cca33d6ff9f60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> ByteOrder::swapIfBigEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 64-bit signed int if the CPU is big-endian. </p>

</div>
</div>
<a class="anchor" id="ga9b284220a53da3852b131d98dd85fdbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ByteOrder::swapIfBigEndian </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 32-bit float if the CPU is big-endian. </p>

<p>References <a class="el" href="group__juce__core-memory.html#gac2b033fd8e98d9c4dfbb57a88466d62f">ByteOrder::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga92060f5baff564c7e346309473326b69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ByteOrder::swapIfBigEndian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 64-bit float if the CPU is big-endian. </p>

<p>References <a class="el" href="group__juce__core-memory.html#gac2b033fd8e98d9c4dfbb57a88466d62f">ByteOrder::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga374444379b6a0f2010e36fa985175b9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> ByteOrder::swapIfLittleEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 16-bit unsigned int if the CPU is little-endian. </p>

</div>
</div>
<a class="anchor" id="ga4a6108916f94343a894fd7a146d48000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> ByteOrder::swapIfLittleEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 32-bit unsigned int if the CPU is little-endian. </p>

</div>
</div>
<a class="anchor" id="ga08ca5e947cb823fc208ede0635387695"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> ByteOrder::swapIfLittleEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 64-bit unsigned int if the CPU is little-endian. </p>

</div>
</div>
<a class="anchor" id="ga744b0ba49fa5cd0323fbd0cb663a64a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a> ByteOrder::swapIfLittleEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga259fa4834387bd68627ddf37bb3ebdb9">int16</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 16-bit signed int if the CPU is little-endian. </p>

</div>
</div>
<a class="anchor" id="gae00631878bb112db9e31cb7987cd0114"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a> ByteOrder::swapIfLittleEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#ga43d43196463bde49cb067f5c20ab8481">int32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 32-bit signed int if the CPU is little-endian. </p>

</div>
</div>
<a class="anchor" id="ga531090b4ee8e06c95c8c6d0536aadd64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a> ByteOrder::swapIfLittleEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__juce__core-maths.html#gaecfc3c54bd29ad5964e1c1c3ccbf89df">int64</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 64-bit signed int if the CPU is little-endian. </p>

</div>
</div>
<a class="anchor" id="gabde05ef314c29aeb9f49c1dbe13f6fb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ByteOrder::swapIfLittleEndian </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 32-bit float if the CPU is little-endian. </p>

</div>
</div>
<a class="anchor" id="ga51aa557077c032ab3fec337e0b47b5f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ByteOrder::swapIfLittleEndian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the byte order of a 64-bit float if the CPU is little-endian. </p>

</div>
</div>
<a class="anchor" id="ga5ee16f591feb0902fddb472eb4057293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> ByteOrder::littleEndianInt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns 4 bytes into a little-endian integer. </p>

</div>
</div>
<a class="anchor" id="gaa68dab24810f92bd18f08471ca2b2bba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> ByteOrder::littleEndianInt64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns 8 bytes into a little-endian integer. </p>

</div>
</div>
<a class="anchor" id="gabfa2888cce7d46ea40f54fceb49b544c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> ByteOrder::littleEndianShort </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns 2 bytes into a little-endian integer. </p>

</div>
</div>
<a class="anchor" id="gaca1a20a5825bcbef1f7b6920e3eee99f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga1134b580f8da4de94ca6b1de4d37975e">uint32</a> ByteOrder::bigEndianInt </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns 4 bytes into a big-endian integer. </p>

</div>
</div>
<a class="anchor" id="gaf7c126f0a1015a0c9f5b91aac2991620"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga29940ae63ec06c9998bba873e25407ad">uint64</a> ByteOrder::bigEndianInt64 </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns 8 bytes into a big-endian integer. </p>

</div>
</div>
<a class="anchor" id="ga7716b1b156320f4668d93142c69d7a3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__juce__core-maths.html#ga05f6b0ae8f6a6e135b0e290c25fe0e4e">uint16</a> ByteOrder::bigEndianShort </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns 2 bytes into a big-endian integer. </p>

</div>
</div>
<a class="anchor" id="ga579da6322ef30e565507fdbf0b9faefb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ByteOrder::isBigEndian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the current CPU is big-endian. </p>

</div>
</div>
<a class="anchor" id="ga35200b99bb4420fe1401bb9f3bae52a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ByteOrder::littleEndian24Bit </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts 3 little-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits). </p>

</div>
</div>
<a class="anchor" id="ga0dffd4f0e34fdd69453104e89996507d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ByteOrder::bigEndian24Bit </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts 3 big-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits). </p>

</div>
</div>
<a class="anchor" id="ga287ad85e68c599c8dcfdb329aecefda7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ByteOrder::littleEndian24BitToChars </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a 24-bit number to 3 little-endian bytes. </p>

</div>
</div>
<a class="anchor" id="gaf30f589309d051d2e3476c4c62a698b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ByteOrder::bigEndian24BitToChars </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>destBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a 24-bit number to 3 big-endian bytes. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 19 2017 11:40:20 for JUCE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
